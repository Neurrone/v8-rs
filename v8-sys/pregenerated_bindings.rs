/* automatically generated by rust-bindgen */

#[doc(hidden)]

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        storage: Storage,
        align: [Align; 0],
    }

    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn new(storage: Storage) -> Self {
            Self { storage, align: [] }
        }

        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());

            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];

            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };

            let mask = 1 << bit_index;

            byte & mask == mask
        }

        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());

            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];

            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };

            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }

        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

            let mut val = 0;

            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }

            val
        }

        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct equal_to {
            pub _address: u8,
        }
        pub type equal_to_first_argument_type = u8;
        pub type equal_to_second_argument_type = u8;
        pub type equal_to_result_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct hash {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type ostream = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator__Not_user_specialized = u8;
        pub type allocator_value_type = u8;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr__Mybase = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct unique_ptr {
            pub _address: u8,
        }
        pub type unique_ptr__Mybase = u8;
        pub type unique_ptr_pointer = u8;
        pub type unique_ptr_element_type = u8;
        pub type unique_ptr_deleter_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string__Mybase = u8;
        pub type basic_string_traits_type = u8;
        pub type basic_string_allocator_type = u8;
        pub type basic_string__Alty = u8;
        pub type basic_string__Alty_traits = u8;
        pub type basic_string__Mydata_t = u8;
        pub type basic_string_value_type = u8;
        pub type basic_string_size_type = u8;
        pub type basic_string_difference_type = u8;
        pub type basic_string_pointer = u8;
        pub type basic_string_const_pointer = u8;
        pub type basic_string_reference = u8;
        pub type basic_string_const_reference = u8;
        pub type basic_string_iterator = u8;
        pub type basic_string_const_iterator = u8;
        pub type basic_string_reverse_iterator = u8;
        pub type basic_string_const_reverse_iterator = u8;
        pub type basic_string__Use_memcpy_move = u8;
        pub type basic_string__Is_elem_cptr = u8;
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Mybase = u8;
        pub type vector__Alty = u8;
        pub type vector__Alty_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_allocator_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_size_type = u8;
        pub type vector_difference_type = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub mod experimental {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod filesystem {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct unordered_set {
            pub _address: u8,
        }
        pub type unordered_set__Mytraits = u8;
        pub type unordered_set__Mybase = u8;
        pub type unordered_set_hasher = u8;
        pub type unordered_set_key_type = u8;
        pub type unordered_set_key_equal = u8;
        pub type unordered_set_key_compare = u8;
        pub type unordered_set_value_type = u8;
        pub type unordered_set_allocator_type = u8;
        pub type unordered_set_size_type = u8;
        pub type unordered_set_difference_type = u8;
        pub type unordered_set_pointer = u8;
        pub type unordered_set_const_pointer = u8;
        pub type unordered_set_reference = u8;
        pub type unordered_set_const_reference = u8;
        pub type unordered_set_iterator = u8;
        pub type unordered_set_const_iterator = u8;
        pub type unordered_set_local_iterator = u8;
        pub type unordered_set_const_local_iterator = u8;
        pub type unordered_set__Alnode = u8;
        pub type unordered_set__Alnode_traits = u8;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct _iobuf {
        pub _Placeholder: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout__iobuf() {
        assert_eq!(
            ::std::mem::size_of::<_iobuf>(),
            8usize,
            concat!("Size of: ", stringify!(_iobuf))
        );
        assert_eq!(
            ::std::mem::align_of::<_iobuf>(),
            8usize,
            concat!("Alignment of ", stringify!(_iobuf))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_iobuf>()))._Placeholder as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_iobuf),
                "::",
                stringify!(_Placeholder)
            )
        );
    }
    pub type FILE = root::_iobuf;
    pub mod v8 {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapProfiler {
            _unused: [u8; 0],
        }
        pub mod internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Isolate {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Object {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ScriptStreamingData {
                _unused: [u8; 0],
            }
            pub mod wasm {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct NativeModule {
                    _unused: [u8; 0],
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct StreamingDecoder {
                    _unused: [u8; 0],
                }
            }
            pub const kApiPointerSize: ::std::os::raw::c_int = 8;
            pub const kApiDoubleSize: ::std::os::raw::c_int = 8;
            pub const kApiIntSize: ::std::os::raw::c_int = 4;
            pub const kApiInt64Size: ::std::os::raw::c_int = 8;
            pub const kHeapObjectTag: ::std::os::raw::c_int = 1;
            pub const kWeakHeapObjectTag: ::std::os::raw::c_int = 3;
            pub const kHeapObjectTagSize: ::std::os::raw::c_int = 2;
            pub const kHeapObjectTagMask: isize = 3;
            pub const kSmiTag: ::std::os::raw::c_int = 0;
            pub const kSmiTagSize: ::std::os::raw::c_int = 1;
            pub const kSmiTagMask: isize = 1;
            pub const kSmiShiftSize: ::std::os::raw::c_int = 31;
            pub const kSmiValueSize: ::std::os::raw::c_int = 32;
            pub const kSmiMinValue: ::std::os::raw::c_int = -2147483648;
            pub const kSmiMaxValue: ::std::os::raw::c_int = 2147483647;
            pub const Internals_kHeapObjectMapOffset: ::std::os::raw::c_int = 0;
            pub const Internals_kMapInstanceTypeOffset: ::std::os::raw::c_int = 12;
            pub const Internals_kStringResourceOffset: ::std::os::raw::c_int = 24;
            pub const Internals_kOddballKindOffset: ::std::os::raw::c_int = 40;
            pub const Internals_kForeignAddressOffset: ::std::os::raw::c_int = 8;
            pub const Internals_kJSObjectHeaderSize: ::std::os::raw::c_int = 24;
            pub const Internals_kFixedArrayHeaderSize: ::std::os::raw::c_int = 16;
            pub const Internals_kContextHeaderSize: ::std::os::raw::c_int = 16;
            pub const Internals_kContextEmbedderDataIndex: ::std::os::raw::c_int = 5;
            pub const Internals_kFullStringRepresentationMask: ::std::os::raw::c_int = 15;
            pub const Internals_kStringEncodingMask: ::std::os::raw::c_int = 8;
            pub const Internals_kExternalTwoByteRepresentationTag: ::std::os::raw::c_int = 2;
            pub const Internals_kExternalOneByteRepresentationTag: ::std::os::raw::c_int = 10;
            pub const Internals_kIsolateEmbedderDataOffset: ::std::os::raw::c_int = 0;
            pub const Internals_kExternalMemoryOffset: ::std::os::raw::c_int = 32;
            pub const Internals_kExternalMemoryLimitOffset: ::std::os::raw::c_int = 40;
            pub const Internals_kExternalMemoryAtLastMarkCompactOffset: ::std::os::raw::c_int = 48;
            pub const Internals_kIsolateRootsOffset: ::std::os::raw::c_int = 72;
            pub const Internals_kUndefinedValueRootIndex: ::std::os::raw::c_int = 4;
            pub const Internals_kTheHoleValueRootIndex: ::std::os::raw::c_int = 5;
            pub const Internals_kNullValueRootIndex: ::std::os::raw::c_int = 6;
            pub const Internals_kTrueValueRootIndex: ::std::os::raw::c_int = 7;
            pub const Internals_kFalseValueRootIndex: ::std::os::raw::c_int = 8;
            pub const Internals_kEmptyStringRootIndex: ::std::os::raw::c_int = 9;
            pub const Internals_kNodeClassIdOffset: ::std::os::raw::c_int = 8;
            pub const Internals_kNodeFlagsOffset: ::std::os::raw::c_int = 11;
            pub const Internals_kNodeStateMask: ::std::os::raw::c_int = 7;
            pub const Internals_kNodeStateIsWeakValue: ::std::os::raw::c_int = 2;
            pub const Internals_kNodeStateIsPendingValue: ::std::os::raw::c_int = 3;
            pub const Internals_kNodeStateIsNearDeathValue: ::std::os::raw::c_int = 4;
            pub const Internals_kNodeIsIndependentShift: ::std::os::raw::c_int = 3;
            pub const Internals_kNodeIsActiveShift: ::std::os::raw::c_int = 4;
            pub const Internals_kFirstNonstringType: ::std::os::raw::c_int = 128;
            pub const Internals_kOddballType: ::std::os::raw::c_int = 131;
            pub const Internals_kForeignType: ::std::os::raw::c_int = 135;
            pub const Internals_kJSSpecialApiObjectType: ::std::os::raw::c_int = 1040;
            pub const Internals_kJSApiObjectType: ::std::os::raw::c_int = 1056;
            pub const Internals_kJSObjectType: ::std::os::raw::c_int = 1057;
            pub const Internals_kUndefinedOddballKind: ::std::os::raw::c_int = 5;
            pub const Internals_kNullOddballKind: ::std::os::raw::c_int = 3;
            pub const Internals_kNumIsolateDataSlots: u32 = 4;
            extern "C" {
                #[link_name = "\u{1}?CheckInitializedImpl@Internals@internal@v8@@SAXPEAVIsolate@3@@Z"]
                pub fn Internals_CheckInitializedImpl(isolate: *mut root::v8::Isolate);
            }
        }
        /// An object reference managed by the v8 garbage collector.
        ///
        /// All objects returned from v8 have to be tracked by the garbage
        /// collector so that it knows that the objects are still alive.  Also,
        /// because the garbage collector may move objects, it is unsafe to
        /// point directly to an object.  Instead, all objects are stored in
        /// handles which are known by the garbage collector and updated
        /// whenever an object moves.  Handles should always be passed by value
        /// (except in cases like out-parameters) and they should never be
        /// allocated on the heap.
        ///
        /// There are two types of handles: local and persistent handles.
        ///
        /// Local handles are light-weight and transient and typically used in
        /// local operations.  They are managed by HandleScopes. That means that a
        /// HandleScope must exist on the stack when they are created and that they are
        /// only valid inside of the HandleScope active during their creation.
        /// For passing a local handle to an outer HandleScope, an EscapableHandleScope
        /// and its Escape() method must be used.
        ///
        /// Persistent handles can be used when storing objects across several
        /// independent operations and have to be explicitly deallocated when they're no
        /// longer used.
        ///
        /// It is safe to extract the object stored in the handle by
        /// dereferencing the handle (for instance, to extract the Object* from
        /// a Local<Object>); the value will still be governed by a handle
        /// behind the scenes and the same rules apply to these values as to
        /// their handles.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Local<T> {
            pub val_: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        /// A MaybeLocal<> is a wrapper around Local<> that enforces a check whether
        /// the Local<> is empty before it can be used.
        ///
        /// If an API method returns a MaybeLocal<>, the API method can potentially fail
        /// either because an exception is thrown, or because an exception is pending,
        /// e.g. because a previous API call threw an exception that hasn't been caught
        /// yet, or because a TerminateExecution exception was thrown. In that case, an
        /// empty MaybeLocal is returned.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct MaybeLocal<T> {
            pub val_: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub const kInternalFieldsInWeakCallback: ::std::os::raw::c_int = 2;
        pub const kEmbedderFieldsInWeakCallback: ::std::os::raw::c_int = 2;
        /// An object reference that is independent of any handle scope.  Where
        /// a Local handle only lives as long as the HandleScope in which it was
        /// allocated, a PersistentBase handle remains valid until it is explicitly
        /// disposed using Reset().
        ///
        /// A persistent handle contains a reference to a storage cell within
        /// the V8 engine which holds an object value and which is updated by
        /// the garbage collector whenever the object is moved.  A new storage
        /// cell can be created using the constructor or PersistentBase::Reset and
        /// existing handles can be disposed using PersistentBase::Reset.
        ///
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PersistentBase<T> {
            pub val_: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        /// Helper class traits to allow copying and assignment of Persistent.
        /// This will clone the contents of storage cell, but not any of the flags, etc.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct CopyablePersistentTraits {
            pub _address: u8,
        }
        pub type CopyablePersistentTraits_CopyablePersistent<T> = root::v8::Persistent<T>;
        /// A PersistentBase which allows copy and assignment.
        ///
        /// Copy, assignment and destructor behavior is controlled by the traits
        /// class M.
        ///
        /// Note: Persistent class hierarchy is subject to future changes.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Persistent<T> {
            pub _base: root::v8::PersistentBase<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        /// A stack-allocated class that governs a number of local handles.
        /// After a handle scope has been created, all local handles will be
        /// allocated within that handle scope until either the handle scope is
        /// deleted or another handle scope is created.  If there is already a
        /// handle scope and a new one is created, all allocations will take
        /// place in the new handle scope until it is deleted.  After that,
        /// new handles will again be allocated in the original handle scope.
        ///
        /// After the handle scope of a local handle has been deleted the
        /// garbage collector will no longer track the object stored in the
        /// handle and may deallocate it.  The behavior of accessing a handle
        /// for which the handle scope has been deleted is undefined.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct HandleScope {
            pub isolate_: *mut root::v8::internal::Isolate,
            pub prev_next_: *mut *mut root::v8::internal::Object,
            pub prev_limit_: *mut *mut root::v8::internal::Object,
        }
        #[test]
        fn bindgen_test_layout_HandleScope() {
            assert_eq!(
                ::std::mem::size_of::<HandleScope>(),
                24usize,
                concat!("Size of: ", stringify!(HandleScope))
            );
            assert_eq!(
                ::std::mem::align_of::<HandleScope>(),
                8usize,
                concat!("Alignment of ", stringify!(HandleScope))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<HandleScope>())).isolate_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleScope),
                    "::",
                    stringify!(isolate_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<HandleScope>())).prev_next_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleScope),
                    "::",
                    stringify!(prev_next_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<HandleScope>())).prev_limit_ as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleScope),
                    "::",
                    stringify!(prev_limit_)
                )
            );
        }
        extern "C" {
            /// Counts the number of allocated handles.
            #[link_name = "\u{1}?NumberOfHandles@HandleScope@v8@@SAHPEAVIsolate@2@@Z"]
            pub fn HandleScope_NumberOfHandles(
                isolate: *mut root::v8::Isolate,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?Initialize@HandleScope@v8@@IEAAXPEAVIsolate@2@@Z"]
            pub fn HandleScope_Initialize(
                this: *mut root::v8::HandleScope,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?CreateHandle@HandleScope@v8@@KAPEAPEAVObject@internal@2@PEAVIsolate@42@PEAV342@@Z"]
            pub fn HandleScope_CreateHandle(
                isolate: *mut root::v8::internal::Isolate,
                value: *mut root::v8::internal::Object,
            ) -> *mut *mut root::v8::internal::Object;
        }
        extern "C" {
            #[link_name = "\u{1}??0HandleScope@v8@@QEAA@PEAVIsolate@1@@Z"]
            pub fn HandleScope_HandleScope(
                this: *mut root::v8::HandleScope,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DHandleScope@v8@@QEAAXXZ"]
            pub fn HandleScope_HandleScope_destructor(this: *mut root::v8::HandleScope);
        }
        impl HandleScope {
            #[inline]
            pub unsafe fn NumberOfHandles(
                isolate: *mut root::v8::Isolate,
            ) -> ::std::os::raw::c_int {
                HandleScope_NumberOfHandles(isolate)
            }
            #[inline]
            pub unsafe fn Initialize(&mut self, isolate: *mut root::v8::Isolate) {
                HandleScope_Initialize(self, isolate)
            }
            #[inline]
            pub unsafe fn CreateHandle(
                isolate: *mut root::v8::internal::Isolate,
                value: *mut root::v8::internal::Object,
            ) -> *mut *mut root::v8::internal::Object {
                HandleScope_CreateHandle(isolate, value)
            }
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                HandleScope_HandleScope(&mut __bindgen_tmp, isolate);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                HandleScope_HandleScope_destructor(self)
            }
        }
        /// A HandleScope which first allocates a handle in the current scope
        /// which will be later filled with the escape value.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct EscapableHandleScope {
            pub _base: root::v8::HandleScope,
            pub escape_slot_: *mut *mut root::v8::internal::Object,
        }
        #[test]
        fn bindgen_test_layout_EscapableHandleScope() {
            assert_eq!(
                ::std::mem::size_of::<EscapableHandleScope>(),
                32usize,
                concat!("Size of: ", stringify!(EscapableHandleScope))
            );
            assert_eq!(
                ::std::mem::align_of::<EscapableHandleScope>(),
                8usize,
                concat!("Alignment of ", stringify!(EscapableHandleScope))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<EscapableHandleScope>())).escape_slot_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EscapableHandleScope),
                    "::",
                    stringify!(escape_slot_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0EscapableHandleScope@v8@@QEAA@PEAVIsolate@1@@Z"]
            pub fn EscapableHandleScope_EscapableHandleScope(
                this: *mut root::v8::EscapableHandleScope,
                isolate: *mut root::v8::Isolate,
            );
        }
        impl EscapableHandleScope {
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                EscapableHandleScope_EscapableHandleScope(&mut __bindgen_tmp, isolate);
                __bindgen_tmp
            }
        }
        /// A SealHandleScope acts like a handle scope in which no handle allocations
        /// are allowed. It can be useful for debugging handle leaks.
        /// Handles can be allocated within inner normal HandleScopes.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct SealHandleScope {
            pub isolate_: *mut root::v8::internal::Isolate,
            pub prev_limit_: *mut *mut root::v8::internal::Object,
            pub prev_sealed_level_: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_SealHandleScope() {
            assert_eq!(
                ::std::mem::size_of::<SealHandleScope>(),
                24usize,
                concat!("Size of: ", stringify!(SealHandleScope))
            );
            assert_eq!(
                ::std::mem::align_of::<SealHandleScope>(),
                8usize,
                concat!("Alignment of ", stringify!(SealHandleScope))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SealHandleScope>())).isolate_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SealHandleScope),
                    "::",
                    stringify!(isolate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SealHandleScope>())).prev_limit_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SealHandleScope),
                    "::",
                    stringify!(prev_limit_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SealHandleScope>())).prev_sealed_level_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SealHandleScope),
                    "::",
                    stringify!(prev_sealed_level_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0SealHandleScope@v8@@QEAA@PEAVIsolate@1@@Z"]
            pub fn SealHandleScope_SealHandleScope(
                this: *mut root::v8::SealHandleScope,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DSealHandleScope@v8@@QEAAXXZ"]
            pub fn SealHandleScope_SealHandleScope_destructor(this: *mut root::v8::SealHandleScope);
        }
        impl SealHandleScope {
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SealHandleScope_SealHandleScope(&mut __bindgen_tmp, isolate);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                SealHandleScope_SealHandleScope_destructor(self)
            }
        }
        /// The superclass of values and API object templates.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Data {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Data() {
            assert_eq!(
                ::std::mem::size_of::<Data>(),
                1usize,
                concat!("Size of: ", stringify!(Data))
            );
            assert_eq!(
                ::std::mem::align_of::<Data>(),
                1usize,
                concat!("Alignment of ", stringify!(Data))
            );
        }
        /// A container type that holds relevant metadata for module loading.
        ///
        /// This is passed back to the embedder as part of
        /// HostImportModuleDynamicallyCallback for module loading.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ScriptOrModule {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_ScriptOrModule() {
            assert_eq!(
                ::std::mem::size_of::<ScriptOrModule>(),
                1usize,
                concat!("Size of: ", stringify!(ScriptOrModule))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptOrModule>(),
                1usize,
                concat!("Alignment of ", stringify!(ScriptOrModule))
            );
        }
        extern "C" {
            /// The name that was passed by the embedder as ResourceName to the
            /// ScriptOrigin. This can be either a v8::String or v8::Undefined.
            #[link_name = "\u{1}?GetResourceName@ScriptOrModule@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn ScriptOrModule_GetResourceName(
                this: *mut root::v8::ScriptOrModule,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// The options that were passed by the embedder as HostDefinedOptions to
            /// the ScriptOrigin.
            #[link_name = "\u{1}?GetHostDefinedOptions@ScriptOrModule@v8@@QEAA?AV?$Local@VPrimitiveArray@v8@@@2@XZ"]
            pub fn ScriptOrModule_GetHostDefinedOptions(
                this: *mut root::v8::ScriptOrModule,
            ) -> root::v8::Local<root::v8::PrimitiveArray>;
        }
        impl ScriptOrModule {
            #[inline]
            pub unsafe fn GetResourceName(&mut self) -> root::v8::Local<root::v8::Value> {
                ScriptOrModule_GetResourceName(self)
            }
            #[inline]
            pub unsafe fn GetHostDefinedOptions(
                &mut self,
            ) -> root::v8::Local<root::v8::PrimitiveArray> {
                ScriptOrModule_GetHostDefinedOptions(self)
            }
        }
        /// An array to hold Primitive values. This is used by the embedder to
        /// pass host defined options to the ScriptOptions during compilation.
        ///
        /// This is passed back to the embedder as part of
        /// HostImportModuleDynamicallyCallback for module loading.
        ///
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PrimitiveArray {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_PrimitiveArray() {
            assert_eq!(
                ::std::mem::size_of::<PrimitiveArray>(),
                1usize,
                concat!("Size of: ", stringify!(PrimitiveArray))
            );
            assert_eq!(
                ::std::mem::align_of::<PrimitiveArray>(),
                1usize,
                concat!("Alignment of ", stringify!(PrimitiveArray))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@PrimitiveArray@v8@@SA?AV?$Local@VPrimitiveArray@v8@@@2@PEAVIsolate@2@H@Z"]
            pub fn PrimitiveArray_New(
                isolate: *mut root::v8::Isolate,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::PrimitiveArray>;
        }
        extern "C" {
            #[link_name = "\u{1}?Length@PrimitiveArray@v8@@QEBAHXZ"]
            pub fn PrimitiveArray_Length(
                this: *const root::v8::PrimitiveArray,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?Set@PrimitiveArray@v8@@QEAAXPEAVIsolate@2@HV?$Local@VPrimitive@v8@@@2@@Z"]
            pub fn PrimitiveArray_Set(
                this: *mut root::v8::PrimitiveArray,
                isolate: *mut root::v8::Isolate,
                index: ::std::os::raw::c_int,
                item: root::v8::Local<root::v8::Primitive>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Get@PrimitiveArray@v8@@QEAA?AV?$Local@VPrimitive@v8@@@2@PEAVIsolate@2@H@Z"]
            pub fn PrimitiveArray_Get(
                this: *mut root::v8::PrimitiveArray,
                isolate: *mut root::v8::Isolate,
                index: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::Primitive>;
        }
        impl PrimitiveArray {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::PrimitiveArray> {
                PrimitiveArray_New(isolate, length)
            }
            #[inline]
            pub unsafe fn Length(&self) -> ::std::os::raw::c_int {
                PrimitiveArray_Length(self)
            }
            #[inline]
            pub unsafe fn Set(
                &mut self,
                isolate: *mut root::v8::Isolate,
                index: ::std::os::raw::c_int,
                item: root::v8::Local<root::v8::Primitive>,
            ) {
                PrimitiveArray_Set(self, isolate, index, item)
            }
            #[inline]
            pub unsafe fn Get(
                &mut self,
                isolate: *mut root::v8::Isolate,
                index: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::Primitive> {
                PrimitiveArray_Get(self, isolate, index)
            }
        }
        /// The optional attributes of ScriptOrigin.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ScriptOriginOptions {
            pub flags_: ::std::os::raw::c_int,
        }
        pub const ScriptOriginOptions_kIsSharedCrossOrigin:
            root::v8::ScriptOriginOptions__bindgen_ty_1 = 1;
        pub const ScriptOriginOptions_kIsOpaque: root::v8::ScriptOriginOptions__bindgen_ty_1 = 2;
        pub const ScriptOriginOptions_kIsWasm: root::v8::ScriptOriginOptions__bindgen_ty_1 = 4;
        pub const ScriptOriginOptions_kIsModule: root::v8::ScriptOriginOptions__bindgen_ty_1 = 8;
        pub type ScriptOriginOptions__bindgen_ty_1 = i32;
        #[test]
        fn bindgen_test_layout_ScriptOriginOptions() {
            assert_eq!(
                ::std::mem::size_of::<ScriptOriginOptions>(),
                4usize,
                concat!("Size of: ", stringify!(ScriptOriginOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptOriginOptions>(),
                4usize,
                concat!("Alignment of ", stringify!(ScriptOriginOptions))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptOriginOptions>())).flags_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOriginOptions),
                    "::",
                    stringify!(flags_)
                )
            );
        }
        /// The origin, within a file, of a script.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ScriptOrigin {
            pub resource_name_: root::v8::Local<root::v8::Value>,
            pub resource_line_offset_: root::v8::Local<root::v8::Integer>,
            pub resource_column_offset_: root::v8::Local<root::v8::Integer>,
            pub options_: root::v8::ScriptOriginOptions,
            pub script_id_: root::v8::Local<root::v8::Integer>,
            pub source_map_url_: root::v8::Local<root::v8::Value>,
            pub host_defined_options_: root::v8::Local<root::v8::PrimitiveArray>,
        }
        #[test]
        fn bindgen_test_layout_ScriptOrigin() {
            assert_eq!(
                ::std::mem::size_of::<ScriptOrigin>(),
                56usize,
                concat!("Size of: ", stringify!(ScriptOrigin))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptOrigin>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptOrigin))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptOrigin>())).resource_name_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOrigin),
                    "::",
                    stringify!(resource_name_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptOrigin>())).resource_line_offset_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOrigin),
                    "::",
                    stringify!(resource_line_offset_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptOrigin>())).resource_column_offset_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOrigin),
                    "::",
                    stringify!(resource_column_offset_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ScriptOrigin>())).options_ as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOrigin),
                    "::",
                    stringify!(options_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ScriptOrigin>())).script_id_ as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOrigin),
                    "::",
                    stringify!(script_id_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptOrigin>())).source_map_url_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOrigin),
                    "::",
                    stringify!(source_map_url_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptOrigin>())).host_defined_options_ as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptOrigin),
                    "::",
                    stringify!(host_defined_options_)
                )
            );
        }
        /// A compiled JavaScript script, not yet tied to a Context.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct UnboundScript {
            pub _address: u8,
        }
        pub const UnboundScript_kNoScriptId: ::std::os::raw::c_int = 0;
        #[test]
        fn bindgen_test_layout_UnboundScript() {
            assert_eq!(
                ::std::mem::size_of::<UnboundScript>(),
                1usize,
                concat!("Size of: ", stringify!(UnboundScript))
            );
            assert_eq!(
                ::std::mem::align_of::<UnboundScript>(),
                1usize,
                concat!("Alignment of ", stringify!(UnboundScript))
            );
        }
        extern "C" {
            /// Binds the script to the currently entered context.
            #[link_name = "\u{1}?BindToCurrentContext@UnboundScript@v8@@QEAA?AV?$Local@VScript@v8@@@2@XZ"]
            pub fn UnboundScript_BindToCurrentContext(
                this: *mut root::v8::UnboundScript,
            ) -> root::v8::Local<root::v8::Script>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetId@UnboundScript@v8@@QEAAHXZ"]
            pub fn UnboundScript_GetId(this: *mut root::v8::UnboundScript)
                -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?GetScriptName@UnboundScript@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn UnboundScript_GetScriptName(
                this: *mut root::v8::UnboundScript,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Data read from magic sourceURL comments.
            #[link_name = "\u{1}?GetSourceURL@UnboundScript@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn UnboundScript_GetSourceURL(
                this: *mut root::v8::UnboundScript,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Data read from magic sourceMappingURL comments.
            #[link_name = "\u{1}?GetSourceMappingURL@UnboundScript@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn UnboundScript_GetSourceMappingURL(
                this: *mut root::v8::UnboundScript,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Returns zero based line number of the code_pos location in the script.
            /// -1 will be returned if no information available.
            #[link_name = "\u{1}?GetLineNumber@UnboundScript@v8@@QEAAHH@Z"]
            pub fn UnboundScript_GetLineNumber(
                this: *mut root::v8::UnboundScript,
                code_pos: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        impl UnboundScript {
            #[inline]
            pub unsafe fn BindToCurrentContext(&mut self) -> root::v8::Local<root::v8::Script> {
                UnboundScript_BindToCurrentContext(self)
            }
            #[inline]
            pub unsafe fn GetId(&mut self) -> ::std::os::raw::c_int {
                UnboundScript_GetId(self)
            }
            #[inline]
            pub unsafe fn GetScriptName(&mut self) -> root::v8::Local<root::v8::Value> {
                UnboundScript_GetScriptName(self)
            }
            #[inline]
            pub unsafe fn GetSourceURL(&mut self) -> root::v8::Local<root::v8::Value> {
                UnboundScript_GetSourceURL(self)
            }
            #[inline]
            pub unsafe fn GetSourceMappingURL(&mut self) -> root::v8::Local<root::v8::Value> {
                UnboundScript_GetSourceMappingURL(self)
            }
            #[inline]
            pub unsafe fn GetLineNumber(
                &mut self,
                code_pos: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                UnboundScript_GetLineNumber(self, code_pos)
            }
        }
        /// A compiled JavaScript module, not yet tied to a Context.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct UnboundModuleScript {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_UnboundModuleScript() {
            assert_eq!(
                ::std::mem::size_of::<UnboundModuleScript>(),
                1usize,
                concat!("Size of: ", stringify!(UnboundModuleScript))
            );
            assert_eq!(
                ::std::mem::align_of::<UnboundModuleScript>(),
                1usize,
                concat!("Alignment of ", stringify!(UnboundModuleScript))
            );
        }
        /// A location in JavaScript source.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Location {
            pub line_number_: ::std::os::raw::c_int,
            pub column_number_: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_Location() {
            assert_eq!(
                ::std::mem::size_of::<Location>(),
                8usize,
                concat!("Size of: ", stringify!(Location))
            );
            assert_eq!(
                ::std::mem::align_of::<Location>(),
                4usize,
                concat!("Alignment of ", stringify!(Location))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Location>())).line_number_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Location),
                    "::",
                    stringify!(line_number_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Location>())).column_number_ as *const _ as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Location),
                    "::",
                    stringify!(column_number_)
                )
            );
        }
        /// A compiled JavaScript module.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Module {
            pub _address: u8,
        }
        pub const Module_Status_kUninstantiated: root::v8::Module_Status = 0;
        pub const Module_Status_kInstantiating: root::v8::Module_Status = 1;
        pub const Module_Status_kInstantiated: root::v8::Module_Status = 2;
        pub const Module_Status_kEvaluating: root::v8::Module_Status = 3;
        pub const Module_Status_kEvaluated: root::v8::Module_Status = 4;
        pub const Module_Status_kErrored: root::v8::Module_Status = 5;
        /// The different states a module can be in.
        ///
        /// This corresponds to the states used in ECMAScript except that "evaluated"
        /// is split into kEvaluated and kErrored, indicating success and failure,
        /// respectively.
        pub type Module_Status = i32;
        pub type Module_ResolveCallback = ::std::option::Option<
            unsafe extern "C" fn(
                context: root::v8::Local<root::v8::Context>,
                specifier: root::v8::Local<root::v8::String>,
                referrer: root::v8::Local<root::v8::Module>,
            ) -> root::v8::MaybeLocal<root::v8::Module>,
        >;
        #[test]
        fn bindgen_test_layout_Module() {
            assert_eq!(
                ::std::mem::size_of::<Module>(),
                1usize,
                concat!("Size of: ", stringify!(Module))
            );
            assert_eq!(
                ::std::mem::align_of::<Module>(),
                1usize,
                concat!("Alignment of ", stringify!(Module))
            );
        }
        extern "C" {
            /// Returns the module's current status.
            #[link_name = "\u{1}?GetStatus@Module@v8@@QEBA?AW4Status@12@XZ"]
            pub fn Module_GetStatus(this: *const root::v8::Module) -> root::v8::Module_Status;
        }
        extern "C" {
            /// For a module in kErrored status, this returns the corresponding exception.
            #[link_name = "\u{1}?GetException@Module@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Module_GetException(
                this: *const root::v8::Module,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Returns the number of modules requested by this module.
            #[link_name = "\u{1}?GetModuleRequestsLength@Module@v8@@QEBAHXZ"]
            pub fn Module_GetModuleRequestsLength(
                this: *const root::v8::Module,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the ith module specifier in this module.
            /// i must be < GetModuleRequestsLength() and >= 0.
            #[link_name = "\u{1}?GetModuleRequest@Module@v8@@QEBA?AV?$Local@VString@v8@@@2@H@Z"]
            pub fn Module_GetModuleRequest(
                this: *const root::v8::Module,
                i: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Returns the source location (line number and column number) of the ith
            /// module specifier's first occurrence in this module.
            #[link_name = "\u{1}?GetModuleRequestLocation@Module@v8@@QEBA?AVLocation@2@H@Z"]
            pub fn Module_GetModuleRequestLocation(
                this: *const root::v8::Module,
                i: ::std::os::raw::c_int,
            ) -> root::v8::Location;
        }
        extern "C" {
            /// Returns the identity hash for this object.
            #[link_name = "\u{1}?GetIdentityHash@Module@v8@@QEBAHXZ"]
            pub fn Module_GetIdentityHash(this: *const root::v8::Module) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Instantiates the module and its dependencies.
            ///
            /// Returns an empty Maybe<bool> if an exception occurred during
            /// instantiation. (In the case where the callback throws an exception, that
            /// exception is propagated.)
            #[link_name = "\u{1}?InstantiateModule@Module@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@P6A?AV?$MaybeLocal@VModule@v8@@@2@0V?$Local@VString@v8@@@2@V?$Local@VModule@v8@@@2@@Z@Z"]
            pub fn Module_InstantiateModule(
                this: *mut root::v8::Module,
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::Module_ResolveCallback,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Evaluates the module and its dependencies.
            ///
            /// If status is kInstantiated, run the module's code. On success, set status
            /// to kEvaluated and return the completion value; on failure, set status to
            /// kErrored and propagate the thrown exception (which is then also available
            /// via |GetException|).
            #[link_name = "\u{1}?Evaluate@Module@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Module_Evaluate(
                this: *mut root::v8::Module,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Returns the namespace object of this module.
            ///
            /// The module's status must be at least kInstantiated.
            #[link_name = "\u{1}?GetModuleNamespace@Module@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Module_GetModuleNamespace(
                this: *mut root::v8::Module,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Returns the corresponding context-unbound module script.
            ///
            /// The module must be unevaluated, i.e. its status must not be kEvaluating,
            /// kEvaluated or kErrored.
            #[link_name = "\u{1}?GetUnboundModuleScript@Module@v8@@QEAA?AV?$Local@VUnboundModuleScript@v8@@@2@XZ"]
            pub fn Module_GetUnboundModuleScript(
                this: *mut root::v8::Module,
            ) -> root::v8::Local<root::v8::UnboundModuleScript>;
        }
        impl Module {
            #[inline]
            pub unsafe fn GetStatus(&self) -> root::v8::Module_Status {
                Module_GetStatus(self)
            }
            #[inline]
            pub unsafe fn GetException(&self) -> root::v8::Local<root::v8::Value> {
                Module_GetException(self)
            }
            #[inline]
            pub unsafe fn GetModuleRequestsLength(&self) -> ::std::os::raw::c_int {
                Module_GetModuleRequestsLength(self)
            }
            #[inline]
            pub unsafe fn GetModuleRequest(
                &self,
                i: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::String> {
                Module_GetModuleRequest(self, i)
            }
            #[inline]
            pub unsafe fn GetModuleRequestLocation(
                &self,
                i: ::std::os::raw::c_int,
            ) -> root::v8::Location {
                Module_GetModuleRequestLocation(self, i)
            }
            #[inline]
            pub unsafe fn GetIdentityHash(&self) -> ::std::os::raw::c_int {
                Module_GetIdentityHash(self)
            }
            #[inline]
            pub unsafe fn InstantiateModule(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::Module_ResolveCallback,
            ) -> root::v8::Maybe<bool> {
                Module_InstantiateModule(self, context, callback)
            }
            #[inline]
            pub unsafe fn Evaluate(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Module_Evaluate(self, context)
            }
            #[inline]
            pub unsafe fn GetModuleNamespace(&mut self) -> root::v8::Local<root::v8::Value> {
                Module_GetModuleNamespace(self)
            }
            #[inline]
            pub unsafe fn GetUnboundModuleScript(
                &mut self,
            ) -> root::v8::Local<root::v8::UnboundModuleScript> {
                Module_GetUnboundModuleScript(self)
            }
        }
        /// A compiled JavaScript script, tied to a Context which was active when the
        /// script was compiled.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Script {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Script() {
            assert_eq!(
                ::std::mem::size_of::<Script>(),
                1usize,
                concat!("Size of: ", stringify!(Script))
            );
            assert_eq!(
                ::std::mem::align_of::<Script>(),
                1usize,
                concat!("Alignment of ", stringify!(Script))
            );
        }
        extern "C" {
            /// A shorthand for ScriptCompiler::Compile().
            #[link_name = "\u{1}?Compile@Script@v8@@SA?AV?$MaybeLocal@VScript@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VString@v8@@@2@PEAVScriptOrigin@2@@Z"]
            pub fn Script_Compile(
                context: root::v8::Local<root::v8::Context>,
                source: root::v8::Local<root::v8::String>,
                origin: *mut root::v8::ScriptOrigin,
            ) -> root::v8::MaybeLocal<root::v8::Script>;
        }
        extern "C" {
            /// Runs the script returning the resulting value. It will be run in the
            /// context in which it was created (ScriptCompiler::CompileBound or
            /// UnboundScript::BindToCurrentContext()).
            #[link_name = "\u{1}?Run@Script@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Script_Run(
                this: *mut root::v8::Script,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Returns the corresponding context-unbound script.
            #[link_name = "\u{1}?GetUnboundScript@Script@v8@@QEAA?AV?$Local@VUnboundScript@v8@@@2@XZ"]
            pub fn Script_GetUnboundScript(
                this: *mut root::v8::Script,
            ) -> root::v8::Local<root::v8::UnboundScript>;
        }
        impl Script {
            #[inline]
            pub unsafe fn Compile(
                context: root::v8::Local<root::v8::Context>,
                source: root::v8::Local<root::v8::String>,
                origin: *mut root::v8::ScriptOrigin,
            ) -> root::v8::MaybeLocal<root::v8::Script> {
                Script_Compile(context, source, origin)
            }
            #[inline]
            pub unsafe fn Run(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Script_Run(self, context)
            }
            #[inline]
            pub unsafe fn GetUnboundScript(&mut self) -> root::v8::Local<root::v8::UnboundScript> {
                Script_GetUnboundScript(self)
            }
        }
        /// Compilation data that the embedder can cache and pass back to speed up
        /// future compilations. The data is produced if the CompilerOptions passed to
        /// the compilation functions in ScriptCompiler contains produce_data_to_cache
        /// = true. The data to cache can then can be retrieved from
        /// UnboundScript.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ScriptCompiler_CachedData {
            pub data: *const u8,
            pub length: ::std::os::raw::c_int,
            pub rejected: bool,
            pub buffer_policy: root::v8::ScriptCompiler_CachedData_BufferPolicy,
        }
        pub const ScriptCompiler_CachedData_BufferPolicy_BufferNotOwned:
            root::v8::ScriptCompiler_CachedData_BufferPolicy = 0;
        pub const ScriptCompiler_CachedData_BufferPolicy_BufferOwned:
            root::v8::ScriptCompiler_CachedData_BufferPolicy = 1;
        pub type ScriptCompiler_CachedData_BufferPolicy = i32;
        #[test]
        fn bindgen_test_layout_ScriptCompiler_CachedData() {
            assert_eq!(
                ::std::mem::size_of::<ScriptCompiler_CachedData>(),
                24usize,
                concat!("Size of: ", stringify!(ScriptCompiler_CachedData))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptCompiler_CachedData>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptCompiler_CachedData))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_CachedData>())).data as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_CachedData),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_CachedData>())).length as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_CachedData),
                    "::",
                    stringify!(length)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_CachedData>())).rejected as *const _
                        as usize
                },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_CachedData),
                    "::",
                    stringify!(rejected)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_CachedData>())).buffer_policy as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_CachedData),
                    "::",
                    stringify!(buffer_policy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0CachedData@ScriptCompiler@v8@@QEAA@PEBEHW4BufferPolicy@012@@Z"]
            pub fn ScriptCompiler_CachedData_CachedData(
                this: *mut root::v8::ScriptCompiler_CachedData,
                data: *const u8,
                length: ::std::os::raw::c_int,
                buffer_policy: root::v8::ScriptCompiler_CachedData_BufferPolicy,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DCachedData@ScriptCompiler@v8@@QEAAXXZ"]
            pub fn ScriptCompiler_CachedData_CachedData_destructor(
                this: *mut root::v8::ScriptCompiler_CachedData,
            );
        }
        impl ScriptCompiler_CachedData {
            #[inline]
            pub unsafe fn new(
                data: *const u8,
                length: ::std::os::raw::c_int,
                buffer_policy: root::v8::ScriptCompiler_CachedData_BufferPolicy,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ScriptCompiler_CachedData_CachedData(
                    &mut __bindgen_tmp,
                    data,
                    length,
                    buffer_policy,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ScriptCompiler_CachedData_CachedData_destructor(self)
            }
        }
        /// Source code which can be then compiled to a UnboundScript or Script.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ScriptCompiler_Source {
            pub source_string: root::v8::Local<root::v8::String>,
            pub resource_name: root::v8::Local<root::v8::Value>,
            pub resource_line_offset: root::v8::Local<root::v8::Integer>,
            pub resource_column_offset: root::v8::Local<root::v8::Integer>,
            pub resource_options: root::v8::ScriptOriginOptions,
            pub source_map_url: root::v8::Local<root::v8::Value>,
            pub host_defined_options: root::v8::Local<root::v8::PrimitiveArray>,
            pub cached_data: *mut root::v8::ScriptCompiler_CachedData,
        }
        #[test]
        fn bindgen_test_layout_ScriptCompiler_Source() {
            assert_eq!(
                ::std::mem::size_of::<ScriptCompiler_Source>(),
                64usize,
                concat!("Size of: ", stringify!(ScriptCompiler_Source))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptCompiler_Source>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptCompiler_Source))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).source_string as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(source_string)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).resource_name as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(resource_name)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).resource_line_offset
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(resource_line_offset)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).resource_column_offset
                        as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(resource_column_offset)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).resource_options as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(resource_options)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).source_map_url as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(source_map_url)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).host_defined_options
                        as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(host_defined_options)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_Source>())).cached_data as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_Source),
                    "::",
                    stringify!(cached_data)
                )
            );
        }
        #[repr(C)]
        pub struct ScriptCompiler_ExternalSourceStream__bindgen_vtable(::std::os::raw::c_void);
        /// For streaming incomplete script data to V8. The embedder should implement a
        /// subclass of this class.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ScriptCompiler_ExternalSourceStream {
            pub vtable_: *const ScriptCompiler_ExternalSourceStream__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ScriptCompiler_ExternalSourceStream() {
            assert_eq!(
                ::std::mem::size_of::<ScriptCompiler_ExternalSourceStream>(),
                8usize,
                concat!("Size of: ", stringify!(ScriptCompiler_ExternalSourceStream))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptCompiler_ExternalSourceStream>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ScriptCompiler_ExternalSourceStream)
                )
            );
        }
        extern "C" {
            /// V8 calls this method to set a 'bookmark' at the current position in
            /// the source stream, for the purpose of (maybe) later calling
            /// ResetToBookmark. If ResetToBookmark is called later, then subsequent
            /// calls to GetMoreData should return the same data as they did when
            /// SetBookmark was called earlier.
            ///
            /// The embedder may return 'false' to indicate it cannot provide this
            /// functionality.
            #[link_name = "\u{1}?SetBookmark@ExternalSourceStream@ScriptCompiler@v8@@UEAA_NXZ"]
            pub fn ScriptCompiler_ExternalSourceStream_SetBookmark(
                this: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            /// V8 calls this to return to a previously set bookmark.
            #[link_name = "\u{1}?ResetToBookmark@ExternalSourceStream@ScriptCompiler@v8@@UEAAXXZ"]
            pub fn ScriptCompiler_ExternalSourceStream_ResetToBookmark(
                this: *mut ::std::os::raw::c_void,
            );
        }
        /// Source code which can be streamed into V8 in pieces. It will be parsed
        /// while streaming. It can be compiled after the streaming is complete.
        /// StreamedSource must be kept alive while the streaming task is ran (see
        /// ScriptStreamingTask below).
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ScriptCompiler_StreamedSource {
            pub impl_: *mut root::v8::internal::ScriptStreamingData,
        }
        pub const ScriptCompiler_StreamedSource_Encoding_ONE_BYTE:
            root::v8::ScriptCompiler_StreamedSource_Encoding = 0;
        pub const ScriptCompiler_StreamedSource_Encoding_TWO_BYTE:
            root::v8::ScriptCompiler_StreamedSource_Encoding = 1;
        pub const ScriptCompiler_StreamedSource_Encoding_UTF8:
            root::v8::ScriptCompiler_StreamedSource_Encoding = 2;
        pub type ScriptCompiler_StreamedSource_Encoding = i32;
        #[test]
        fn bindgen_test_layout_ScriptCompiler_StreamedSource() {
            assert_eq!(
                ::std::mem::size_of::<ScriptCompiler_StreamedSource>(),
                8usize,
                concat!("Size of: ", stringify!(ScriptCompiler_StreamedSource))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptCompiler_StreamedSource>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptCompiler_StreamedSource))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptCompiler_StreamedSource>())).impl_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptCompiler_StreamedSource),
                    "::",
                    stringify!(impl_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GetCachedData@StreamedSource@ScriptCompiler@v8@@QEBAPEBUCachedData@23@XZ"]
            pub fn ScriptCompiler_StreamedSource_GetCachedData(
                this: *const root::v8::ScriptCompiler_StreamedSource,
            ) -> *const root::v8::ScriptCompiler_CachedData;
        }
        extern "C" {
            #[link_name = "\u{1}??0StreamedSource@ScriptCompiler@v8@@QEAA@PEAVExternalSourceStream@12@W4Encoding@012@@Z"]
            pub fn ScriptCompiler_StreamedSource_StreamedSource(
                this: *mut root::v8::ScriptCompiler_StreamedSource,
                source_stream: *mut root::v8::ScriptCompiler_ExternalSourceStream,
                encoding: root::v8::ScriptCompiler_StreamedSource_Encoding,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DStreamedSource@ScriptCompiler@v8@@QEAAXXZ"]
            pub fn ScriptCompiler_StreamedSource_StreamedSource_destructor(
                this: *mut root::v8::ScriptCompiler_StreamedSource,
            );
        }
        impl ScriptCompiler_StreamedSource {
            #[inline]
            pub unsafe fn GetCachedData(&self) -> *const root::v8::ScriptCompiler_CachedData {
                ScriptCompiler_StreamedSource_GetCachedData(self)
            }
            #[inline]
            pub unsafe fn new(
                source_stream: *mut root::v8::ScriptCompiler_ExternalSourceStream,
                encoding: root::v8::ScriptCompiler_StreamedSource_Encoding,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ScriptCompiler_StreamedSource_StreamedSource(
                    &mut __bindgen_tmp,
                    source_stream,
                    encoding,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ScriptCompiler_StreamedSource_StreamedSource_destructor(self)
            }
        }
        #[repr(C)]
        pub struct ScriptCompiler_ScriptStreamingTask__bindgen_vtable(::std::os::raw::c_void);
        /// A streaming task which the embedder must run on a background thread to
        /// stream scripts into V8. Returned by ScriptCompiler::StartStreamingScript.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ScriptCompiler_ScriptStreamingTask {
            pub vtable_: *const ScriptCompiler_ScriptStreamingTask__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ScriptCompiler_ScriptStreamingTask() {
            assert_eq!(
                ::std::mem::size_of::<ScriptCompiler_ScriptStreamingTask>(),
                8usize,
                concat!("Size of: ", stringify!(ScriptCompiler_ScriptStreamingTask))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptCompiler_ScriptStreamingTask>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ScriptCompiler_ScriptStreamingTask)
                )
            );
        }
        pub const ScriptCompiler_CompileOptions_kNoCompileOptions:
            root::v8::ScriptCompiler_CompileOptions = 0;
        pub const ScriptCompiler_CompileOptions_kProduceParserCache:
            root::v8::ScriptCompiler_CompileOptions = 1;
        pub const ScriptCompiler_CompileOptions_kConsumeParserCache:
            root::v8::ScriptCompiler_CompileOptions = 2;
        pub const ScriptCompiler_CompileOptions_kProduceCodeCache:
            root::v8::ScriptCompiler_CompileOptions = 3;
        pub const ScriptCompiler_CompileOptions_kProduceFullCodeCache:
            root::v8::ScriptCompiler_CompileOptions = 4;
        pub const ScriptCompiler_CompileOptions_kConsumeCodeCache:
            root::v8::ScriptCompiler_CompileOptions = 5;
        pub const ScriptCompiler_CompileOptions_kEagerCompile:
            root::v8::ScriptCompiler_CompileOptions = 6;
        pub type ScriptCompiler_CompileOptions = i32;
        pub const ScriptCompiler_NoCacheReason_kNoCacheNoReason:
            root::v8::ScriptCompiler_NoCacheReason = 0;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseCachingDisabled:
            root::v8::ScriptCompiler_NoCacheReason = 1;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseNoResource:
            root::v8::ScriptCompiler_NoCacheReason = 2;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseInlineScript:
            root::v8::ScriptCompiler_NoCacheReason = 3;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseModule:
            root::v8::ScriptCompiler_NoCacheReason = 4;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseStreamingSource:
            root::v8::ScriptCompiler_NoCacheReason = 5;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseInspector:
            root::v8::ScriptCompiler_NoCacheReason = 6;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseScriptTooSmall:
            root::v8::ScriptCompiler_NoCacheReason = 7;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseCacheTooCold:
            root::v8::ScriptCompiler_NoCacheReason = 8;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseV8Extension:
            root::v8::ScriptCompiler_NoCacheReason = 9;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseExtensionModule:
            root::v8::ScriptCompiler_NoCacheReason = 10;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecausePacScript:
            root::v8::ScriptCompiler_NoCacheReason = 11;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseInDocumentWrite:
            root::v8::ScriptCompiler_NoCacheReason = 12;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseResourceWithNoCacheHandler:
            root::v8::ScriptCompiler_NoCacheReason = 13;
        pub const ScriptCompiler_NoCacheReason_kNoCacheBecauseDeferredProduceCodeCache:
            root::v8::ScriptCompiler_NoCacheReason = 14;
        /// The reason for which we are not requesting or providing a code cache.
        pub type ScriptCompiler_NoCacheReason = i32;
        extern "C" {
            /// Compiles the specified script (context-independent).
            /// Cached data as part of the source object can be optionally produced to be
            /// consumed later to speed up compilation of identical source scripts.
            ///
            /// Note that when producing cached data, the source must point to NULL for
            /// cached data. When consuming cached data, the cached data must have been
            /// produced by the same version of V8.
            ///
            /// \param source Script source code.
            /// \return Compiled script object (context independent; for running it must be
            /// bound to a context).
            #[link_name = "\u{1}?CompileUnboundScript@ScriptCompiler@v8@@SA?AV?$MaybeLocal@VUnboundScript@v8@@@2@PEAVIsolate@2@PEAVSource@12@W4CompileOptions@12@W4NoCacheReason@12@@Z"]
            pub fn ScriptCompiler_CompileUnboundScript(
                isolate: *mut root::v8::Isolate,
                source: *mut root::v8::ScriptCompiler_Source,
                options: root::v8::ScriptCompiler_CompileOptions,
                no_cache_reason: root::v8::ScriptCompiler_NoCacheReason,
            ) -> root::v8::MaybeLocal<root::v8::UnboundScript>;
        }
        extern "C" {
            /// Compiles the specified script (bound to current context).
            ///
            /// \param source Script source code.
            /// \param pre_data Pre-parsing data, as obtained by ScriptData::PreCompile()
            /// using pre_data speeds compilation if it's done multiple times.
            /// Owned by caller, no references are kept when this function returns.
            /// \return Compiled script object, bound to the context that was active
            /// when this function was called. When run it will always use this
            /// context.
            #[link_name = "\u{1}?Compile@ScriptCompiler@v8@@SA?AV?$MaybeLocal@VScript@v8@@@2@V?$Local@VContext@v8@@@2@PEAVSource@12@W4CompileOptions@12@W4NoCacheReason@12@@Z"]
            pub fn ScriptCompiler_Compile(
                context: root::v8::Local<root::v8::Context>,
                source: *mut root::v8::ScriptCompiler_Source,
                options: root::v8::ScriptCompiler_CompileOptions,
                no_cache_reason: root::v8::ScriptCompiler_NoCacheReason,
            ) -> root::v8::MaybeLocal<root::v8::Script>;
        }
        extern "C" {
            /// Returns a task which streams script data into V8, or NULL if the script
            /// cannot be streamed. The user is responsible for running the task on a
            /// background thread and deleting it. When ran, the task starts parsing the
            /// script, and it will request data from the StreamedSource as needed. When
            /// ScriptStreamingTask::Run exits, all data has been streamed and the script
            /// can be compiled (see Compile below).
            ///
            /// This API allows to start the streaming with as little data as possible, and
            /// the remaining data (for example, the ScriptOrigin) is passed to Compile.
            #[link_name = "\u{1}?StartStreamingScript@ScriptCompiler@v8@@SAPEAVScriptStreamingTask@12@PEAVIsolate@2@PEAVStreamedSource@12@W4CompileOptions@12@@Z"]
            pub fn ScriptCompiler_StartStreamingScript(
                isolate: *mut root::v8::Isolate,
                source: *mut root::v8::ScriptCompiler_StreamedSource,
                options: root::v8::ScriptCompiler_CompileOptions,
            ) -> *mut root::v8::ScriptCompiler_ScriptStreamingTask;
        }
        extern "C" {
            /// Compiles a streamed script (bound to current context).
            ///
            /// This can only be called after the streaming has finished
            /// (ScriptStreamingTask has been run). V8 doesn't construct the source string
            /// during streaming, so the embedder needs to pass the full source here.
            #[link_name = "\u{1}?Compile@ScriptCompiler@v8@@SA?AV?$MaybeLocal@VScript@v8@@@2@V?$Local@VContext@v8@@@2@PEAVStreamedSource@12@V?$Local@VString@v8@@@2@AEBVScriptOrigin@2@@Z"]
            pub fn ScriptCompiler_Compile1(
                context: root::v8::Local<root::v8::Context>,
                source: *mut root::v8::ScriptCompiler_StreamedSource,
                full_source_string: root::v8::Local<root::v8::String>,
                origin: *const root::v8::ScriptOrigin,
            ) -> root::v8::MaybeLocal<root::v8::Script>;
        }
        extern "C" {
            /// Return a version tag for CachedData for the current V8 version & flags.
            ///
            /// This value is meant only for determining whether a previously generated
            /// CachedData instance is still valid; the tag has no other meaing.
            ///
            /// Background: The data carried by CachedData may depend on the exact
            /// V8 version number or current compiler flags. This means that when
            /// persisting CachedData, the embedder must take care to not pass in
            /// data from another V8 version, or the same version with different
            /// features enabled.
            ///
            /// The easiest way to do so is to clear the embedder's cache on any
            /// such change.
            ///
            /// Alternatively, this tag can be stored alongside the cached data and
            /// compared when it is being used.
            #[link_name = "\u{1}?CachedDataVersionTag@ScriptCompiler@v8@@SAIXZ"]
            pub fn ScriptCompiler_CachedDataVersionTag() -> u32;
        }
        extern "C" {
            /// Compile an ES module, returning a Module that encapsulates
            /// the compiled code.
            ///
            /// Corresponds to the ParseModule abstract operation in the
            /// ECMAScript specification.
            #[link_name = "\u{1}?CompileModule@ScriptCompiler@v8@@SA?AV?$MaybeLocal@VModule@v8@@@2@PEAVIsolate@2@PEAVSource@12@W4CompileOptions@12@W4NoCacheReason@12@@Z"]
            pub fn ScriptCompiler_CompileModule(
                isolate: *mut root::v8::Isolate,
                source: *mut root::v8::ScriptCompiler_Source,
                options: root::v8::ScriptCompiler_CompileOptions,
                no_cache_reason: root::v8::ScriptCompiler_NoCacheReason,
            ) -> root::v8::MaybeLocal<root::v8::Module>;
        }
        extern "C" {
            /// Compile a function for a given context. This is equivalent to running
            ///
            /// with (obj) {
            /// return function(args) { ... }
            /// }
            ///
            /// It is possible to specify multiple context extensions (obj in the above
            /// example).
            #[link_name = "\u{1}?CompileFunctionInContext@ScriptCompiler@v8@@SA?AV?$MaybeLocal@VFunction@v8@@@2@V?$Local@VContext@v8@@@2@PEAVSource@12@_KQEAV?$Local@VString@v8@@@2@2QEAV?$Local@VObject@v8@@@2@W4CompileOptions@12@W4NoCacheReason@12@@Z"]
            pub fn ScriptCompiler_CompileFunctionInContext(
                context: root::v8::Local<root::v8::Context>,
                source: *mut root::v8::ScriptCompiler_Source,
                arguments_count: usize,
                arguments: *mut root::v8::Local<root::v8::String>,
                context_extension_count: usize,
                context_extensions: *mut root::v8::Local<root::v8::Object>,
                options: root::v8::ScriptCompiler_CompileOptions,
                no_cache_reason: root::v8::ScriptCompiler_NoCacheReason,
            ) -> root::v8::MaybeLocal<root::v8::Function>;
        }
        extern "C" {
            /// Creates and returns code cache for the specified unbound_script.
            /// This will return nullptr if the script cannot be serialized. The
            /// CachedData returned by this function should be owned by the caller.
            #[link_name = "\u{1}?CreateCodeCache@ScriptCompiler@v8@@SAPEAUCachedData@12@V?$Local@VUnboundScript@v8@@@2@@Z"]
            pub fn ScriptCompiler_CreateCodeCache(
                unbound_script: root::v8::Local<root::v8::UnboundScript>,
            ) -> *mut root::v8::ScriptCompiler_CachedData;
        }
        extern "C" {
            /// Creates and returns code cache for the specified unbound_module_script.
            /// This will return nullptr if the script cannot be serialized. The
            /// CachedData returned by this function should be owned by the caller.
            #[link_name = "\u{1}?CreateCodeCache@ScriptCompiler@v8@@SAPEAUCachedData@12@V?$Local@VUnboundModuleScript@v8@@@2@@Z"]
            pub fn ScriptCompiler_CreateCodeCache1(
                unbound_module_script: root::v8::Local<root::v8::UnboundModuleScript>,
            ) -> *mut root::v8::ScriptCompiler_CachedData;
        }
        extern "C" {
            /// Creates and returns code cache for the specified function that was
            /// previously produced by CompileFunctionInContext.
            /// This will return nullptr if the script cannot be serialized. The
            /// CachedData returned by this function should be owned by the caller.
            #[link_name = "\u{1}?CreateCodeCacheForFunction@ScriptCompiler@v8@@SAPEAUCachedData@12@V?$Local@VFunction@v8@@@2@@Z"]
            pub fn ScriptCompiler_CreateCodeCacheForFunction(
                function: root::v8::Local<root::v8::Function>,
            ) -> *mut root::v8::ScriptCompiler_CachedData;
        }
        /// An error message.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Message {
            pub _address: u8,
        }
        pub const Message_kNoLineNumberInfo: ::std::os::raw::c_int = 0;
        pub const Message_kNoColumnInfo: ::std::os::raw::c_int = 0;
        pub const Message_kNoScriptIdInfo: ::std::os::raw::c_int = 0;
        #[test]
        fn bindgen_test_layout_Message() {
            assert_eq!(
                ::std::mem::size_of::<Message>(),
                1usize,
                concat!("Size of: ", stringify!(Message))
            );
            assert_eq!(
                ::std::mem::align_of::<Message>(),
                1usize,
                concat!("Alignment of ", stringify!(Message))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Get@Message@v8@@QEBA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn Message_Get(this: *const root::v8::Message)
                -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Return the isolate to which the Message belongs.
            #[link_name = "\u{1}?GetIsolate@Message@v8@@QEBAPEAVIsolate@2@XZ"]
            pub fn Message_GetIsolate(this: *const root::v8::Message) -> *mut root::v8::Isolate;
        }
        extern "C" {
            #[link_name = "\u{1}?GetSourceLine@Message@v8@@QEBA?AV?$MaybeLocal@VString@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Message_GetSourceLine(
                this: *const root::v8::Message,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            /// Returns the origin for the script from where the function causing the
            /// error originates.
            #[link_name = "\u{1}?GetScriptOrigin@Message@v8@@QEBA?AVScriptOrigin@2@XZ"]
            pub fn Message_GetScriptOrigin(
                this: *const root::v8::Message,
            ) -> root::v8::ScriptOrigin;
        }
        extern "C" {
            /// Returns the resource name for the script from where the function causing
            /// the error originates.
            #[link_name = "\u{1}?GetScriptResourceName@Message@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Message_GetScriptResourceName(
                this: *const root::v8::Message,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Exception stack trace. By default stack traces are not captured for
            /// uncaught exceptions. SetCaptureStackTraceForUncaughtExceptions allows
            /// to change this option.
            #[link_name = "\u{1}?GetStackTrace@Message@v8@@QEBA?AV?$Local@VStackTrace@v8@@@2@XZ"]
            pub fn Message_GetStackTrace(
                this: *const root::v8::Message,
            ) -> root::v8::Local<root::v8::StackTrace>;
        }
        extern "C" {
            /// Returns the number, 1-based, of the line where the error occurred.
            #[link_name = "\u{1}?GetLineNumber@Message@v8@@QEBA?AV?$Maybe@H@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Message_GetLineNumber(
                this: *const root::v8::Message,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<::std::os::raw::c_int>;
        }
        extern "C" {
            /// Returns the index within the script of the first character where
            /// the error occurred.
            #[link_name = "\u{1}?GetStartPosition@Message@v8@@QEBAHXZ"]
            pub fn Message_GetStartPosition(
                this: *const root::v8::Message,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the index within the script of the last character where
            /// the error occurred.
            #[link_name = "\u{1}?GetEndPosition@Message@v8@@QEBAHXZ"]
            pub fn Message_GetEndPosition(this: *const root::v8::Message) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the error level of the message.
            #[link_name = "\u{1}?ErrorLevel@Message@v8@@QEBAHXZ"]
            pub fn Message_ErrorLevel(this: *const root::v8::Message) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the index within the line of the first character where
            /// the error occurred.
            #[link_name = "\u{1}?GetStartColumn@Message@v8@@QEBAHXZ"]
            pub fn Message_GetStartColumn(this: *const root::v8::Message) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?GetStartColumn@Message@v8@@QEBA?AV?$Maybe@H@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Message_GetStartColumn1(
                this: *const root::v8::Message,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<::std::os::raw::c_int>;
        }
        extern "C" {
            /// Returns the index within the line of the last character where
            /// the error occurred.
            #[link_name = "\u{1}?GetEndColumn@Message@v8@@QEBAHXZ"]
            pub fn Message_GetEndColumn(this: *const root::v8::Message) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?GetEndColumn@Message@v8@@QEBA?AV?$Maybe@H@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Message_GetEndColumn1(
                this: *const root::v8::Message,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<::std::os::raw::c_int>;
        }
        extern "C" {
            /// Passes on the value set by the embedder when it fed the script from which
            /// this Message was generated to V8.
            #[link_name = "\u{1}?IsSharedCrossOrigin@Message@v8@@QEBA_NXZ"]
            pub fn Message_IsSharedCrossOrigin(this: *const root::v8::Message) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?IsOpaque@Message@v8@@QEBA_NXZ"]
            pub fn Message_IsOpaque(this: *const root::v8::Message) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?PrintCurrentStackTrace@Message@v8@@SAXPEAVIsolate@2@PEAU_iobuf@@@Z"]
            pub fn Message_PrintCurrentStackTrace(
                isolate: *mut root::v8::Isolate,
                out: *mut root::FILE,
            );
        }
        impl Message {
            #[inline]
            pub unsafe fn Get(&self) -> root::v8::Local<root::v8::String> {
                Message_Get(self)
            }
            #[inline]
            pub unsafe fn GetIsolate(&self) -> *mut root::v8::Isolate {
                Message_GetIsolate(self)
            }
            #[inline]
            pub unsafe fn GetSourceLine(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                Message_GetSourceLine(self, context)
            }
            #[inline]
            pub unsafe fn GetScriptOrigin(&self) -> root::v8::ScriptOrigin {
                Message_GetScriptOrigin(self)
            }
            #[inline]
            pub unsafe fn GetScriptResourceName(&self) -> root::v8::Local<root::v8::Value> {
                Message_GetScriptResourceName(self)
            }
            #[inline]
            pub unsafe fn GetStackTrace(&self) -> root::v8::Local<root::v8::StackTrace> {
                Message_GetStackTrace(self)
            }
            #[inline]
            pub unsafe fn GetLineNumber(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<::std::os::raw::c_int> {
                Message_GetLineNumber(self, context)
            }
            #[inline]
            pub unsafe fn GetStartPosition(&self) -> ::std::os::raw::c_int {
                Message_GetStartPosition(self)
            }
            #[inline]
            pub unsafe fn GetEndPosition(&self) -> ::std::os::raw::c_int {
                Message_GetEndPosition(self)
            }
            #[inline]
            pub unsafe fn ErrorLevel(&self) -> ::std::os::raw::c_int {
                Message_ErrorLevel(self)
            }
            #[inline]
            pub unsafe fn GetStartColumn(&self) -> ::std::os::raw::c_int {
                Message_GetStartColumn(self)
            }
            #[inline]
            pub unsafe fn GetStartColumn1(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<::std::os::raw::c_int> {
                Message_GetStartColumn1(self, context)
            }
            #[inline]
            pub unsafe fn GetEndColumn(&self) -> ::std::os::raw::c_int {
                Message_GetEndColumn(self)
            }
            #[inline]
            pub unsafe fn GetEndColumn1(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<::std::os::raw::c_int> {
                Message_GetEndColumn1(self, context)
            }
            #[inline]
            pub unsafe fn IsSharedCrossOrigin(&self) -> bool {
                Message_IsSharedCrossOrigin(self)
            }
            #[inline]
            pub unsafe fn IsOpaque(&self) -> bool {
                Message_IsOpaque(self)
            }
            #[inline]
            pub unsafe fn PrintCurrentStackTrace(
                isolate: *mut root::v8::Isolate,
                out: *mut root::FILE,
            ) {
                Message_PrintCurrentStackTrace(isolate, out)
            }
        }
        /// Representation of a JavaScript stack trace. The information collected is a
        /// snapshot of the execution stack and the information remains valid after
        /// execution continues.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct StackTrace {
            pub _address: u8,
        }
        pub const StackTrace_StackTraceOptions_kLineNumber: root::v8::StackTrace_StackTraceOptions =
            1;
        pub const StackTrace_StackTraceOptions_kColumnOffset:
            root::v8::StackTrace_StackTraceOptions = 3;
        pub const StackTrace_StackTraceOptions_kScriptName: root::v8::StackTrace_StackTraceOptions =
            4;
        pub const StackTrace_StackTraceOptions_kFunctionName:
            root::v8::StackTrace_StackTraceOptions = 8;
        pub const StackTrace_StackTraceOptions_kIsEval: root::v8::StackTrace_StackTraceOptions = 16;
        pub const StackTrace_StackTraceOptions_kIsConstructor:
            root::v8::StackTrace_StackTraceOptions = 32;
        pub const StackTrace_StackTraceOptions_kScriptNameOrSourceURL:
            root::v8::StackTrace_StackTraceOptions = 64;
        pub const StackTrace_StackTraceOptions_kScriptId: root::v8::StackTrace_StackTraceOptions =
            128;
        pub const StackTrace_StackTraceOptions_kExposeFramesAcrossSecurityOrigins:
            root::v8::StackTrace_StackTraceOptions = 256;
        pub const StackTrace_StackTraceOptions_kOverview: root::v8::StackTrace_StackTraceOptions =
            15;
        pub const StackTrace_StackTraceOptions_kDetailed: root::v8::StackTrace_StackTraceOptions =
            127;
        /// Flags that determine what information is placed captured for each
        /// StackFrame when grabbing the current stack trace.
        /// Note: these options are deprecated and we always collect all available
        /// information (kDetailed).
        pub type StackTrace_StackTraceOptions = i32;
        #[test]
        fn bindgen_test_layout_StackTrace() {
            assert_eq!(
                ::std::mem::size_of::<StackTrace>(),
                1usize,
                concat!("Size of: ", stringify!(StackTrace))
            );
            assert_eq!(
                ::std::mem::align_of::<StackTrace>(),
                1usize,
                concat!("Alignment of ", stringify!(StackTrace))
            );
        }
        extern "C" {
            /// Returns a StackFrame at a particular index.
            #[link_name = "\u{1}?GetFrame@StackTrace@v8@@QEBA?AV?$Local@VStackFrame@v8@@@2@PEAVIsolate@2@I@Z"]
            pub fn StackTrace_GetFrame(
                this: *const root::v8::StackTrace,
                isolate: *mut root::v8::Isolate,
                index: u32,
            ) -> root::v8::Local<root::v8::StackFrame>;
        }
        extern "C" {
            /// Returns the number of StackFrames.
            #[link_name = "\u{1}?GetFrameCount@StackTrace@v8@@QEBAHXZ"]
            pub fn StackTrace_GetFrameCount(
                this: *const root::v8::StackTrace,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Grab a snapshot of the current JavaScript execution stack.
            ///
            /// \param frame_limit The maximum number of stack frames we want to capture.
            /// \param options Enumerates the set of things we will capture for each
            /// StackFrame.
            #[link_name = "\u{1}?CurrentStackTrace@StackTrace@v8@@SA?AV?$Local@VStackTrace@v8@@@2@PEAVIsolate@2@HW4StackTraceOptions@12@@Z"]
            pub fn StackTrace_CurrentStackTrace(
                isolate: *mut root::v8::Isolate,
                frame_limit: ::std::os::raw::c_int,
                options: root::v8::StackTrace_StackTraceOptions,
            ) -> root::v8::Local<root::v8::StackTrace>;
        }
        impl StackTrace {
            #[inline]
            pub unsafe fn GetFrame(
                &self,
                isolate: *mut root::v8::Isolate,
                index: u32,
            ) -> root::v8::Local<root::v8::StackFrame> {
                StackTrace_GetFrame(self, isolate, index)
            }
            #[inline]
            pub unsafe fn GetFrameCount(&self) -> ::std::os::raw::c_int {
                StackTrace_GetFrameCount(self)
            }
            #[inline]
            pub unsafe fn CurrentStackTrace(
                isolate: *mut root::v8::Isolate,
                frame_limit: ::std::os::raw::c_int,
                options: root::v8::StackTrace_StackTraceOptions,
            ) -> root::v8::Local<root::v8::StackTrace> {
                StackTrace_CurrentStackTrace(isolate, frame_limit, options)
            }
        }
        /// A single JavaScript stack frame.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct StackFrame {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_StackFrame() {
            assert_eq!(
                ::std::mem::size_of::<StackFrame>(),
                1usize,
                concat!("Size of: ", stringify!(StackFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<StackFrame>(),
                1usize,
                concat!("Alignment of ", stringify!(StackFrame))
            );
        }
        extern "C" {
            /// Returns the number, 1-based, of the line for the associate function call.
            /// This method will return Message::kNoLineNumberInfo if it is unable to
            /// retrieve the line number, or if kLineNumber was not passed as an option
            /// when capturing the StackTrace.
            #[link_name = "\u{1}?GetLineNumber@StackFrame@v8@@QEBAHXZ"]
            pub fn StackFrame_GetLineNumber(
                this: *const root::v8::StackFrame,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the 1-based column offset on the line for the associated function
            /// call.
            /// This method will return Message::kNoColumnInfo if it is unable to retrieve
            /// the column number, or if kColumnOffset was not passed as an option when
            /// capturing the StackTrace.
            #[link_name = "\u{1}?GetColumn@StackFrame@v8@@QEBAHXZ"]
            pub fn StackFrame_GetColumn(this: *const root::v8::StackFrame)
                -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the id of the script for the function for this StackFrame.
            /// This method will return Message::kNoScriptIdInfo if it is unable to
            /// retrieve the script id, or if kScriptId was not passed as an option when
            /// capturing the StackTrace.
            #[link_name = "\u{1}?GetScriptId@StackFrame@v8@@QEBAHXZ"]
            pub fn StackFrame_GetScriptId(
                this: *const root::v8::StackFrame,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the name of the resource that contains the script for the
            /// function for this StackFrame.
            #[link_name = "\u{1}?GetScriptName@StackFrame@v8@@QEBA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn StackFrame_GetScriptName(
                this: *const root::v8::StackFrame,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Returns the name of the resource that contains the script for the
            /// function for this StackFrame or sourceURL value if the script name
            /// is undefined and its source ends with //# sourceURL=... string or
            /// deprecated //@ sourceURL=... string.
            #[link_name = "\u{1}?GetScriptNameOrSourceURL@StackFrame@v8@@QEBA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn StackFrame_GetScriptNameOrSourceURL(
                this: *const root::v8::StackFrame,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Returns the name of the function associated with this stack frame.
            #[link_name = "\u{1}?GetFunctionName@StackFrame@v8@@QEBA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn StackFrame_GetFunctionName(
                this: *const root::v8::StackFrame,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Returns whether or not the associated function is compiled via a call to
            /// eval().
            #[link_name = "\u{1}?IsEval@StackFrame@v8@@QEBA_NXZ"]
            pub fn StackFrame_IsEval(this: *const root::v8::StackFrame) -> bool;
        }
        extern "C" {
            /// Returns whether or not the associated function is called as a
            /// constructor via "new".
            #[link_name = "\u{1}?IsConstructor@StackFrame@v8@@QEBA_NXZ"]
            pub fn StackFrame_IsConstructor(this: *const root::v8::StackFrame) -> bool;
        }
        extern "C" {
            /// Returns whether or not the associated functions is defined in wasm.
            #[link_name = "\u{1}?IsWasm@StackFrame@v8@@QEBA_NXZ"]
            pub fn StackFrame_IsWasm(this: *const root::v8::StackFrame) -> bool;
        }
        impl StackFrame {
            #[inline]
            pub unsafe fn GetLineNumber(&self) -> ::std::os::raw::c_int {
                StackFrame_GetLineNumber(self)
            }
            #[inline]
            pub unsafe fn GetColumn(&self) -> ::std::os::raw::c_int {
                StackFrame_GetColumn(self)
            }
            #[inline]
            pub unsafe fn GetScriptId(&self) -> ::std::os::raw::c_int {
                StackFrame_GetScriptId(self)
            }
            #[inline]
            pub unsafe fn GetScriptName(&self) -> root::v8::Local<root::v8::String> {
                StackFrame_GetScriptName(self)
            }
            #[inline]
            pub unsafe fn GetScriptNameOrSourceURL(&self) -> root::v8::Local<root::v8::String> {
                StackFrame_GetScriptNameOrSourceURL(self)
            }
            #[inline]
            pub unsafe fn GetFunctionName(&self) -> root::v8::Local<root::v8::String> {
                StackFrame_GetFunctionName(self)
            }
            #[inline]
            pub unsafe fn IsEval(&self) -> bool {
                StackFrame_IsEval(self)
            }
            #[inline]
            pub unsafe fn IsConstructor(&self) -> bool {
                StackFrame_IsConstructor(self)
            }
            #[inline]
            pub unsafe fn IsWasm(&self) -> bool {
                StackFrame_IsWasm(self)
            }
        }
        pub const StateTag_JS: root::v8::StateTag = 0;
        pub const StateTag_GC: root::v8::StateTag = 1;
        pub const StateTag_PARSER: root::v8::StateTag = 2;
        pub const StateTag_BYTECODE_COMPILER: root::v8::StateTag = 3;
        pub const StateTag_COMPILER: root::v8::StateTag = 4;
        pub const StateTag_OTHER: root::v8::StateTag = 5;
        pub const StateTag_EXTERNAL: root::v8::StateTag = 6;
        pub const StateTag_IDLE: root::v8::StateTag = 7;
        pub type StateTag = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct RegisterState {
            pub pc: *mut ::std::os::raw::c_void,
            pub sp: *mut ::std::os::raw::c_void,
            pub fp: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_RegisterState() {
            assert_eq!(
                ::std::mem::size_of::<RegisterState>(),
                24usize,
                concat!("Size of: ", stringify!(RegisterState))
            );
            assert_eq!(
                ::std::mem::align_of::<RegisterState>(),
                8usize,
                concat!("Alignment of ", stringify!(RegisterState))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RegisterState>())).pc as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RegisterState),
                    "::",
                    stringify!(pc)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RegisterState>())).sp as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RegisterState),
                    "::",
                    stringify!(sp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RegisterState>())).fp as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RegisterState),
                    "::",
                    stringify!(fp)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct SampleInfo {
            pub frames_count: usize,
            pub vm_state: root::v8::StateTag,
            pub external_callback_entry: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_SampleInfo() {
            assert_eq!(
                ::std::mem::size_of::<SampleInfo>(),
                24usize,
                concat!("Size of: ", stringify!(SampleInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<SampleInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(SampleInfo))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SampleInfo>())).frames_count as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SampleInfo),
                    "::",
                    stringify!(frames_count)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SampleInfo>())).vm_state as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SampleInfo),
                    "::",
                    stringify!(vm_state)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SampleInfo>())).external_callback_entry as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SampleInfo),
                    "::",
                    stringify!(external_callback_entry)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct MemoryRange {
            pub start: *const ::std::os::raw::c_void,
            pub length_in_bytes: usize,
        }
        #[test]
        fn bindgen_test_layout_MemoryRange() {
            assert_eq!(
                ::std::mem::size_of::<MemoryRange>(),
                16usize,
                concat!("Size of: ", stringify!(MemoryRange))
            );
            assert_eq!(
                ::std::mem::align_of::<MemoryRange>(),
                8usize,
                concat!("Alignment of ", stringify!(MemoryRange))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MemoryRange>())).start as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MemoryRange),
                    "::",
                    stringify!(start)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<MemoryRange>())).length_in_bytes as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MemoryRange),
                    "::",
                    stringify!(length_in_bytes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Parse@JSON@v8@@SA?AV?$MaybeLocal@VValue@v8@@@2@PEAVIsolate@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn JSON_Parse(
                isolate: *mut root::v8::Isolate,
                json_string: root::v8::Local<root::v8::String>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Parse@JSON@v8@@SA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn JSON_Parse1(
                context: root::v8::Local<root::v8::Context>,
                json_string: root::v8::Local<root::v8::String>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Tries to stringify the JSON-serializable object |json_object| and returns
            /// it as string if successful.
            ///
            /// \param json_object The JSON-serializable object to stringify.
            /// \return The corresponding string if successfully stringified.
            #[link_name = "\u{1}?Stringify@JSON@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn JSON_Stringify(
                context: root::v8::Local<root::v8::Context>,
                json_object: root::v8::Local<root::v8::Value>,
                gap: root::v8::Local<root::v8::String>,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        /// Value serialization compatible with the HTML structured clone algorithm.
        /// The format is backward-compatible (i.e. safe to store to disk).
        ///
        /// WARNING: This API is under development, and changes (including incompatible
        /// changes to the API or wire format) may occur without notice until this
        /// warning is removed.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ValueSerializer {
            pub private_: *mut root::v8::ValueSerializer_PrivateData,
        }
        #[repr(C)]
        pub struct ValueSerializer_Delegate__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ValueSerializer_Delegate {
            pub vtable_: *const ValueSerializer_Delegate__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ValueSerializer_Delegate() {
            assert_eq!(
                ::std::mem::size_of::<ValueSerializer_Delegate>(),
                8usize,
                concat!("Size of: ", stringify!(ValueSerializer_Delegate))
            );
            assert_eq!(
                ::std::mem::align_of::<ValueSerializer_Delegate>(),
                8usize,
                concat!("Alignment of ", stringify!(ValueSerializer_Delegate))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ValueSerializer_PrivateData {
            _unused: [u8; 0],
        }
        #[test]
        fn bindgen_test_layout_ValueSerializer() {
            assert_eq!(
                ::std::mem::size_of::<ValueSerializer>(),
                8usize,
                concat!("Size of: ", stringify!(ValueSerializer))
            );
            assert_eq!(
                ::std::mem::align_of::<ValueSerializer>(),
                8usize,
                concat!("Alignment of ", stringify!(ValueSerializer))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ValueSerializer>())).private_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ValueSerializer),
                    "::",
                    stringify!(private_)
                )
            );
        }
        extern "C" {
            /// Writes out a header, which includes the format version.
            #[link_name = "\u{1}?WriteHeader@ValueSerializer@v8@@QEAAXXZ"]
            pub fn ValueSerializer_WriteHeader(this: *mut root::v8::ValueSerializer);
        }
        extern "C" {
            /// Serializes a JavaScript value into the buffer.
            #[link_name = "\u{1}?WriteValue@ValueSerializer@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn ValueSerializer_WriteValue(
                this: *mut root::v8::ValueSerializer,
                context: root::v8::Local<root::v8::Context>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?ReleaseBuffer@ValueSerializer@v8@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ"]
            pub fn ValueSerializer_ReleaseBuffer(this: *mut root::v8::ValueSerializer) -> u8;
        }
        extern "C" {
            /// Returns the stored data (allocated using the delegate's
            /// ReallocateBufferMemory) and its size. This serializer should not be used
            /// once the buffer is released. The contents are undefined if a previous write
            /// has failed. Ownership of the buffer is transferred to the caller.
            #[link_name = "\u{1}?Release@ValueSerializer@v8@@QEAA?AU?$pair@PEAE_K@std@@XZ"]
            pub fn ValueSerializer_Release(this: *mut root::v8::ValueSerializer) -> u8;
        }
        extern "C" {
            /// Marks an ArrayBuffer as havings its contents transferred out of band.
            /// Pass the corresponding ArrayBuffer in the deserializing context to
            /// ValueDeserializer::TransferArrayBuffer.
            #[link_name = "\u{1}?TransferArrayBuffer@ValueSerializer@v8@@QEAAXIV?$Local@VArrayBuffer@v8@@@2@@Z"]
            pub fn ValueSerializer_TransferArrayBuffer(
                this: *mut root::v8::ValueSerializer,
                transfer_id: u32,
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?TransferSharedArrayBuffer@ValueSerializer@v8@@QEAAXIV?$Local@VSharedArrayBuffer@v8@@@2@@Z"]
            pub fn ValueSerializer_TransferSharedArrayBuffer(
                this: *mut root::v8::ValueSerializer,
                transfer_id: u32,
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
            );
        }
        extern "C" {
            /// Indicate whether to treat ArrayBufferView objects as host objects,
            /// i.e. pass them to Delegate::WriteHostObject. This should not be
            /// called when no Delegate was passed.
            ///
            /// The default is not to treat ArrayBufferViews as host objects.
            #[link_name = "\u{1}?SetTreatArrayBufferViewsAsHostObjects@ValueSerializer@v8@@QEAAX_N@Z"]
            pub fn ValueSerializer_SetTreatArrayBufferViewsAsHostObjects(
                this: *mut root::v8::ValueSerializer,
                mode: bool,
            );
        }
        extern "C" {
            /// Write raw data in various common formats to the buffer.
            /// Note that integer types are written in base-128 varint format, not with a
            /// binary copy. For use during an override of Delegate::WriteHostObject.
            #[link_name = "\u{1}?WriteUint32@ValueSerializer@v8@@QEAAXI@Z"]
            pub fn ValueSerializer_WriteUint32(this: *mut root::v8::ValueSerializer, value: u32);
        }
        extern "C" {
            #[link_name = "\u{1}?WriteUint64@ValueSerializer@v8@@QEAAX_K@Z"]
            pub fn ValueSerializer_WriteUint64(this: *mut root::v8::ValueSerializer, value: u64);
        }
        extern "C" {
            #[link_name = "\u{1}?WriteDouble@ValueSerializer@v8@@QEAAXN@Z"]
            pub fn ValueSerializer_WriteDouble(this: *mut root::v8::ValueSerializer, value: f64);
        }
        extern "C" {
            #[link_name = "\u{1}?WriteRawBytes@ValueSerializer@v8@@QEAAXPEBX_K@Z"]
            pub fn ValueSerializer_WriteRawBytes(
                this: *mut root::v8::ValueSerializer,
                source: *const ::std::os::raw::c_void,
                length: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0ValueSerializer@v8@@QEAA@PEAVIsolate@1@@Z"]
            pub fn ValueSerializer_ValueSerializer(
                this: *mut root::v8::ValueSerializer,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0ValueSerializer@v8@@QEAA@PEAVIsolate@1@PEAVDelegate@01@@Z"]
            pub fn ValueSerializer_ValueSerializer1(
                this: *mut root::v8::ValueSerializer,
                isolate: *mut root::v8::Isolate,
                delegate: *mut root::v8::ValueSerializer_Delegate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DValueSerializer@v8@@QEAAXXZ"]
            pub fn ValueSerializer_ValueSerializer_destructor(this: *mut root::v8::ValueSerializer);
        }
        impl ValueSerializer {
            #[inline]
            pub unsafe fn WriteHeader(&mut self) {
                ValueSerializer_WriteHeader(self)
            }
            #[inline]
            pub unsafe fn WriteValue(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                ValueSerializer_WriteValue(self, context, value)
            }
            #[inline]
            pub unsafe fn ReleaseBuffer(&mut self) -> u8 {
                ValueSerializer_ReleaseBuffer(self)
            }
            #[inline]
            pub unsafe fn Release(&mut self) -> u8 {
                ValueSerializer_Release(self)
            }
            #[inline]
            pub unsafe fn TransferArrayBuffer(
                &mut self,
                transfer_id: u32,
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
            ) {
                ValueSerializer_TransferArrayBuffer(self, transfer_id, array_buffer)
            }
            #[inline]
            pub unsafe fn TransferSharedArrayBuffer(
                &mut self,
                transfer_id: u32,
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
            ) {
                ValueSerializer_TransferSharedArrayBuffer(self, transfer_id, shared_array_buffer)
            }
            #[inline]
            pub unsafe fn SetTreatArrayBufferViewsAsHostObjects(&mut self, mode: bool) {
                ValueSerializer_SetTreatArrayBufferViewsAsHostObjects(self, mode)
            }
            #[inline]
            pub unsafe fn WriteUint32(&mut self, value: u32) {
                ValueSerializer_WriteUint32(self, value)
            }
            #[inline]
            pub unsafe fn WriteUint64(&mut self, value: u64) {
                ValueSerializer_WriteUint64(self, value)
            }
            #[inline]
            pub unsafe fn WriteDouble(&mut self, value: f64) {
                ValueSerializer_WriteDouble(self, value)
            }
            #[inline]
            pub unsafe fn WriteRawBytes(
                &mut self,
                source: *const ::std::os::raw::c_void,
                length: usize,
            ) {
                ValueSerializer_WriteRawBytes(self, source, length)
            }
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ValueSerializer_ValueSerializer(&mut __bindgen_tmp, isolate);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                isolate: *mut root::v8::Isolate,
                delegate: *mut root::v8::ValueSerializer_Delegate,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ValueSerializer_ValueSerializer1(&mut __bindgen_tmp, isolate, delegate);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ValueSerializer_ValueSerializer_destructor(self)
            }
        }
        extern "C" {
            /// The embedder overrides this method to write some kind of host object, if
            /// possible. If not, a suitable exception should be thrown and
            /// Nothing<bool>() returned.
            #[link_name = "\u{1}?WriteHostObject@Delegate@ValueSerializer@v8@@UEAA?AV?$Maybe@_N@3@PEAVIsolate@3@V?$Local@VObject@v8@@@3@@Z"]
            pub fn ValueSerializer_Delegate_WriteHostObject(
                this: *mut ::std::os::raw::c_void,
                isolate: *mut root::v8::Isolate,
                object: root::v8::Local<root::v8::Object>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Called when the ValueSerializer is going to serialize a
            /// SharedArrayBuffer object. The embedder must return an ID for the
            /// object, using the same ID if this SharedArrayBuffer has already been
            /// serialized in this buffer. When deserializing, this ID will be passed to
            /// ValueDeserializer::GetSharedArrayBufferFromId as |clone_id|.
            ///
            /// If the object cannot be serialized, an
            /// exception should be thrown and Nothing<uint32_t>() returned.
            #[link_name = "\u{1}?GetSharedArrayBufferId@Delegate@ValueSerializer@v8@@UEAA?AV?$Maybe@I@3@PEAVIsolate@3@V?$Local@VSharedArrayBuffer@v8@@@3@@Z"]
            pub fn ValueSerializer_Delegate_GetSharedArrayBufferId(
                this: *mut ::std::os::raw::c_void,
                isolate: *mut root::v8::Isolate,
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
            ) -> root::v8::Maybe<u32>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetWasmModuleTransferId@Delegate@ValueSerializer@v8@@UEAA?AV?$Maybe@I@3@PEAVIsolate@3@V?$Local@VWasmCompiledModule@v8@@@3@@Z"]
            pub fn ValueSerializer_Delegate_GetWasmModuleTransferId(
                this: *mut ::std::os::raw::c_void,
                isolate: *mut root::v8::Isolate,
                module: root::v8::Local<root::v8::WasmCompiledModule>,
            ) -> root::v8::Maybe<u32>;
        }
        extern "C" {
            /// Allocates memory for the buffer of at least the size provided. The actual
            /// size (which may be greater or equal) is written to |actual_size|. If no
            /// buffer has been allocated yet, nullptr will be provided.
            ///
            /// If the memory cannot be allocated, nullptr should be returned.
            /// |actual_size| will be ignored. It is assumed that |old_buffer| is still
            /// valid in this case and has not been modified.
            ///
            /// The default implementation uses the stdlib's `realloc()` function.
            #[link_name = "\u{1}?ReallocateBufferMemory@Delegate@ValueSerializer@v8@@UEAAPEAXPEAX_KPEA_K@Z"]
            pub fn ValueSerializer_Delegate_ReallocateBufferMemory(
                this: *mut ::std::os::raw::c_void,
                old_buffer: *mut ::std::os::raw::c_void,
                size: usize,
                actual_size: *mut usize,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            /// Frees a buffer allocated with |ReallocateBufferMemory|.
            ///
            /// The default implementation uses the stdlib's `free()` function.
            #[link_name = "\u{1}?FreeBufferMemory@Delegate@ValueSerializer@v8@@UEAAXPEAX@Z"]
            pub fn ValueSerializer_Delegate_FreeBufferMemory(
                this: *mut ::std::os::raw::c_void,
                buffer: *mut ::std::os::raw::c_void,
            );
        }
        /// Deserializes values from data written with ValueSerializer, or a compatible
        /// implementation.
        ///
        /// WARNING: This API is under development, and changes (including incompatible
        /// changes to the API or wire format) may occur without notice until this
        /// warning is removed.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ValueDeserializer {
            pub private_: *mut root::v8::ValueDeserializer_PrivateData,
        }
        #[repr(C)]
        pub struct ValueDeserializer_Delegate__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ValueDeserializer_Delegate {
            pub vtable_: *const ValueDeserializer_Delegate__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ValueDeserializer_Delegate() {
            assert_eq!(
                ::std::mem::size_of::<ValueDeserializer_Delegate>(),
                8usize,
                concat!("Size of: ", stringify!(ValueDeserializer_Delegate))
            );
            assert_eq!(
                ::std::mem::align_of::<ValueDeserializer_Delegate>(),
                8usize,
                concat!("Alignment of ", stringify!(ValueDeserializer_Delegate))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ValueDeserializer_PrivateData {
            _unused: [u8; 0],
        }
        #[test]
        fn bindgen_test_layout_ValueDeserializer() {
            assert_eq!(
                ::std::mem::size_of::<ValueDeserializer>(),
                8usize,
                concat!("Size of: ", stringify!(ValueDeserializer))
            );
            assert_eq!(
                ::std::mem::align_of::<ValueDeserializer>(),
                8usize,
                concat!("Alignment of ", stringify!(ValueDeserializer))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ValueDeserializer>())).private_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ValueDeserializer),
                    "::",
                    stringify!(private_)
                )
            );
        }
        extern "C" {
            /// Reads and validates a header (including the format version).
            /// May, for example, reject an invalid or unsupported wire format.
            #[link_name = "\u{1}?ReadHeader@ValueDeserializer@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn ValueDeserializer_ReadHeader(
                this: *mut root::v8::ValueDeserializer,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Deserializes a JavaScript value from the buffer.
            #[link_name = "\u{1}?ReadValue@ValueDeserializer@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn ValueDeserializer_ReadValue(
                this: *mut root::v8::ValueDeserializer,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Accepts the array buffer corresponding to the one passed previously to
            /// ValueSerializer::TransferArrayBuffer.
            #[link_name = "\u{1}?TransferArrayBuffer@ValueDeserializer@v8@@QEAAXIV?$Local@VArrayBuffer@v8@@@2@@Z"]
            pub fn ValueDeserializer_TransferArrayBuffer(
                this: *mut root::v8::ValueDeserializer,
                transfer_id: u32,
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
            );
        }
        extern "C" {
            /// Similar to TransferArrayBuffer, but for SharedArrayBuffer.
            /// The id is not necessarily in the same namespace as unshared ArrayBuffer
            /// objects.
            #[link_name = "\u{1}?TransferSharedArrayBuffer@ValueDeserializer@v8@@QEAAXIV?$Local@VSharedArrayBuffer@v8@@@2@@Z"]
            pub fn ValueDeserializer_TransferSharedArrayBuffer(
                this: *mut root::v8::ValueDeserializer,
                id: u32,
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
            );
        }
        extern "C" {
            /// Must be called before ReadHeader to enable support for reading the legacy
            /// wire format (i.e., which predates this being shipped).
            ///
            /// Don't use this unless you need to read data written by previous versions of
            /// blink::ScriptValueSerializer.
            #[link_name = "\u{1}?SetSupportsLegacyWireFormat@ValueDeserializer@v8@@QEAAX_N@Z"]
            pub fn ValueDeserializer_SetSupportsLegacyWireFormat(
                this: *mut root::v8::ValueDeserializer,
                supports_legacy_wire_format: bool,
            );
        }
        extern "C" {
            /// Expect inline wasm in the data stream (rather than in-memory transfer)
            #[link_name = "\u{1}?SetExpectInlineWasm@ValueDeserializer@v8@@QEAAX_N@Z"]
            pub fn ValueDeserializer_SetExpectInlineWasm(
                this: *mut root::v8::ValueDeserializer,
                allow_inline_wasm: bool,
            );
        }
        extern "C" {
            /// Reads the underlying wire format version. Likely mostly to be useful to
            /// legacy code reading old wire format versions. Must be called after
            /// ReadHeader.
            #[link_name = "\u{1}?GetWireFormatVersion@ValueDeserializer@v8@@QEBAIXZ"]
            pub fn ValueDeserializer_GetWireFormatVersion(
                this: *const root::v8::ValueDeserializer,
            ) -> u32;
        }
        extern "C" {
            /// Reads raw data in various common formats to the buffer.
            /// Note that integer types are read in base-128 varint format, not with a
            /// binary copy. For use during an override of Delegate::ReadHostObject.
            #[link_name = "\u{1}?ReadUint32@ValueDeserializer@v8@@QEAA_NPEAI@Z"]
            pub fn ValueDeserializer_ReadUint32(
                this: *mut root::v8::ValueDeserializer,
                value: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?ReadUint64@ValueDeserializer@v8@@QEAA_NPEA_K@Z"]
            pub fn ValueDeserializer_ReadUint64(
                this: *mut root::v8::ValueDeserializer,
                value: *mut u64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?ReadDouble@ValueDeserializer@v8@@QEAA_NPEAN@Z"]
            pub fn ValueDeserializer_ReadDouble(
                this: *mut root::v8::ValueDeserializer,
                value: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?ReadRawBytes@ValueDeserializer@v8@@QEAA_N_KPEAPEBX@Z"]
            pub fn ValueDeserializer_ReadRawBytes(
                this: *mut root::v8::ValueDeserializer,
                length: usize,
                data: *mut *const ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0ValueDeserializer@v8@@QEAA@PEAVIsolate@1@PEBE_K@Z"]
            pub fn ValueDeserializer_ValueDeserializer(
                this: *mut root::v8::ValueDeserializer,
                isolate: *mut root::v8::Isolate,
                data: *const u8,
                size: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0ValueDeserializer@v8@@QEAA@PEAVIsolate@1@PEBE_KPEAVDelegate@01@@Z"]
            pub fn ValueDeserializer_ValueDeserializer1(
                this: *mut root::v8::ValueDeserializer,
                isolate: *mut root::v8::Isolate,
                data: *const u8,
                size: usize,
                delegate: *mut root::v8::ValueDeserializer_Delegate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DValueDeserializer@v8@@QEAAXXZ"]
            pub fn ValueDeserializer_ValueDeserializer_destructor(
                this: *mut root::v8::ValueDeserializer,
            );
        }
        impl ValueDeserializer {
            #[inline]
            pub unsafe fn ReadHeader(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<bool> {
                ValueDeserializer_ReadHeader(self, context)
            }
            #[inline]
            pub unsafe fn ReadValue(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                ValueDeserializer_ReadValue(self, context)
            }
            #[inline]
            pub unsafe fn TransferArrayBuffer(
                &mut self,
                transfer_id: u32,
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
            ) {
                ValueDeserializer_TransferArrayBuffer(self, transfer_id, array_buffer)
            }
            #[inline]
            pub unsafe fn TransferSharedArrayBuffer(
                &mut self,
                id: u32,
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
            ) {
                ValueDeserializer_TransferSharedArrayBuffer(self, id, shared_array_buffer)
            }
            #[inline]
            pub unsafe fn SetSupportsLegacyWireFormat(
                &mut self,
                supports_legacy_wire_format: bool,
            ) {
                ValueDeserializer_SetSupportsLegacyWireFormat(self, supports_legacy_wire_format)
            }
            #[inline]
            pub unsafe fn SetExpectInlineWasm(&mut self, allow_inline_wasm: bool) {
                ValueDeserializer_SetExpectInlineWasm(self, allow_inline_wasm)
            }
            #[inline]
            pub unsafe fn GetWireFormatVersion(&self) -> u32 {
                ValueDeserializer_GetWireFormatVersion(self)
            }
            #[inline]
            pub unsafe fn ReadUint32(&mut self, value: *mut u32) -> bool {
                ValueDeserializer_ReadUint32(self, value)
            }
            #[inline]
            pub unsafe fn ReadUint64(&mut self, value: *mut u64) -> bool {
                ValueDeserializer_ReadUint64(self, value)
            }
            #[inline]
            pub unsafe fn ReadDouble(&mut self, value: *mut f64) -> bool {
                ValueDeserializer_ReadDouble(self, value)
            }
            #[inline]
            pub unsafe fn ReadRawBytes(
                &mut self,
                length: usize,
                data: *mut *const ::std::os::raw::c_void,
            ) -> bool {
                ValueDeserializer_ReadRawBytes(self, length, data)
            }
            #[inline]
            pub unsafe fn new(
                isolate: *mut root::v8::Isolate,
                data: *const u8,
                size: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ValueDeserializer_ValueDeserializer(&mut __bindgen_tmp, isolate, data, size);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                isolate: *mut root::v8::Isolate,
                data: *const u8,
                size: usize,
                delegate: *mut root::v8::ValueDeserializer_Delegate,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ValueDeserializer_ValueDeserializer1(
                    &mut __bindgen_tmp,
                    isolate,
                    data,
                    size,
                    delegate,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ValueDeserializer_ValueDeserializer_destructor(self)
            }
        }
        extern "C" {
            /// The embedder overrides this method to read some kind of host object, if
            /// possible. If not, a suitable exception should be thrown and
            /// MaybeLocal<Object>() returned.
            #[link_name = "\u{1}?ReadHostObject@Delegate@ValueDeserializer@v8@@UEAA?AV?$MaybeLocal@VObject@v8@@@3@PEAVIsolate@3@@Z"]
            pub fn ValueDeserializer_Delegate_ReadHostObject(
                this: *mut ::std::os::raw::c_void,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::MaybeLocal<root::v8::Object>;
        }
        extern "C" {
            /// Get a WasmCompiledModule given a transfer_id previously provided
            /// by ValueSerializer::GetWasmModuleTransferId
            #[link_name = "\u{1}?GetWasmModuleFromId@Delegate@ValueDeserializer@v8@@UEAA?AV?$MaybeLocal@VWasmCompiledModule@v8@@@3@PEAVIsolate@3@I@Z"]
            pub fn ValueDeserializer_Delegate_GetWasmModuleFromId(
                this: *mut ::std::os::raw::c_void,
                isolate: *mut root::v8::Isolate,
                transfer_id: u32,
            ) -> root::v8::MaybeLocal<root::v8::WasmCompiledModule>;
        }
        extern "C" {
            /// Get a SharedArrayBuffer given a clone_id previously provided
            /// by ValueSerializer::GetSharedArrayBufferId
            #[link_name = "\u{1}?GetSharedArrayBufferFromId@Delegate@ValueDeserializer@v8@@UEAA?AV?$MaybeLocal@VSharedArrayBuffer@v8@@@3@PEAVIsolate@3@I@Z"]
            pub fn ValueDeserializer_Delegate_GetSharedArrayBufferFromId(
                this: *mut ::std::os::raw::c_void,
                isolate: *mut root::v8::Isolate,
                clone_id: u32,
            ) -> root::v8::MaybeLocal<root::v8::SharedArrayBuffer>;
        }
        /// The superclass of all JavaScript values and objects.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Value {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Value() {
            assert_eq!(
                ::std::mem::size_of::<Value>(),
                1usize,
                concat!("Size of: ", stringify!(Value))
            );
            assert_eq!(
                ::std::mem::align_of::<Value>(),
                1usize,
                concat!("Alignment of ", stringify!(Value))
            );
        }
        extern "C" {
            /// Returns true if this value is true.
            #[link_name = "\u{1}?IsTrue@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsTrue(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is false.
            #[link_name = "\u{1}?IsFalse@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsFalse(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a symbol or a string.
            #[link_name = "\u{1}?IsName@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsName(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a symbol.
            #[link_name = "\u{1}?IsSymbol@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsSymbol(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a function.
            #[link_name = "\u{1}?IsFunction@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsFunction(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an array. Note that it will return false for
            /// an Proxy for an array.
            #[link_name = "\u{1}?IsArray@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsArray(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an object.
            #[link_name = "\u{1}?IsObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a bigint.
            #[link_name = "\u{1}?IsBigInt@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsBigInt(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is boolean.
            #[link_name = "\u{1}?IsBoolean@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsBoolean(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a number.
            #[link_name = "\u{1}?IsNumber@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsNumber(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is external.
            #[link_name = "\u{1}?IsExternal@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsExternal(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a 32-bit signed integer.
            #[link_name = "\u{1}?IsInt32@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsInt32(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a 32-bit unsigned integer.
            #[link_name = "\u{1}?IsUint32@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsUint32(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Date.
            #[link_name = "\u{1}?IsDate@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsDate(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Arguments object.
            #[link_name = "\u{1}?IsArgumentsObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsArgumentsObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a BigInt object.
            #[link_name = "\u{1}?IsBigIntObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsBigIntObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Boolean object.
            #[link_name = "\u{1}?IsBooleanObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsBooleanObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Number object.
            #[link_name = "\u{1}?IsNumberObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsNumberObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a String object.
            #[link_name = "\u{1}?IsStringObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsStringObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Symbol object.
            #[link_name = "\u{1}?IsSymbolObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsSymbolObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a NativeError.
            #[link_name = "\u{1}?IsNativeError@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsNativeError(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a RegExp.
            #[link_name = "\u{1}?IsRegExp@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsRegExp(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an async function.
            #[link_name = "\u{1}?IsAsyncFunction@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsAsyncFunction(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Generator function.
            #[link_name = "\u{1}?IsGeneratorFunction@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsGeneratorFunction(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Generator object (iterator).
            #[link_name = "\u{1}?IsGeneratorObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsGeneratorObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Promise.
            #[link_name = "\u{1}?IsPromise@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsPromise(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Map.
            #[link_name = "\u{1}?IsMap@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsMap(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Set.
            #[link_name = "\u{1}?IsSet@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsSet(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Map Iterator.
            #[link_name = "\u{1}?IsMapIterator@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsMapIterator(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Set Iterator.
            #[link_name = "\u{1}?IsSetIterator@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsSetIterator(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a WeakMap.
            #[link_name = "\u{1}?IsWeakMap@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsWeakMap(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a WeakSet.
            #[link_name = "\u{1}?IsWeakSet@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsWeakSet(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an ArrayBuffer.
            #[link_name = "\u{1}?IsArrayBuffer@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsArrayBuffer(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an ArrayBufferView.
            #[link_name = "\u{1}?IsArrayBufferView@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsArrayBufferView(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is one of TypedArrays.
            #[link_name = "\u{1}?IsTypedArray@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsTypedArray(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Uint8Array.
            #[link_name = "\u{1}?IsUint8Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsUint8Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Uint8ClampedArray.
            #[link_name = "\u{1}?IsUint8ClampedArray@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsUint8ClampedArray(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Int8Array.
            #[link_name = "\u{1}?IsInt8Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsInt8Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Uint16Array.
            #[link_name = "\u{1}?IsUint16Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsUint16Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Int16Array.
            #[link_name = "\u{1}?IsInt16Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsInt16Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Uint32Array.
            #[link_name = "\u{1}?IsUint32Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsUint32Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is an Int32Array.
            #[link_name = "\u{1}?IsInt32Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsInt32Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Float32Array.
            #[link_name = "\u{1}?IsFloat32Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsFloat32Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a Float64Array.
            #[link_name = "\u{1}?IsFloat64Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsFloat64Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a BigInt64Array.
            #[link_name = "\u{1}?IsBigInt64Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsBigInt64Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a BigUint64Array.
            #[link_name = "\u{1}?IsBigUint64Array@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsBigUint64Array(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a DataView.
            #[link_name = "\u{1}?IsDataView@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsDataView(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a SharedArrayBuffer.
            /// This is an experimental feature.
            #[link_name = "\u{1}?IsSharedArrayBuffer@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsSharedArrayBuffer(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if this value is a JavaScript Proxy.
            #[link_name = "\u{1}?IsProxy@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsProxy(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?IsWebAssemblyCompiledModule@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsWebAssemblyCompiledModule(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            /// Returns true if the value is a Module Namespace Object.
            #[link_name = "\u{1}?IsModuleNamespaceObject@Value@v8@@QEBA_NXZ"]
            pub fn Value_IsModuleNamespaceObject(this: *const root::v8::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?ToBigInt@Value@v8@@QEBA?AV?$MaybeLocal@VBigInt@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToBigInt(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::BigInt>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToBoolean@Value@v8@@QEBA?AV?$MaybeLocal@VBoolean@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToBoolean(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Boolean>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToNumber@Value@v8@@QEBA?AV?$MaybeLocal@VNumber@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToNumber(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Number>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@Value@v8@@QEBA?AV?$MaybeLocal@VString@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToString(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToDetailString@Value@v8@@QEBA?AV?$MaybeLocal@VString@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToDetailString(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToObject@Value@v8@@QEBA?AV?$MaybeLocal@VObject@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToObject(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Object>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToInteger@Value@v8@@QEBA?AV?$MaybeLocal@VInteger@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToInteger(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Integer>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToUint32@Value@v8@@QEBA?AV?$MaybeLocal@VUint32@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToUint32(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Uint32>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToInt32@Value@v8@@QEBA?AV?$MaybeLocal@VInt32@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToInt32(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Int32>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToBoolean@Value@v8@@QEBA?AV?$Local@VBoolean@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Value_ToBoolean1(
                this: *const root::v8::Value,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Boolean>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToNumber@Value@v8@@QEBA?AV?$Local@VNumber@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Value_ToNumber1(
                this: *const root::v8::Value,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Number>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@Value@v8@@QEBA?AV?$Local@VString@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Value_ToString1(
                this: *const root::v8::Value,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToObject@Value@v8@@QEBA?AV?$Local@VObject@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Value_ToObject1(
                this: *const root::v8::Value,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Object>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToInteger@Value@v8@@QEBA?AV?$Local@VInteger@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Value_ToInteger1(
                this: *const root::v8::Value,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Integer>;
        }
        extern "C" {
            #[link_name = "\u{1}?ToInt32@Value@v8@@QEBA?AV?$Local@VInt32@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Value_ToInt321(
                this: *const root::v8::Value,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Int32>;
        }
        extern "C" {
            /// Attempts to convert a string to an array index.
            /// Returns an empty handle if the conversion fails.
            #[link_name = "\u{1}?ToArrayIndex@Value@v8@@QEBA?AV?$MaybeLocal@VUint32@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_ToArrayIndex(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Uint32>;
        }
        extern "C" {
            #[link_name = "\u{1}?BooleanValue@Value@v8@@QEBA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_BooleanValue(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?NumberValue@Value@v8@@QEBA?AV?$Maybe@N@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_NumberValue(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<f64>;
        }
        extern "C" {
            #[link_name = "\u{1}?IntegerValue@Value@v8@@QEBA?AV?$Maybe@_J@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_IntegerValue(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<i64>;
        }
        extern "C" {
            #[link_name = "\u{1}?Uint32Value@Value@v8@@QEBA?AV?$Maybe@I@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_Uint32Value(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<u32>;
        }
        extern "C" {
            #[link_name = "\u{1}?Int32Value@Value@v8@@QEBA?AV?$Maybe@H@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Value_Int32Value(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<i32>;
        }
        extern "C" {
            /// JS ==
            #[link_name = "\u{1}?Equals@Value@v8@@QEBA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Value_Equals(
                this: *const root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
                that: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?StrictEquals@Value@v8@@QEBA_NV?$Local@VValue@v8@@@2@@Z"]
            pub fn Value_StrictEquals(
                this: *const root::v8::Value,
                that: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?SameValue@Value@v8@@QEBA_NV?$Local@VValue@v8@@@2@@Z"]
            pub fn Value_SameValue(
                this: *const root::v8::Value,
                that: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?TypeOf@Value@v8@@QEAA?AV?$Local@VString@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Value_TypeOf(
                this: *mut root::v8::Value,
                arg1: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            #[link_name = "\u{1}?InstanceOf@Value@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VObject@v8@@@2@@Z"]
            pub fn Value_InstanceOf(
                this: *mut root::v8::Value,
                context: root::v8::Local<root::v8::Context>,
                object: root::v8::Local<root::v8::Object>,
            ) -> root::v8::Maybe<bool>;
        }
        impl Value {
            #[inline]
            pub unsafe fn IsTrue(&self) -> bool {
                Value_IsTrue(self)
            }
            #[inline]
            pub unsafe fn IsFalse(&self) -> bool {
                Value_IsFalse(self)
            }
            #[inline]
            pub unsafe fn IsName(&self) -> bool {
                Value_IsName(self)
            }
            #[inline]
            pub unsafe fn IsSymbol(&self) -> bool {
                Value_IsSymbol(self)
            }
            #[inline]
            pub unsafe fn IsFunction(&self) -> bool {
                Value_IsFunction(self)
            }
            #[inline]
            pub unsafe fn IsArray(&self) -> bool {
                Value_IsArray(self)
            }
            #[inline]
            pub unsafe fn IsObject(&self) -> bool {
                Value_IsObject(self)
            }
            #[inline]
            pub unsafe fn IsBigInt(&self) -> bool {
                Value_IsBigInt(self)
            }
            #[inline]
            pub unsafe fn IsBoolean(&self) -> bool {
                Value_IsBoolean(self)
            }
            #[inline]
            pub unsafe fn IsNumber(&self) -> bool {
                Value_IsNumber(self)
            }
            #[inline]
            pub unsafe fn IsExternal(&self) -> bool {
                Value_IsExternal(self)
            }
            #[inline]
            pub unsafe fn IsInt32(&self) -> bool {
                Value_IsInt32(self)
            }
            #[inline]
            pub unsafe fn IsUint32(&self) -> bool {
                Value_IsUint32(self)
            }
            #[inline]
            pub unsafe fn IsDate(&self) -> bool {
                Value_IsDate(self)
            }
            #[inline]
            pub unsafe fn IsArgumentsObject(&self) -> bool {
                Value_IsArgumentsObject(self)
            }
            #[inline]
            pub unsafe fn IsBigIntObject(&self) -> bool {
                Value_IsBigIntObject(self)
            }
            #[inline]
            pub unsafe fn IsBooleanObject(&self) -> bool {
                Value_IsBooleanObject(self)
            }
            #[inline]
            pub unsafe fn IsNumberObject(&self) -> bool {
                Value_IsNumberObject(self)
            }
            #[inline]
            pub unsafe fn IsStringObject(&self) -> bool {
                Value_IsStringObject(self)
            }
            #[inline]
            pub unsafe fn IsSymbolObject(&self) -> bool {
                Value_IsSymbolObject(self)
            }
            #[inline]
            pub unsafe fn IsNativeError(&self) -> bool {
                Value_IsNativeError(self)
            }
            #[inline]
            pub unsafe fn IsRegExp(&self) -> bool {
                Value_IsRegExp(self)
            }
            #[inline]
            pub unsafe fn IsAsyncFunction(&self) -> bool {
                Value_IsAsyncFunction(self)
            }
            #[inline]
            pub unsafe fn IsGeneratorFunction(&self) -> bool {
                Value_IsGeneratorFunction(self)
            }
            #[inline]
            pub unsafe fn IsGeneratorObject(&self) -> bool {
                Value_IsGeneratorObject(self)
            }
            #[inline]
            pub unsafe fn IsPromise(&self) -> bool {
                Value_IsPromise(self)
            }
            #[inline]
            pub unsafe fn IsMap(&self) -> bool {
                Value_IsMap(self)
            }
            #[inline]
            pub unsafe fn IsSet(&self) -> bool {
                Value_IsSet(self)
            }
            #[inline]
            pub unsafe fn IsMapIterator(&self) -> bool {
                Value_IsMapIterator(self)
            }
            #[inline]
            pub unsafe fn IsSetIterator(&self) -> bool {
                Value_IsSetIterator(self)
            }
            #[inline]
            pub unsafe fn IsWeakMap(&self) -> bool {
                Value_IsWeakMap(self)
            }
            #[inline]
            pub unsafe fn IsWeakSet(&self) -> bool {
                Value_IsWeakSet(self)
            }
            #[inline]
            pub unsafe fn IsArrayBuffer(&self) -> bool {
                Value_IsArrayBuffer(self)
            }
            #[inline]
            pub unsafe fn IsArrayBufferView(&self) -> bool {
                Value_IsArrayBufferView(self)
            }
            #[inline]
            pub unsafe fn IsTypedArray(&self) -> bool {
                Value_IsTypedArray(self)
            }
            #[inline]
            pub unsafe fn IsUint8Array(&self) -> bool {
                Value_IsUint8Array(self)
            }
            #[inline]
            pub unsafe fn IsUint8ClampedArray(&self) -> bool {
                Value_IsUint8ClampedArray(self)
            }
            #[inline]
            pub unsafe fn IsInt8Array(&self) -> bool {
                Value_IsInt8Array(self)
            }
            #[inline]
            pub unsafe fn IsUint16Array(&self) -> bool {
                Value_IsUint16Array(self)
            }
            #[inline]
            pub unsafe fn IsInt16Array(&self) -> bool {
                Value_IsInt16Array(self)
            }
            #[inline]
            pub unsafe fn IsUint32Array(&self) -> bool {
                Value_IsUint32Array(self)
            }
            #[inline]
            pub unsafe fn IsInt32Array(&self) -> bool {
                Value_IsInt32Array(self)
            }
            #[inline]
            pub unsafe fn IsFloat32Array(&self) -> bool {
                Value_IsFloat32Array(self)
            }
            #[inline]
            pub unsafe fn IsFloat64Array(&self) -> bool {
                Value_IsFloat64Array(self)
            }
            #[inline]
            pub unsafe fn IsBigInt64Array(&self) -> bool {
                Value_IsBigInt64Array(self)
            }
            #[inline]
            pub unsafe fn IsBigUint64Array(&self) -> bool {
                Value_IsBigUint64Array(self)
            }
            #[inline]
            pub unsafe fn IsDataView(&self) -> bool {
                Value_IsDataView(self)
            }
            #[inline]
            pub unsafe fn IsSharedArrayBuffer(&self) -> bool {
                Value_IsSharedArrayBuffer(self)
            }
            #[inline]
            pub unsafe fn IsProxy(&self) -> bool {
                Value_IsProxy(self)
            }
            #[inline]
            pub unsafe fn IsWebAssemblyCompiledModule(&self) -> bool {
                Value_IsWebAssemblyCompiledModule(self)
            }
            #[inline]
            pub unsafe fn IsModuleNamespaceObject(&self) -> bool {
                Value_IsModuleNamespaceObject(self)
            }
            #[inline]
            pub unsafe fn ToBigInt(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::BigInt> {
                Value_ToBigInt(self, context)
            }
            #[inline]
            pub unsafe fn ToBoolean(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Boolean> {
                Value_ToBoolean(self, context)
            }
            #[inline]
            pub unsafe fn ToNumber(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Number> {
                Value_ToNumber(self, context)
            }
            #[inline]
            pub unsafe fn ToString(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                Value_ToString(self, context)
            }
            #[inline]
            pub unsafe fn ToDetailString(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                Value_ToDetailString(self, context)
            }
            #[inline]
            pub unsafe fn ToObject(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Object> {
                Value_ToObject(self, context)
            }
            #[inline]
            pub unsafe fn ToInteger(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Integer> {
                Value_ToInteger(self, context)
            }
            #[inline]
            pub unsafe fn ToUint32(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Uint32> {
                Value_ToUint32(self, context)
            }
            #[inline]
            pub unsafe fn ToInt32(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Int32> {
                Value_ToInt32(self, context)
            }
            #[inline]
            pub unsafe fn ToBoolean1(
                &self,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Boolean> {
                Value_ToBoolean1(self, isolate)
            }
            #[inline]
            pub unsafe fn ToNumber1(
                &self,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Number> {
                Value_ToNumber1(self, isolate)
            }
            #[inline]
            pub unsafe fn ToString1(
                &self,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::String> {
                Value_ToString1(self, isolate)
            }
            #[inline]
            pub unsafe fn ToObject1(
                &self,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Object> {
                Value_ToObject1(self, isolate)
            }
            #[inline]
            pub unsafe fn ToInteger1(
                &self,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Integer> {
                Value_ToInteger1(self, isolate)
            }
            #[inline]
            pub unsafe fn ToInt321(
                &self,
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Int32> {
                Value_ToInt321(self, isolate)
            }
            #[inline]
            pub unsafe fn ToArrayIndex(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Uint32> {
                Value_ToArrayIndex(self, context)
            }
            #[inline]
            pub unsafe fn BooleanValue(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<bool> {
                Value_BooleanValue(self, context)
            }
            #[inline]
            pub unsafe fn NumberValue(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<f64> {
                Value_NumberValue(self, context)
            }
            #[inline]
            pub unsafe fn IntegerValue(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<i64> {
                Value_IntegerValue(self, context)
            }
            #[inline]
            pub unsafe fn Uint32Value(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<u32> {
                Value_Uint32Value(self, context)
            }
            #[inline]
            pub unsafe fn Int32Value(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::Maybe<i32> {
                Value_Int32Value(self, context)
            }
            #[inline]
            pub unsafe fn Equals(
                &self,
                context: root::v8::Local<root::v8::Context>,
                that: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Value_Equals(self, context, that)
            }
            #[inline]
            pub unsafe fn StrictEquals(&self, that: root::v8::Local<root::v8::Value>) -> bool {
                Value_StrictEquals(self, that)
            }
            #[inline]
            pub unsafe fn SameValue(&self, that: root::v8::Local<root::v8::Value>) -> bool {
                Value_SameValue(self, that)
            }
            #[inline]
            pub unsafe fn TypeOf(
                &mut self,
                arg1: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::String> {
                Value_TypeOf(self, arg1)
            }
            #[inline]
            pub unsafe fn InstanceOf(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                object: root::v8::Local<root::v8::Object>,
            ) -> root::v8::Maybe<bool> {
                Value_InstanceOf(self, context, object)
            }
        }
        /// The superclass of primitive values.  See ECMA-262 4.3.2.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Primitive {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Primitive() {
            assert_eq!(
                ::std::mem::size_of::<Primitive>(),
                1usize,
                concat!("Size of: ", stringify!(Primitive))
            );
            assert_eq!(
                ::std::mem::align_of::<Primitive>(),
                1usize,
                concat!("Alignment of ", stringify!(Primitive))
            );
        }
        /// A primitive boolean value (ECMA-262, 4.3.14).  Either the true
        /// or false value.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Boolean {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Boolean() {
            assert_eq!(
                ::std::mem::size_of::<Boolean>(),
                1usize,
                concat!("Size of: ", stringify!(Boolean))
            );
            assert_eq!(
                ::std::mem::align_of::<Boolean>(),
                1usize,
                concat!("Alignment of ", stringify!(Boolean))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Value@Boolean@v8@@QEBA_NXZ"]
            pub fn Boolean_Value(this: *const root::v8::Boolean) -> bool;
        }
        impl Boolean {
            #[inline]
            pub unsafe fn Value(&self) -> bool {
                Boolean_Value(self)
            }
        }
        /// A superclass for symbols and strings.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Name {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Name() {
            assert_eq!(
                ::std::mem::size_of::<Name>(),
                1usize,
                concat!("Size of: ", stringify!(Name))
            );
            assert_eq!(
                ::std::mem::align_of::<Name>(),
                1usize,
                concat!("Alignment of ", stringify!(Name))
            );
        }
        extern "C" {
            /// Returns the identity hash for this object. The current implementation
            /// uses an inline property on the object to store the identity hash.
            ///
            /// The return value will never be 0. Also, it is not guaranteed to be
            /// unique.
            #[link_name = "\u{1}?GetIdentityHash@Name@v8@@QEAAHXZ"]
            pub fn Name_GetIdentityHash(this: *mut root::v8::Name) -> ::std::os::raw::c_int;
        }
        impl Name {
            #[inline]
            pub unsafe fn GetIdentityHash(&mut self) -> ::std::os::raw::c_int {
                Name_GetIdentityHash(self)
            }
        }
        /// Create a new string, always allocating new storage memory.
        pub const NewStringType_kNormal: root::v8::NewStringType = 0;
        /// Acts as a hint that the string should be created in the
        /// old generation heap space and be deduplicated if an identical string
        /// already exists.
        pub const NewStringType_kInternalized: root::v8::NewStringType = 1;
        /// A flag describing different modes of string creation.
        ///
        /// Aside from performance implications there are no differences between the two
        /// creation modes.
        pub type NewStringType = i32;
        /// A JavaScript string value (ECMA-262, 4.3.17).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct String {
            pub _address: u8,
        }
        pub const String_Encoding_UNKNOWN_ENCODING: root::v8::String_Encoding = 1;
        pub const String_Encoding_TWO_BYTE_ENCODING: root::v8::String_Encoding = 0;
        pub const String_Encoding_ONE_BYTE_ENCODING: root::v8::String_Encoding = 8;
        pub type String_Encoding = i32;
        pub const String_WriteOptions_NO_OPTIONS: root::v8::String_WriteOptions = 0;
        pub const String_WriteOptions_HINT_MANY_WRITES_EXPECTED: root::v8::String_WriteOptions = 1;
        pub const String_WriteOptions_NO_NULL_TERMINATION: root::v8::String_WriteOptions = 2;
        pub const String_WriteOptions_PRESERVE_ONE_BYTE_NULL: root::v8::String_WriteOptions = 4;
        pub const String_WriteOptions_REPLACE_INVALID_UTF8: root::v8::String_WriteOptions = 8;
        /// Write the contents of the string to an external buffer.
        /// If no arguments are given, expects the buffer to be large
        /// enough to hold the entire string and NULL terminator. Copies
        /// the contents of the string and the NULL terminator into the
        /// buffer.
        ///
        /// WriteUtf8 will not write partial UTF-8 sequences, preferring to stop
        /// before the end of the buffer.
        ///
        /// Copies up to length characters into the output buffer.
        /// Only null-terminates if there is enough space in the buffer.
        ///
        /// \param buffer The buffer into which the string will be copied.
        /// \param start The starting position within the string at which
        /// copying begins.
        /// \param length The number of characters to copy from the string.  For
        /// WriteUtf8 the number of bytes in the buffer.
        /// \param nchars_ref The number of characters written, can be NULL.
        /// \param options Various options that might affect performance of this or
        /// subsequent operations.
        /// \return The number of characters copied to the buffer excluding the null
        /// terminator.  For WriteUtf8: The number of bytes copied to the buffer
        /// including the null terminator (if written).
        pub type String_WriteOptions = i32;
        #[repr(C)]
        pub struct String_ExternalStringResourceBase__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct String_ExternalStringResourceBase {
            pub vtable_: *const String_ExternalStringResourceBase__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_String_ExternalStringResourceBase() {
            assert_eq!(
                ::std::mem::size_of::<String_ExternalStringResourceBase>(),
                8usize,
                concat!("Size of: ", stringify!(String_ExternalStringResourceBase))
            );
            assert_eq!(
                ::std::mem::align_of::<String_ExternalStringResourceBase>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(String_ExternalStringResourceBase)
                )
            );
        }
        /// An ExternalStringResource is a wrapper around a two-byte string
        /// buffer that resides outside V8's heap. Implement an
        /// ExternalStringResource to manage the life cycle of the underlying
        /// buffer.  Note that the string data must be immutable.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct String_ExternalStringResource {
            pub _base: root::v8::String_ExternalStringResourceBase,
        }
        #[test]
        fn bindgen_test_layout_String_ExternalStringResource() {
            assert_eq!(
                ::std::mem::size_of::<String_ExternalStringResource>(),
                8usize,
                concat!("Size of: ", stringify!(String_ExternalStringResource))
            );
            assert_eq!(
                ::std::mem::align_of::<String_ExternalStringResource>(),
                8usize,
                concat!("Alignment of ", stringify!(String_ExternalStringResource))
            );
        }
        /// An ExternalOneByteStringResource is a wrapper around an one-byte
        /// string buffer that resides outside V8's heap. Implement an
        /// ExternalOneByteStringResource to manage the life cycle of the
        /// underlying buffer.  Note that the string data must be immutable
        /// and that the data must be Latin-1 and not UTF-8, which would require
        /// special treatment internally in the engine and do not allow efficient
        /// indexing.  Use String::New or convert to 16 bit data for non-Latin1.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct String_ExternalOneByteStringResource {
            pub _base: root::v8::String_ExternalStringResourceBase,
        }
        #[test]
        fn bindgen_test_layout_String_ExternalOneByteStringResource() {
            assert_eq!(
                ::std::mem::size_of::<String_ExternalOneByteStringResource>(),
                8usize,
                concat!(
                    "Size of: ",
                    stringify!(String_ExternalOneByteStringResource)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<String_ExternalOneByteStringResource>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(String_ExternalOneByteStringResource)
                )
            );
        }
        pub const String_NewStringType_kNormalString: root::v8::String_NewStringType = 0;
        pub const String_NewStringType_kInternalizedString: root::v8::String_NewStringType = 1;
        pub type String_NewStringType = i32;
        /// Converts an object to a UTF-8-encoded character array.  Useful if
        /// you want to print the object.  If conversion to a string fails
        /// (e.g. due to an exception in the toString() method of the object)
        /// then the length() method returns 0 and the * operator returns
        /// NULL.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct String_Utf8Value {
            pub str_: *mut ::std::os::raw::c_char,
            pub length_: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_String_Utf8Value() {
            assert_eq!(
                ::std::mem::size_of::<String_Utf8Value>(),
                16usize,
                concat!("Size of: ", stringify!(String_Utf8Value))
            );
            assert_eq!(
                ::std::mem::align_of::<String_Utf8Value>(),
                8usize,
                concat!("Alignment of ", stringify!(String_Utf8Value))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<String_Utf8Value>())).str_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(String_Utf8Value),
                    "::",
                    stringify!(str_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<String_Utf8Value>())).length_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(String_Utf8Value),
                    "::",
                    stringify!(length_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0Utf8Value@String@v8@@QEAA@PEAVIsolate@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn String_Utf8Value_Utf8Value(
                this: *mut root::v8::String_Utf8Value,
                isolate: *mut root::v8::Isolate,
                obj: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DUtf8Value@String@v8@@QEAAXXZ"]
            pub fn String_Utf8Value_Utf8Value_destructor(this: *mut root::v8::String_Utf8Value);
        }
        impl String_Utf8Value {
            #[inline]
            pub unsafe fn new(
                isolate: *mut root::v8::Isolate,
                obj: root::v8::Local<root::v8::Value>,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                String_Utf8Value_Utf8Value(&mut __bindgen_tmp, isolate, obj);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                String_Utf8Value_Utf8Value_destructor(self)
            }
        }
        /// Converts an object to a two-byte (UTF-16-encoded) string.
        /// If conversion to a string fails (eg. due to an exception in the toString()
        /// method of the object) then the length() method returns 0 and the * operator
        /// returns NULL.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct String_Value {
            pub str_: *mut u16,
            pub length_: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_String_Value() {
            assert_eq!(
                ::std::mem::size_of::<String_Value>(),
                16usize,
                concat!("Size of: ", stringify!(String_Value))
            );
            assert_eq!(
                ::std::mem::align_of::<String_Value>(),
                8usize,
                concat!("Alignment of ", stringify!(String_Value))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<String_Value>())).str_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(String_Value),
                    "::",
                    stringify!(str_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<String_Value>())).length_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(String_Value),
                    "::",
                    stringify!(length_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0Value@String@v8@@QEAA@PEAVIsolate@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn String_Value_Value(
                this: *mut root::v8::String_Value,
                isolate: *mut root::v8::Isolate,
                obj: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DValue@String@v8@@QEAAXXZ"]
            pub fn String_Value_Value_destructor(this: *mut root::v8::String_Value);
        }
        impl String_Value {
            #[inline]
            pub unsafe fn new(
                isolate: *mut root::v8::Isolate,
                obj: root::v8::Local<root::v8::Value>,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                String_Value_Value(&mut __bindgen_tmp, isolate, obj);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                String_Value_Value_destructor(self)
            }
        }
        pub const String_kMaxLength: ::std::os::raw::c_int = 1073741799;
        #[test]
        fn bindgen_test_layout_String() {
            assert_eq!(
                ::std::mem::size_of::<String>(),
                1usize,
                concat!("Size of: ", stringify!(String))
            );
            assert_eq!(
                ::std::mem::align_of::<String>(),
                1usize,
                concat!("Alignment of ", stringify!(String))
            );
        }
        extern "C" {
            /// Returns the number of characters (UTF-16 code units) in this string.
            #[link_name = "\u{1}?Length@String@v8@@QEBAHXZ"]
            pub fn String_Length(this: *const root::v8::String) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the number of bytes in the UTF-8 encoded
            /// representation of this string.
            #[link_name = "\u{1}?Utf8Length@String@v8@@QEBAHPEAVIsolate@2@@Z"]
            pub fn String_Utf8Length(
                this: *const root::v8::String,
                isolate: *mut root::v8::Isolate,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns whether this string is known to contain only one byte data,
            /// i.e. ISO-8859-1 code points.
            /// Does not read the string.
            /// False negatives are possible.
            #[link_name = "\u{1}?IsOneByte@String@v8@@QEBA_NXZ"]
            pub fn String_IsOneByte(this: *const root::v8::String) -> bool;
        }
        extern "C" {
            /// Returns whether this string contain only one byte data,
            /// i.e. ISO-8859-1 code points.
            /// Will read the entire string in some cases.
            #[link_name = "\u{1}?ContainsOnlyOneByte@String@v8@@QEBA_NXZ"]
            pub fn String_ContainsOnlyOneByte(this: *const root::v8::String) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Write@String@v8@@QEBAHPEAVIsolate@2@PEAGHHH@Z"]
            pub fn String_Write(
                this: *const root::v8::String,
                isolate: *mut root::v8::Isolate,
                buffer: *mut u16,
                start: ::std::os::raw::c_int,
                length: ::std::os::raw::c_int,
                options: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?WriteOneByte@String@v8@@QEBAHPEAVIsolate@2@PEAEHHH@Z"]
            pub fn String_WriteOneByte(
                this: *const root::v8::String,
                isolate: *mut root::v8::Isolate,
                buffer: *mut u8,
                start: ::std::os::raw::c_int,
                length: ::std::os::raw::c_int,
                options: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?WriteUtf8@String@v8@@QEBAHPEAVIsolate@2@PEADHPEAHH@Z"]
            pub fn String_WriteUtf8(
                this: *const root::v8::String,
                isolate: *mut root::v8::Isolate,
                buffer: *mut ::std::os::raw::c_char,
                length: ::std::os::raw::c_int,
                nchars_ref: *mut ::std::os::raw::c_int,
                options: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns true if the string is external
            #[link_name = "\u{1}?IsExternal@String@v8@@QEBA_NXZ"]
            pub fn String_IsExternal(this: *const root::v8::String) -> bool;
        }
        extern "C" {
            /// Returns true if the string is both external and one-byte.
            #[link_name = "\u{1}?IsExternalOneByte@String@v8@@QEBA_NXZ"]
            pub fn String_IsExternalOneByte(this: *const root::v8::String) -> bool;
        }
        extern "C" {
            /// Get the ExternalOneByteStringResource for an external one-byte string.
            /// Returns NULL if IsExternalOneByte() doesn't return true.
            #[link_name = "\u{1}?GetExternalOneByteStringResource@String@v8@@QEBAPEBVExternalOneByteStringResource@12@XZ"]
            pub fn String_GetExternalOneByteStringResource(
                this: *const root::v8::String,
            ) -> *const root::v8::String_ExternalOneByteStringResource;
        }
        extern "C" {
            #[link_name = "\u{1}?NewFromUtf8@String@v8@@SA?AV?$Local@VString@v8@@@2@PEAVIsolate@2@PEBDW4NewStringType@12@H@Z"]
            pub fn String_NewFromUtf8(
                isolate: *mut root::v8::Isolate,
                data: *const ::std::os::raw::c_char,
                type_: root::v8::String_NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Allocates a new string from UTF-8 data. Only returns an empty value when
            /// length > kMaxLength.
            #[link_name = "\u{1}?NewFromUtf8@String@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@PEAVIsolate@2@PEBDW4NewStringType@2@H@Z"]
            pub fn String_NewFromUtf81(
                isolate: *mut root::v8::Isolate,
                data: *const ::std::os::raw::c_char,
                type_: root::v8::NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            /// Allocates a new string from Latin-1 data.  Only returns an empty value
            /// when length > kMaxLength.
            #[link_name = "\u{1}?NewFromOneByte@String@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@PEAVIsolate@2@PEBEW4NewStringType@2@H@Z"]
            pub fn String_NewFromOneByte(
                isolate: *mut root::v8::Isolate,
                data: *const u8,
                type_: root::v8::NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            #[link_name = "\u{1}?NewFromTwoByte@String@v8@@SA?AV?$Local@VString@v8@@@2@PEAVIsolate@2@PEBGW4NewStringType@12@H@Z"]
            pub fn String_NewFromTwoByte(
                isolate: *mut root::v8::Isolate,
                data: *const u16,
                type_: root::v8::String_NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Allocates a new string from UTF-16 data. Only returns an empty value when
            /// length > kMaxLength.
            #[link_name = "\u{1}?NewFromTwoByte@String@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@PEAVIsolate@2@PEBGW4NewStringType@2@H@Z"]
            pub fn String_NewFromTwoByte1(
                isolate: *mut root::v8::Isolate,
                data: *const u16,
                type_: root::v8::NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            /// Creates a new string by concatenating the left and the right strings
            /// passed in as parameters.
            #[link_name = "\u{1}?Concat@String@v8@@SA?AV?$Local@VString@v8@@@2@PEAVIsolate@2@V32@1@Z"]
            pub fn String_Concat(
                isolate: *mut root::v8::Isolate,
                left: root::v8::Local<root::v8::String>,
                right: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Creates a new external string using the data defined in the given
            /// resource. When the external string is no longer live on V8's heap the
            /// resource will be disposed by calling its Dispose method. The caller of
            /// this function should not otherwise delete or modify the resource. Neither
            /// should the underlying buffer be deallocated or modified except through the
            /// destructor of the external string resource.
            #[link_name = "\u{1}?NewExternalTwoByte@String@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@PEAVIsolate@2@PEAVExternalStringResource@12@@Z"]
            pub fn String_NewExternalTwoByte(
                isolate: *mut root::v8::Isolate,
                resource: *mut root::v8::String_ExternalStringResource,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            /// Associate an external string resource with this string by transforming it
            /// in place so that existing references to this string in the JavaScript heap
            /// will use the external string resource. The external string resource's
            /// character contents need to be equivalent to this string.
            /// Returns true if the string has been changed to be an external string.
            /// The string is not modified if the operation fails. See NewExternal for
            /// information on the lifetime of the resource.
            #[link_name = "\u{1}?MakeExternal@String@v8@@QEAA_NPEAVExternalStringResource@12@@Z"]
            pub fn String_MakeExternal(
                this: *mut root::v8::String,
                resource: *mut root::v8::String_ExternalStringResource,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?NewExternal@String@v8@@SA?AV?$Local@VString@v8@@@2@PEAVIsolate@2@PEAVExternalOneByteStringResource@12@@Z"]
            pub fn String_NewExternal(
                isolate: *mut root::v8::Isolate,
                resource: *mut root::v8::String_ExternalOneByteStringResource,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            #[link_name = "\u{1}?NewExternalOneByte@String@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@PEAVIsolate@2@PEAVExternalOneByteStringResource@12@@Z"]
            pub fn String_NewExternalOneByte(
                isolate: *mut root::v8::Isolate,
                resource: *mut root::v8::String_ExternalOneByteStringResource,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            /// Associate an external string resource with this string by transforming it
            /// in place so that existing references to this string in the JavaScript heap
            /// will use the external string resource. The external string resource's
            /// character contents need to be equivalent to this string.
            /// Returns true if the string has been changed to be an external string.
            /// The string is not modified if the operation fails. See NewExternal for
            /// information on the lifetime of the resource.
            #[link_name = "\u{1}?MakeExternal@String@v8@@QEAA_NPEAVExternalOneByteStringResource@12@@Z"]
            pub fn String_MakeExternal1(
                this: *mut root::v8::String,
                resource: *mut root::v8::String_ExternalOneByteStringResource,
            ) -> bool;
        }
        extern "C" {
            /// Returns true if this string can be made external.
            #[link_name = "\u{1}?CanMakeExternal@String@v8@@QEAA_NXZ"]
            pub fn String_CanMakeExternal(this: *mut root::v8::String) -> bool;
        }
        extern "C" {
            /// Returns true if the strings values are equal. Same as JS ==/===.
            #[link_name = "\u{1}?StringEquals@String@v8@@QEAA_NV?$Local@VString@v8@@@2@@Z"]
            pub fn String_StringEquals(
                this: *mut root::v8::String,
                str: root::v8::Local<root::v8::String>,
            ) -> bool;
        }
        impl String {
            #[inline]
            pub unsafe fn Length(&self) -> ::std::os::raw::c_int {
                String_Length(self)
            }
            #[inline]
            pub unsafe fn Utf8Length(
                &self,
                isolate: *mut root::v8::Isolate,
            ) -> ::std::os::raw::c_int {
                String_Utf8Length(self, isolate)
            }
            #[inline]
            pub unsafe fn IsOneByte(&self) -> bool {
                String_IsOneByte(self)
            }
            #[inline]
            pub unsafe fn ContainsOnlyOneByte(&self) -> bool {
                String_ContainsOnlyOneByte(self)
            }
            #[inline]
            pub unsafe fn Write(
                &self,
                isolate: *mut root::v8::Isolate,
                buffer: *mut u16,
                start: ::std::os::raw::c_int,
                length: ::std::os::raw::c_int,
                options: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                String_Write(self, isolate, buffer, start, length, options)
            }
            #[inline]
            pub unsafe fn WriteOneByte(
                &self,
                isolate: *mut root::v8::Isolate,
                buffer: *mut u8,
                start: ::std::os::raw::c_int,
                length: ::std::os::raw::c_int,
                options: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                String_WriteOneByte(self, isolate, buffer, start, length, options)
            }
            #[inline]
            pub unsafe fn WriteUtf8(
                &self,
                isolate: *mut root::v8::Isolate,
                buffer: *mut ::std::os::raw::c_char,
                length: ::std::os::raw::c_int,
                nchars_ref: *mut ::std::os::raw::c_int,
                options: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                String_WriteUtf8(self, isolate, buffer, length, nchars_ref, options)
            }
            #[inline]
            pub unsafe fn IsExternal(&self) -> bool {
                String_IsExternal(self)
            }
            #[inline]
            pub unsafe fn IsExternalOneByte(&self) -> bool {
                String_IsExternalOneByte(self)
            }
            #[inline]
            pub unsafe fn GetExternalOneByteStringResource(
                &self,
            ) -> *const root::v8::String_ExternalOneByteStringResource {
                String_GetExternalOneByteStringResource(self)
            }
            #[inline]
            pub unsafe fn NewFromUtf8(
                isolate: *mut root::v8::Isolate,
                data: *const ::std::os::raw::c_char,
                type_: root::v8::String_NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::String> {
                String_NewFromUtf8(isolate, data, type_, length)
            }
            #[inline]
            pub unsafe fn NewFromUtf81(
                isolate: *mut root::v8::Isolate,
                data: *const ::std::os::raw::c_char,
                type_: root::v8::NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                String_NewFromUtf81(isolate, data, type_, length)
            }
            #[inline]
            pub unsafe fn NewFromOneByte(
                isolate: *mut root::v8::Isolate,
                data: *const u8,
                type_: root::v8::NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                String_NewFromOneByte(isolate, data, type_, length)
            }
            #[inline]
            pub unsafe fn NewFromTwoByte(
                isolate: *mut root::v8::Isolate,
                data: *const u16,
                type_: root::v8::String_NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::String> {
                String_NewFromTwoByte(isolate, data, type_, length)
            }
            #[inline]
            pub unsafe fn NewFromTwoByte1(
                isolate: *mut root::v8::Isolate,
                data: *const u16,
                type_: root::v8::NewStringType,
                length: ::std::os::raw::c_int,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                String_NewFromTwoByte1(isolate, data, type_, length)
            }
            #[inline]
            pub unsafe fn Concat(
                isolate: *mut root::v8::Isolate,
                left: root::v8::Local<root::v8::String>,
                right: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::String> {
                String_Concat(isolate, left, right)
            }
            #[inline]
            pub unsafe fn NewExternalTwoByte(
                isolate: *mut root::v8::Isolate,
                resource: *mut root::v8::String_ExternalStringResource,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                String_NewExternalTwoByte(isolate, resource)
            }
            #[inline]
            pub unsafe fn MakeExternal(
                &mut self,
                resource: *mut root::v8::String_ExternalStringResource,
            ) -> bool {
                String_MakeExternal(self, resource)
            }
            #[inline]
            pub unsafe fn NewExternal(
                isolate: *mut root::v8::Isolate,
                resource: *mut root::v8::String_ExternalOneByteStringResource,
            ) -> root::v8::Local<root::v8::String> {
                String_NewExternal(isolate, resource)
            }
            #[inline]
            pub unsafe fn NewExternalOneByte(
                isolate: *mut root::v8::Isolate,
                resource: *mut root::v8::String_ExternalOneByteStringResource,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                String_NewExternalOneByte(isolate, resource)
            }
            #[inline]
            pub unsafe fn MakeExternal1(
                &mut self,
                resource: *mut root::v8::String_ExternalOneByteStringResource,
            ) -> bool {
                String_MakeExternal1(self, resource)
            }
            #[inline]
            pub unsafe fn CanMakeExternal(&mut self) -> bool {
                String_CanMakeExternal(self)
            }
            #[inline]
            pub unsafe fn StringEquals(&mut self, str: root::v8::Local<root::v8::String>) -> bool {
                String_StringEquals(self, str)
            }
        }
        /// A JavaScript symbol (ECMA-262 edition 6)
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Symbol {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Symbol() {
            assert_eq!(
                ::std::mem::size_of::<Symbol>(),
                1usize,
                concat!("Size of: ", stringify!(Symbol))
            );
            assert_eq!(
                ::std::mem::align_of::<Symbol>(),
                1usize,
                concat!("Alignment of ", stringify!(Symbol))
            );
        }
        extern "C" {
            /// Returns the print name string of the symbol, or undefined if none.
            #[link_name = "\u{1}?Name@Symbol@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Symbol_Name(this: *const root::v8::Symbol) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Create a symbol. If name is not empty, it will be used as the description.
            #[link_name = "\u{1}?New@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Symbol_New(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            /// Access global symbol registry.
            /// Note that symbols created this way are never collected, so
            /// they should only be used for statically fixed properties.
            /// Also, there is only one global name space for the names used as keys.
            /// To minimize the potential for clashes, use qualified names as keys.
            #[link_name = "\u{1}?For@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Symbol_For(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            /// Retrieve a global symbol. Similar to |For|, but using a separate
            /// registry that is not accessible by (and cannot clash with) JavaScript code.
            #[link_name = "\u{1}?ForApi@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Symbol_ForApi(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetAsyncIterator@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetAsyncIterator(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetHasInstance@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetHasInstance(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetIsConcatSpreadable@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetIsConcatSpreadable(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetIterator@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetIterator(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetMatch@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetMatch(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetReplace@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetReplace(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetSearch@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetSearch(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetSplit@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetSplit(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetToPrimitive@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetToPrimitive(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetToStringTag@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetToStringTag(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetUnscopables@Symbol@v8@@SA?AV?$Local@VSymbol@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Symbol_GetUnscopables(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        impl Symbol {
            #[inline]
            pub unsafe fn Name(&self) -> root::v8::Local<root::v8::Value> {
                Symbol_Name(self)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_New(isolate, name)
            }
            #[inline]
            pub unsafe fn For(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_For(isolate, name)
            }
            #[inline]
            pub unsafe fn ForApi(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_ForApi(isolate, name)
            }
            #[inline]
            pub unsafe fn GetAsyncIterator(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetAsyncIterator(isolate)
            }
            #[inline]
            pub unsafe fn GetHasInstance(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetHasInstance(isolate)
            }
            #[inline]
            pub unsafe fn GetIsConcatSpreadable(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetIsConcatSpreadable(isolate)
            }
            #[inline]
            pub unsafe fn GetIterator(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetIterator(isolate)
            }
            #[inline]
            pub unsafe fn GetMatch(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetMatch(isolate)
            }
            #[inline]
            pub unsafe fn GetReplace(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetReplace(isolate)
            }
            #[inline]
            pub unsafe fn GetSearch(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetSearch(isolate)
            }
            #[inline]
            pub unsafe fn GetSplit(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetSplit(isolate)
            }
            #[inline]
            pub unsafe fn GetToPrimitive(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetToPrimitive(isolate)
            }
            #[inline]
            pub unsafe fn GetToStringTag(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetToStringTag(isolate)
            }
            #[inline]
            pub unsafe fn GetUnscopables(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Symbol> {
                Symbol_GetUnscopables(isolate)
            }
        }
        /// A private symbol
        ///
        /// This is an experimental feature. Use at your own risk.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Private {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Private() {
            assert_eq!(
                ::std::mem::size_of::<Private>(),
                1usize,
                concat!("Size of: ", stringify!(Private))
            );
            assert_eq!(
                ::std::mem::align_of::<Private>(),
                1usize,
                concat!("Alignment of ", stringify!(Private))
            );
        }
        extern "C" {
            /// Returns the print name string of the private symbol, or undefined if none.
            #[link_name = "\u{1}?Name@Private@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Private_Name(this: *const root::v8::Private)
                -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Create a private symbol. If name is not empty, it will be the description.
            #[link_name = "\u{1}?New@Private@v8@@SA?AV?$Local@VPrivate@v8@@@2@PEAVIsolate@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Private_New(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Private>;
        }
        extern "C" {
            /// Retrieve a global private symbol. If a symbol with this name has not
            /// been retrieved in the same isolate before, it is created.
            /// Note that private symbols created this way are never collected, so
            /// they should only be used for statically fixed properties.
            /// Also, there is only one global name space for the names used as keys.
            /// To minimize the potential for clashes, use qualified names as keys,
            /// e.g., "Class#property".
            #[link_name = "\u{1}?ForApi@Private@v8@@SA?AV?$Local@VPrivate@v8@@@2@PEAVIsolate@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Private_ForApi(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Private>;
        }
        impl Private {
            #[inline]
            pub unsafe fn Name(&self) -> root::v8::Local<root::v8::Value> {
                Private_Name(self)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Private> {
                Private_New(isolate, name)
            }
            #[inline]
            pub unsafe fn ForApi(
                isolate: *mut root::v8::Isolate,
                name: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Private> {
                Private_ForApi(isolate, name)
            }
        }
        /// A JavaScript number value (ECMA-262, 4.3.20)
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Number {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Number() {
            assert_eq!(
                ::std::mem::size_of::<Number>(),
                1usize,
                concat!("Size of: ", stringify!(Number))
            );
            assert_eq!(
                ::std::mem::align_of::<Number>(),
                1usize,
                concat!("Alignment of ", stringify!(Number))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Value@Number@v8@@QEBANXZ"]
            pub fn Number_Value(this: *const root::v8::Number) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Number@v8@@SA?AV?$Local@VNumber@v8@@@2@PEAVIsolate@2@N@Z"]
            pub fn Number_New(
                isolate: *mut root::v8::Isolate,
                value: f64,
            ) -> root::v8::Local<root::v8::Number>;
        }
        impl Number {
            #[inline]
            pub unsafe fn Value(&self) -> f64 {
                Number_Value(self)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: f64,
            ) -> root::v8::Local<root::v8::Number> {
                Number_New(isolate, value)
            }
        }
        /// A JavaScript value representing a signed integer.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Integer {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Integer() {
            assert_eq!(
                ::std::mem::size_of::<Integer>(),
                1usize,
                concat!("Size of: ", stringify!(Integer))
            );
            assert_eq!(
                ::std::mem::align_of::<Integer>(),
                1usize,
                concat!("Alignment of ", stringify!(Integer))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Integer@v8@@SA?AV?$Local@VInteger@v8@@@2@PEAVIsolate@2@H@Z"]
            pub fn Integer_New(
                isolate: *mut root::v8::Isolate,
                value: i32,
            ) -> root::v8::Local<root::v8::Integer>;
        }
        extern "C" {
            #[link_name = "\u{1}?NewFromUnsigned@Integer@v8@@SA?AV?$Local@VInteger@v8@@@2@PEAVIsolate@2@I@Z"]
            pub fn Integer_NewFromUnsigned(
                isolate: *mut root::v8::Isolate,
                value: u32,
            ) -> root::v8::Local<root::v8::Integer>;
        }
        extern "C" {
            #[link_name = "\u{1}?Value@Integer@v8@@QEBA_JXZ"]
            pub fn Integer_Value(this: *const root::v8::Integer) -> i64;
        }
        impl Integer {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: i32,
            ) -> root::v8::Local<root::v8::Integer> {
                Integer_New(isolate, value)
            }
            #[inline]
            pub unsafe fn NewFromUnsigned(
                isolate: *mut root::v8::Isolate,
                value: u32,
            ) -> root::v8::Local<root::v8::Integer> {
                Integer_NewFromUnsigned(isolate, value)
            }
            #[inline]
            pub unsafe fn Value(&self) -> i64 {
                Integer_Value(self)
            }
        }
        /// A JavaScript value representing a 32-bit signed integer.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Int32 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Int32() {
            assert_eq!(
                ::std::mem::size_of::<Int32>(),
                1usize,
                concat!("Size of: ", stringify!(Int32))
            );
            assert_eq!(
                ::std::mem::align_of::<Int32>(),
                1usize,
                concat!("Alignment of ", stringify!(Int32))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Value@Int32@v8@@QEBAHXZ"]
            pub fn Int32_Value(this: *const root::v8::Int32) -> i32;
        }
        impl Int32 {
            #[inline]
            pub unsafe fn Value(&self) -> i32 {
                Int32_Value(self)
            }
        }
        /// A JavaScript value representing a 32-bit unsigned integer.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Uint32 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Uint32() {
            assert_eq!(
                ::std::mem::size_of::<Uint32>(),
                1usize,
                concat!("Size of: ", stringify!(Uint32))
            );
            assert_eq!(
                ::std::mem::align_of::<Uint32>(),
                1usize,
                concat!("Alignment of ", stringify!(Uint32))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Value@Uint32@v8@@QEBAIXZ"]
            pub fn Uint32_Value(this: *const root::v8::Uint32) -> u32;
        }
        impl Uint32 {
            #[inline]
            pub unsafe fn Value(&self) -> u32 {
                Uint32_Value(self)
            }
        }
        /// A JavaScript BigInt value (https://tc39.github.io/proposal-bigint)
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct BigInt {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_BigInt() {
            assert_eq!(
                ::std::mem::size_of::<BigInt>(),
                1usize,
                concat!("Size of: ", stringify!(BigInt))
            );
            assert_eq!(
                ::std::mem::align_of::<BigInt>(),
                1usize,
                concat!("Alignment of ", stringify!(BigInt))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@BigInt@v8@@SA?AV?$Local@VBigInt@v8@@@2@PEAVIsolate@2@_J@Z"]
            pub fn BigInt_New(
                isolate: *mut root::v8::Isolate,
                value: i64,
            ) -> root::v8::Local<root::v8::BigInt>;
        }
        extern "C" {
            #[link_name = "\u{1}?NewFromUnsigned@BigInt@v8@@SA?AV?$Local@VBigInt@v8@@@2@PEAVIsolate@2@_K@Z"]
            pub fn BigInt_NewFromUnsigned(
                isolate: *mut root::v8::Isolate,
                value: u64,
            ) -> root::v8::Local<root::v8::BigInt>;
        }
        extern "C" {
            /// Creates a new BigInt object using a specified sign bit and a
            /// specified list of digits/words.
            /// The resulting number is calculated as:
            ///
            /// (-1)^sign_bit * (words[0] * (2^64)^0 + words[1] * (2^64)^1 + ...)
            #[link_name = "\u{1}?NewFromWords@BigInt@v8@@SA?AV?$MaybeLocal@VBigInt@v8@@@2@V?$Local@VContext@v8@@@2@HHPEB_K@Z"]
            pub fn BigInt_NewFromWords(
                context: root::v8::Local<root::v8::Context>,
                sign_bit: ::std::os::raw::c_int,
                word_count: ::std::os::raw::c_int,
                words: *const u64,
            ) -> root::v8::MaybeLocal<root::v8::BigInt>;
        }
        extern "C" {
            /// Returns the value of this BigInt as an unsigned 64-bit integer.
            /// If `lossless` is provided, it will reflect whether the return value was
            /// truncated or wrapped around. In particular, it is set to `false` if this
            /// BigInt is negative.
            #[link_name = "\u{1}?Uint64Value@BigInt@v8@@QEBA_KPEA_N@Z"]
            pub fn BigInt_Uint64Value(this: *const root::v8::BigInt, lossless: *mut bool) -> u64;
        }
        extern "C" {
            /// Returns the value of this BigInt as a signed 64-bit integer.
            /// If `lossless` is provided, it will reflect whether this BigInt was
            /// truncated or not.
            #[link_name = "\u{1}?Int64Value@BigInt@v8@@QEBA_JPEA_N@Z"]
            pub fn BigInt_Int64Value(this: *const root::v8::BigInt, lossless: *mut bool) -> i64;
        }
        extern "C" {
            /// Returns the number of 64-bit words needed to store the result of
            /// ToWordsArray().
            #[link_name = "\u{1}?WordCount@BigInt@v8@@QEBAHXZ"]
            pub fn BigInt_WordCount(this: *const root::v8::BigInt) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Writes the contents of this BigInt to a specified memory location.
            /// `sign_bit` must be provided and will be set to 1 if this BigInt is
            /// negative.
            /// `*word_count` has to be initialized to the length of the `words` array.
            /// Upon return, it will be set to the actual number of words that would
            /// be needed to store this BigInt (i.e. the return value of `WordCount()`).
            #[link_name = "\u{1}?ToWordsArray@BigInt@v8@@QEBAXPEAH0PEA_K@Z"]
            pub fn BigInt_ToWordsArray(
                this: *const root::v8::BigInt,
                sign_bit: *mut ::std::os::raw::c_int,
                word_count: *mut ::std::os::raw::c_int,
                words: *mut u64,
            );
        }
        impl BigInt {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: i64,
            ) -> root::v8::Local<root::v8::BigInt> {
                BigInt_New(isolate, value)
            }
            #[inline]
            pub unsafe fn NewFromUnsigned(
                isolate: *mut root::v8::Isolate,
                value: u64,
            ) -> root::v8::Local<root::v8::BigInt> {
                BigInt_NewFromUnsigned(isolate, value)
            }
            #[inline]
            pub unsafe fn NewFromWords(
                context: root::v8::Local<root::v8::Context>,
                sign_bit: ::std::os::raw::c_int,
                word_count: ::std::os::raw::c_int,
                words: *const u64,
            ) -> root::v8::MaybeLocal<root::v8::BigInt> {
                BigInt_NewFromWords(context, sign_bit, word_count, words)
            }
            #[inline]
            pub unsafe fn Uint64Value(&self, lossless: *mut bool) -> u64 {
                BigInt_Uint64Value(self, lossless)
            }
            #[inline]
            pub unsafe fn Int64Value(&self, lossless: *mut bool) -> i64 {
                BigInt_Int64Value(self, lossless)
            }
            #[inline]
            pub unsafe fn WordCount(&self) -> ::std::os::raw::c_int {
                BigInt_WordCount(self)
            }
            #[inline]
            pub unsafe fn ToWordsArray(
                &self,
                sign_bit: *mut ::std::os::raw::c_int,
                word_count: *mut ::std::os::raw::c_int,
                words: *mut u64,
            ) {
                BigInt_ToWordsArray(self, sign_bit, word_count, words)
            }
        }
        /// None.
        pub const PropertyAttribute_None: root::v8::PropertyAttribute = 0;
        /// ReadOnly, i.e., not writable.
        pub const PropertyAttribute_ReadOnly: root::v8::PropertyAttribute = 1;
        /// DontEnum, i.e., not enumerable.
        pub const PropertyAttribute_DontEnum: root::v8::PropertyAttribute = 2;
        /// DontDelete, i.e., not configurable.
        pub const PropertyAttribute_DontDelete: root::v8::PropertyAttribute = 4;
        /// PropertyAttribute.
        pub type PropertyAttribute = i32;
        /// Accessor[Getter|Setter] are used as callback functions when
        /// setting|getting a particular property. See Object and ObjectTemplate's
        /// method SetAccessor.
        pub type AccessorGetterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::String>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        pub type AccessorNameGetterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        pub type AccessorSetterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::String>,
                value: root::v8::Local<root::v8::Value>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        pub type AccessorNameSetterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Value>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        pub const AccessControl_DEFAULT: root::v8::AccessControl = 0;
        pub const AccessControl_ALL_CAN_READ: root::v8::AccessControl = 1;
        pub const AccessControl_ALL_CAN_WRITE: root::v8::AccessControl = 2;
        pub const AccessControl_PROHIBITS_OVERWRITING: root::v8::AccessControl = 4;
        /// Access control specifications.
        ///
        /// Some accessors should be accessible across contexts.  These
        /// accessors have an explicit access control parameter which specifies
        /// the kind of cross-context access that should be allowed.
        ///
        /// TODO(dcarney): Remove PROHIBITS_OVERWRITING as it is now unused.
        pub type AccessControl = i32;
        pub const PropertyFilter_ALL_PROPERTIES: root::v8::PropertyFilter = 0;
        pub const PropertyFilter_ONLY_WRITABLE: root::v8::PropertyFilter = 1;
        pub const PropertyFilter_ONLY_ENUMERABLE: root::v8::PropertyFilter = 2;
        pub const PropertyFilter_ONLY_CONFIGURABLE: root::v8::PropertyFilter = 4;
        pub const PropertyFilter_SKIP_STRINGS: root::v8::PropertyFilter = 8;
        pub const PropertyFilter_SKIP_SYMBOLS: root::v8::PropertyFilter = 16;
        /// Property filter bits. They can be or'ed to build a composite filter.
        pub type PropertyFilter = i32;
        pub const SideEffectType_kHasSideEffect: root::v8::SideEffectType = 0;
        pub const SideEffectType_kHasNoSideEffect: root::v8::SideEffectType = 1;
        /// Options for marking whether callbacks may trigger JS-observable side effects.
        /// Side-effect-free callbacks are whitelisted during debug evaluation with
        /// throwOnSideEffect. It applies when calling a Function, FunctionTemplate,
        /// or an Accessor's getter callback. For Interceptors, please see
        /// PropertyHandlerFlags's kHasNoSideEffect.
        pub type SideEffectType = i32;
        pub const KeyCollectionMode_kOwnOnly: root::v8::KeyCollectionMode = 0;
        pub const KeyCollectionMode_kIncludePrototypes: root::v8::KeyCollectionMode = 1;
        /// Keys/Properties filter enums:
        ///
        /// KeyCollectionMode limits the range of collected properties. kOwnOnly limits
        /// the collected properties to the given Object only. kIncludesPrototypes will
        /// include all keys of the objects's prototype chain as well.
        pub type KeyCollectionMode = i32;
        pub const IndexFilter_kIncludeIndices: root::v8::IndexFilter = 0;
        pub const IndexFilter_kSkipIndices: root::v8::IndexFilter = 1;
        /// kIncludesIndices allows for integer indices to be collected, while
        /// kSkipIndices will exclude integer indices from being collected.
        pub type IndexFilter = i32;
        pub const KeyConversionMode_kConvertToString: root::v8::KeyConversionMode = 0;
        pub const KeyConversionMode_kKeepNumbers: root::v8::KeyConversionMode = 1;
        /// kConvertToString will convert integer indices to strings.
        /// kKeepNumbers will return numbers for integer indices.
        pub type KeyConversionMode = i32;
        pub const IntegrityLevel_kFrozen: root::v8::IntegrityLevel = 0;
        pub const IntegrityLevel_kSealed: root::v8::IntegrityLevel = 1;
        /// Integrity level for objects.
        pub type IntegrityLevel = i32;
        /// A JavaScript object (ECMA-262, 4.3.3)
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Object {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Object() {
            assert_eq!(
                ::std::mem::size_of::<Object>(),
                1usize,
                concat!("Size of: ", stringify!(Object))
            );
            assert_eq!(
                ::std::mem::align_of::<Object>(),
                1usize,
                concat!("Alignment of ", stringify!(Object))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Object@v8@@QEAA_NV?$Local@VValue@v8@@@2@0@Z"]
            pub fn Object_Set(
                this: *mut root::v8::Object,
                key: root::v8::Local<root::v8::Value>,
                value: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@1@Z"]
            pub fn Object_Set1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Object@v8@@QEAA_NIV?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_Set2(
                this: *mut root::v8::Object,
                index: u32,
                value: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@IV?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_Set3(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateDataProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_CreateDataProperty(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateDataProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@IV?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_CreateDataProperty1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?DefineOwnProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@V?$Local@VValue@v8@@@2@W4PropertyAttribute@2@@Z"]
            pub fn Object_DefineOwnProperty(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Value>,
                attributes: root::v8::PropertyAttribute,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?DefineProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@AEAVPropertyDescriptor@2@@Z"]
            pub fn Object_DefineProperty(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
                descriptor: *mut root::v8::PropertyDescriptor,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Get@Object@v8@@QEAA?AV?$Local@VValue@v8@@@2@V32@@Z"]
            pub fn Object_Get(
                this: *mut root::v8::Object,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Get@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_Get1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Get@Object@v8@@QEAA?AV?$Local@VValue@v8@@@2@I@Z"]
            pub fn Object_Get2(
                this: *mut root::v8::Object,
                index: u32,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Get@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@I@Z"]
            pub fn Object_Get3(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Gets the property attributes of a property which can be None or
            /// any combination of ReadOnly, DontEnum and DontDelete. Returns
            /// None when the property doesn't exist.
            #[link_name = "\u{1}?GetPropertyAttributes@Object@v8@@QEAA?AV?$Maybe@W4PropertyAttribute@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_GetPropertyAttributes(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<root::v8::PropertyAttribute>;
        }
        extern "C" {
            /// Returns Object.getOwnPropertyDescriptor as per ES2016 section 19.1.2.6.
            #[link_name = "\u{1}?GetOwnPropertyDescriptor@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_GetOwnPropertyDescriptor(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Has@Object@v8@@QEAA_NV?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_Has(
                this: *mut root::v8::Object,
                key: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            /// Object::Has() calls the abstract operation HasProperty(O, P) described
            /// in ECMA-262, 7.3.10. Has() returns
            /// true, if the object has the property, either own or on the prototype chain.
            /// Interceptors, i.e., PropertyQueryCallbacks, are called if present.
            ///
            /// Has() has the same side effects as JavaScript's `variable in object`.
            /// For example, calling Has() on a revoked proxy will throw an exception.
            ///
            /// \note Has() converts the key to a name, which possibly calls back into
            /// JavaScript.
            ///
            /// See also v8::Object::HasOwnProperty() and
            /// v8::Object::HasRealNamedProperty().
            #[link_name = "\u{1}?Has@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_Has1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Delete@Object@v8@@QEAA_NV?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_Delete(
                this: *mut root::v8::Object,
                key: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Delete@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_Delete1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Has@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@I@Z"]
            pub fn Object_Has2(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Delete@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@I@Z"]
            pub fn Object_Delete2(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Note: SideEffectType affects the getter only, not the setter.
            #[link_name = "\u{1}?SetAccessor@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@P6AX1AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZP6AX1V?$Local@VValue@v8@@@2@AEBV?$PropertyCallbackInfo@X@2@@ZV?$MaybeLocal@VValue@v8@@@2@W4AccessControl@2@W4PropertyAttribute@2@W4SideEffectType@2@@Z"]
            pub fn Object_SetAccessor(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::MaybeLocal<root::v8::Value>,
                settings: root::v8::AccessControl,
                attribute: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?SetAccessorProperty@Object@v8@@QEAAXV?$Local@VName@v8@@@2@V?$Local@VFunction@v8@@@2@1W4PropertyAttribute@2@W4AccessControl@2@@Z"]
            pub fn Object_SetAccessorProperty(
                this: *mut root::v8::Object,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::Local<root::v8::Function>,
                setter: root::v8::Local<root::v8::Function>,
                attribute: root::v8::PropertyAttribute,
                settings: root::v8::AccessControl,
            );
        }
        extern "C" {
            /// Sets a native data property like Template::SetNativeDataProperty, but
            /// this method sets on this object directly.
            #[link_name = "\u{1}?SetNativeDataProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@P6AX1AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZP6AX1V?$Local@VValue@v8@@@2@AEBV?$PropertyCallbackInfo@X@2@@Z4W4PropertyAttribute@2@W4SideEffectType@2@@Z"]
            pub fn Object_SetNativeDataProperty(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attributes: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Attempts to create a property with the given name which behaves like a data
            /// property, except that the provided getter is invoked (and provided with the
            /// data value) to supply its value the first time it is read. After the
            /// property is accessed once, it is replaced with an ordinary data property.
            ///
            /// Analogous to Template::SetLazyDataProperty.
            #[link_name = "\u{1}?SetLazyDataProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@P6AX1AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@W4PropertyAttribute@2@W4SideEffectType@2@@Z"]
            pub fn Object_SetLazyDataProperty(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attributes: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Functionality for private properties.
            /// This is an experimental feature, use at your own risk.
            /// Note: Private properties are not inherited. Do not rely on this, since it
            /// may change.
            #[link_name = "\u{1}?HasPrivate@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VPrivate@v8@@@2@@Z"]
            pub fn Object_HasPrivate(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?SetPrivate@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VPrivate@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_SetPrivate(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?DeletePrivate@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VPrivate@v8@@@2@@Z"]
            pub fn Object_DeletePrivate(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetPrivate@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VPrivate@v8@@@2@@Z"]
            pub fn Object_GetPrivate(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetPropertyNames@Object@v8@@QEAA?AV?$Local@VArray@v8@@@2@XZ"]
            pub fn Object_GetPropertyNames(
                this: *mut root::v8::Object,
            ) -> root::v8::Local<root::v8::Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetPropertyNames@Object@v8@@QEAA?AV?$MaybeLocal@VArray@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Object_GetPropertyNames1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetPropertyNames@Object@v8@@QEAA?AV?$MaybeLocal@VArray@v8@@@2@V?$Local@VContext@v8@@@2@W4KeyCollectionMode@2@W4PropertyFilter@2@W4IndexFilter@2@W4KeyConversionMode@2@@Z"]
            pub fn Object_GetPropertyNames2(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                mode: root::v8::KeyCollectionMode,
                property_filter: root::v8::PropertyFilter,
                index_filter: root::v8::IndexFilter,
                key_conversion: root::v8::KeyConversionMode,
            ) -> root::v8::MaybeLocal<root::v8::Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetOwnPropertyNames@Object@v8@@QEAA?AV?$Local@VArray@v8@@@2@XZ"]
            pub fn Object_GetOwnPropertyNames(
                this: *mut root::v8::Object,
            ) -> root::v8::Local<root::v8::Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetOwnPropertyNames@Object@v8@@QEAA?AV?$MaybeLocal@VArray@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Object_GetOwnPropertyNames1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Array>;
        }
        extern "C" {
            /// Returns an array containing the names of the filtered properties
            /// of this object, including properties from prototype objects.  The
            /// array returned by this method contains the same values as would
            /// be enumerated by a for-in statement over this object.
            #[link_name = "\u{1}?GetOwnPropertyNames@Object@v8@@QEAA?AV?$MaybeLocal@VArray@v8@@@2@V?$Local@VContext@v8@@@2@W4PropertyFilter@2@W4KeyConversionMode@2@@Z"]
            pub fn Object_GetOwnPropertyNames2(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                filter: root::v8::PropertyFilter,
                key_conversion: root::v8::KeyConversionMode,
            ) -> root::v8::MaybeLocal<root::v8::Array>;
        }
        extern "C" {
            /// Get the prototype object.  This does not skip objects marked to
            /// be skipped by __proto__ and it does not consult the security
            /// handler.
            #[link_name = "\u{1}?GetPrototype@Object@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Object_GetPrototype(
                this: *mut root::v8::Object,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Set the prototype object.  This does not skip objects marked to
            /// be skipped by __proto__ and it does not consult the security
            /// handler.
            #[link_name = "\u{1}?SetPrototype@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_SetPrototype(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                prototype: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Finds an instance of the given function template in the prototype
            /// chain.
            #[link_name = "\u{1}?FindInstanceInPrototypeChain@Object@v8@@QEAA?AV?$Local@VObject@v8@@@2@V?$Local@VFunctionTemplate@v8@@@2@@Z"]
            pub fn Object_FindInstanceInPrototypeChain(
                this: *mut root::v8::Object,
                tmpl: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::Object>;
        }
        extern "C" {
            /// Call builtin Object.prototype.toString on this object.
            /// This is different from Value::ToString() that may call
            /// user-defined toString function. This one does not.
            #[link_name = "\u{1}?ObjectProtoToString@Object@v8@@QEAA?AV?$MaybeLocal@VString@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Object_ObjectProtoToString(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String>;
        }
        extern "C" {
            /// Returns the name of the function invoked as a constructor for this object.
            #[link_name = "\u{1}?GetConstructorName@Object@v8@@QEAA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn Object_GetConstructorName(
                this: *mut root::v8::Object,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Sets the integrity level of the object.
            #[link_name = "\u{1}?SetIntegrityLevel@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@W4IntegrityLevel@2@@Z"]
            pub fn Object_SetIntegrityLevel(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                level: root::v8::IntegrityLevel,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Gets the number of internal fields for this Object.
            #[link_name = "\u{1}?InternalFieldCount@Object@v8@@QEAAHXZ"]
            pub fn Object_InternalFieldCount(this: *mut root::v8::Object) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Sets the value in an internal field.
            #[link_name = "\u{1}?SetInternalField@Object@v8@@QEAAXHV?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_SetInternalField(
                this: *mut root::v8::Object,
                index: ::std::os::raw::c_int,
                value: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            /// Sets a 2-byte-aligned native pointer in an internal field. To retrieve such
            /// a field, GetAlignedPointerFromInternalField must be used, everything else
            /// leads to undefined behavior.
            #[link_name = "\u{1}?SetAlignedPointerInInternalField@Object@v8@@QEAAXHPEAX@Z"]
            pub fn Object_SetAlignedPointerInInternalField(
                this: *mut root::v8::Object,
                index: ::std::os::raw::c_int,
                value: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetAlignedPointerInInternalFields@Object@v8@@QEAAXHQEAHQEAPEAX@Z"]
            pub fn Object_SetAlignedPointerInInternalFields(
                this: *mut root::v8::Object,
                argc: ::std::os::raw::c_int,
                indices: *mut ::std::os::raw::c_int,
                values: *mut *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            /// HasOwnProperty() is like JavaScript's Object.prototype.hasOwnProperty().
            ///
            /// See also v8::Object::Has() and v8::Object::HasRealNamedProperty().
            #[link_name = "\u{1}?HasOwnProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_HasOwnProperty(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?HasOwnProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@I@Z"]
            pub fn Object_HasOwnProperty1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?HasRealNamedProperty@Object@v8@@QEAA_NV?$Local@VString@v8@@@2@@Z"]
            pub fn Object_HasRealNamedProperty(
                this: *mut root::v8::Object,
                key: root::v8::Local<root::v8::String>,
            ) -> bool;
        }
        extern "C" {
            /// Use HasRealNamedProperty() if you want to check if an object has an own
            /// property without causing side effects, i.e., without calling interceptors.
            ///
            /// This function is similar to v8::Object::HasOwnProperty(), but it does not
            /// call interceptors.
            ///
            /// \note Consider using non-masking interceptors, i.e., the interceptors are
            /// not called if the receiver has the real named property. See
            /// `v8::PropertyHandlerFlags::kNonMasking`.
            ///
            /// See also v8::Object::Has().
            #[link_name = "\u{1}?HasRealNamedProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_HasRealNamedProperty1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?HasRealIndexedProperty@Object@v8@@QEAA_NI@Z"]
            pub fn Object_HasRealIndexedProperty(this: *mut root::v8::Object, index: u32) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?HasRealIndexedProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@I@Z"]
            pub fn Object_HasRealIndexedProperty1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?HasRealNamedCallbackProperty@Object@v8@@QEAA_NV?$Local@VString@v8@@@2@@Z"]
            pub fn Object_HasRealNamedCallbackProperty(
                this: *mut root::v8::Object,
                key: root::v8::Local<root::v8::String>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?HasRealNamedCallbackProperty@Object@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_HasRealNamedCallbackProperty1(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// If result.IsEmpty() no real property was located in the prototype chain.
            /// This means interceptors in the prototype chain are not called.
            #[link_name = "\u{1}?GetRealNamedPropertyInPrototypeChain@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_GetRealNamedPropertyInPrototypeChain(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Gets the property attributes of a real property in the prototype chain,
            /// which can be None or any combination of ReadOnly, DontEnum and DontDelete.
            /// Interceptors in the prototype chain are not called.
            #[link_name = "\u{1}?GetRealNamedPropertyAttributesInPrototypeChain@Object@v8@@QEAA?AV?$Maybe@W4PropertyAttribute@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_GetRealNamedPropertyAttributesInPrototypeChain(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<root::v8::PropertyAttribute>;
        }
        extern "C" {
            /// If result.IsEmpty() no real property was located on the object or
            /// in the prototype chain.
            /// This means interceptors in the prototype chain are not called.
            #[link_name = "\u{1}?GetRealNamedProperty@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_GetRealNamedProperty(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Gets the property attributes of a real property which can be
            /// None or any combination of ReadOnly, DontEnum and DontDelete.
            /// Interceptors in the prototype chain are not called.
            #[link_name = "\u{1}?GetRealNamedPropertyAttributes@Object@v8@@QEAA?AV?$Maybe@W4PropertyAttribute@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VName@v8@@@2@@Z"]
            pub fn Object_GetRealNamedPropertyAttributes(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<root::v8::PropertyAttribute>;
        }
        extern "C" {
            /// Tests for a named lookup interceptor.
            #[link_name = "\u{1}?HasNamedLookupInterceptor@Object@v8@@QEAA_NXZ"]
            pub fn Object_HasNamedLookupInterceptor(this: *mut root::v8::Object) -> bool;
        }
        extern "C" {
            /// Tests for an index lookup interceptor.
            #[link_name = "\u{1}?HasIndexedLookupInterceptor@Object@v8@@QEAA_NXZ"]
            pub fn Object_HasIndexedLookupInterceptor(this: *mut root::v8::Object) -> bool;
        }
        extern "C" {
            /// Returns the identity hash for this object. The current implementation
            /// uses a hidden property on the object to store the identity hash.
            ///
            /// The return value will never be 0. Also, it is not guaranteed to be
            /// unique.
            #[link_name = "\u{1}?GetIdentityHash@Object@v8@@QEAAHXZ"]
            pub fn Object_GetIdentityHash(this: *mut root::v8::Object) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Clone this object with a fast but shallow copy.  Values will point
            /// to the same values as the original object.
            #[link_name = "\u{1}?Clone@Object@v8@@QEAA?AV?$Local@VObject@v8@@@2@XZ"]
            pub fn Object_Clone(this: *mut root::v8::Object) -> root::v8::Local<root::v8::Object>;
        }
        extern "C" {
            /// Returns the context in which the object was created.
            #[link_name = "\u{1}?CreationContext@Object@v8@@QEAA?AV?$Local@VContext@v8@@@2@XZ"]
            pub fn Object_CreationContext(
                this: *mut root::v8::Object,
            ) -> root::v8::Local<root::v8::Context>;
        }
        extern "C" {
            /// Checks whether a callback is set by the
            /// ObjectTemplate::SetCallAsFunctionHandler method.
            /// When an Object is callable this method returns true.
            #[link_name = "\u{1}?IsCallable@Object@v8@@QEAA_NXZ"]
            pub fn Object_IsCallable(this: *mut root::v8::Object) -> bool;
        }
        extern "C" {
            /// True if this object is a constructor.
            #[link_name = "\u{1}?IsConstructor@Object@v8@@QEAA_NXZ"]
            pub fn Object_IsConstructor(this: *mut root::v8::Object) -> bool;
        }
        extern "C" {
            /// Call an Object as a function if a callback is set by the
            /// ObjectTemplate::SetCallAsFunctionHandler method.
            #[link_name = "\u{1}?CallAsFunction@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@HQEAV52@@Z"]
            pub fn Object_CallAsFunction(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                recv: root::v8::Local<root::v8::Value>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Call an Object as a constructor if a callback is set by the
            /// ObjectTemplate::SetCallAsFunctionHandler method.
            /// Note: This method behaves like the Function::NewInstance method.
            #[link_name = "\u{1}?CallAsConstructor@Object@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@HQEAV?$Local@VValue@v8@@@2@@Z"]
            pub fn Object_CallAsConstructor(
                this: *mut root::v8::Object,
                context: root::v8::Local<root::v8::Context>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Return the isolate to which the Object belongs to.
            #[link_name = "\u{1}?GetIsolate@Object@v8@@QEAAPEAVIsolate@2@XZ"]
            pub fn Object_GetIsolate(this: *mut root::v8::Object) -> *mut root::v8::Isolate;
        }
        extern "C" {
            /// If this object is a Set, Map, WeakSet or WeakMap, this returns a
            /// representation of the elements of this object as an array.
            /// If this object is a SetIterator or MapIterator, this returns all
            /// elements of the underlying collection, starting at the iterator's current
            /// position.
            /// For other types, this will return an empty MaybeLocal<Array> (without
            /// scheduling an exception).
            #[link_name = "\u{1}?PreviewEntries@Object@v8@@QEAA?AV?$MaybeLocal@VArray@v8@@@2@PEA_N@Z"]
            pub fn Object_PreviewEntries(
                this: *mut root::v8::Object,
                is_key_value: *mut bool,
            ) -> root::v8::MaybeLocal<root::v8::Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Object@v8@@SA?AV?$Local@VObject@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Object_New(isolate: *mut root::v8::Isolate)
                -> root::v8::Local<root::v8::Object>;
        }
        impl Object {
            #[inline]
            pub unsafe fn Set(
                &mut self,
                key: root::v8::Local<root::v8::Value>,
                value: root::v8::Local<root::v8::Value>,
            ) -> bool {
                Object_Set(self, key, value)
            }
            #[inline]
            pub unsafe fn Set1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_Set1(self, context, key, value)
            }
            #[inline]
            pub unsafe fn Set2(
                &mut self,
                index: u32,
                value: root::v8::Local<root::v8::Value>,
            ) -> bool {
                Object_Set2(self, index, value)
            }
            #[inline]
            pub unsafe fn Set3(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_Set3(self, context, index, value)
            }
            #[inline]
            pub unsafe fn CreateDataProperty(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_CreateDataProperty(self, context, key, value)
            }
            #[inline]
            pub unsafe fn CreateDataProperty1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_CreateDataProperty1(self, context, index, value)
            }
            #[inline]
            pub unsafe fn DefineOwnProperty(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Value>,
                attributes: root::v8::PropertyAttribute,
            ) -> root::v8::Maybe<bool> {
                Object_DefineOwnProperty(self, context, key, value, attributes)
            }
            #[inline]
            pub unsafe fn DefineProperty(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
                descriptor: *mut root::v8::PropertyDescriptor,
            ) -> root::v8::Maybe<bool> {
                Object_DefineProperty(self, context, key, descriptor)
            }
            #[inline]
            pub unsafe fn Get(
                &mut self,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::Value> {
                Object_Get(self, key)
            }
            #[inline]
            pub unsafe fn Get1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_Get1(self, context, key)
            }
            #[inline]
            pub unsafe fn Get2(&mut self, index: u32) -> root::v8::Local<root::v8::Value> {
                Object_Get2(self, index)
            }
            #[inline]
            pub unsafe fn Get3(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_Get3(self, context, index)
            }
            #[inline]
            pub unsafe fn GetPropertyAttributes(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<root::v8::PropertyAttribute> {
                Object_GetPropertyAttributes(self, context, key)
            }
            #[inline]
            pub unsafe fn GetOwnPropertyDescriptor(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_GetOwnPropertyDescriptor(self, context, key)
            }
            #[inline]
            pub unsafe fn Has(&mut self, key: root::v8::Local<root::v8::Value>) -> bool {
                Object_Has(self, key)
            }
            #[inline]
            pub unsafe fn Has1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_Has1(self, context, key)
            }
            #[inline]
            pub unsafe fn Delete(&mut self, key: root::v8::Local<root::v8::Value>) -> bool {
                Object_Delete(self, key)
            }
            #[inline]
            pub unsafe fn Delete1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_Delete1(self, context, key)
            }
            #[inline]
            pub unsafe fn Has2(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool> {
                Object_Has2(self, context, index)
            }
            #[inline]
            pub unsafe fn Delete2(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool> {
                Object_Delete2(self, context, index)
            }
            #[inline]
            pub unsafe fn SetAccessor(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::MaybeLocal<root::v8::Value>,
                settings: root::v8::AccessControl,
                attribute: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Maybe<bool> {
                Object_SetAccessor(
                    self,
                    context,
                    name,
                    getter,
                    setter,
                    data,
                    settings,
                    attribute,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn SetAccessorProperty(
                &mut self,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::Local<root::v8::Function>,
                setter: root::v8::Local<root::v8::Function>,
                attribute: root::v8::PropertyAttribute,
                settings: root::v8::AccessControl,
            ) {
                Object_SetAccessorProperty(self, name, getter, setter, attribute, settings)
            }
            #[inline]
            pub unsafe fn SetNativeDataProperty(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attributes: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Maybe<bool> {
                Object_SetNativeDataProperty(
                    self,
                    context,
                    name,
                    getter,
                    setter,
                    data,
                    attributes,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn SetLazyDataProperty(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attributes: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Maybe<bool> {
                Object_SetLazyDataProperty(
                    self,
                    context,
                    name,
                    getter,
                    data,
                    attributes,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn HasPrivate(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
            ) -> root::v8::Maybe<bool> {
                Object_HasPrivate(self, context, key)
            }
            #[inline]
            pub unsafe fn SetPrivate(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_SetPrivate(self, context, key, value)
            }
            #[inline]
            pub unsafe fn DeletePrivate(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
            ) -> root::v8::Maybe<bool> {
                Object_DeletePrivate(self, context, key)
            }
            #[inline]
            pub unsafe fn GetPrivate(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Private>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_GetPrivate(self, context, key)
            }
            #[inline]
            pub unsafe fn GetPropertyNames(&mut self) -> root::v8::Local<root::v8::Array> {
                Object_GetPropertyNames(self)
            }
            #[inline]
            pub unsafe fn GetPropertyNames1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Array> {
                Object_GetPropertyNames1(self, context)
            }
            #[inline]
            pub unsafe fn GetPropertyNames2(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                mode: root::v8::KeyCollectionMode,
                property_filter: root::v8::PropertyFilter,
                index_filter: root::v8::IndexFilter,
                key_conversion: root::v8::KeyConversionMode,
            ) -> root::v8::MaybeLocal<root::v8::Array> {
                Object_GetPropertyNames2(
                    self,
                    context,
                    mode,
                    property_filter,
                    index_filter,
                    key_conversion,
                )
            }
            #[inline]
            pub unsafe fn GetOwnPropertyNames(&mut self) -> root::v8::Local<root::v8::Array> {
                Object_GetOwnPropertyNames(self)
            }
            #[inline]
            pub unsafe fn GetOwnPropertyNames1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Array> {
                Object_GetOwnPropertyNames1(self, context)
            }
            #[inline]
            pub unsafe fn GetOwnPropertyNames2(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                filter: root::v8::PropertyFilter,
                key_conversion: root::v8::KeyConversionMode,
            ) -> root::v8::MaybeLocal<root::v8::Array> {
                Object_GetOwnPropertyNames2(self, context, filter, key_conversion)
            }
            #[inline]
            pub unsafe fn GetPrototype(&mut self) -> root::v8::Local<root::v8::Value> {
                Object_GetPrototype(self)
            }
            #[inline]
            pub unsafe fn SetPrototype(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                prototype: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Object_SetPrototype(self, context, prototype)
            }
            #[inline]
            pub unsafe fn FindInstanceInPrototypeChain(
                &mut self,
                tmpl: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::Object> {
                Object_FindInstanceInPrototypeChain(self, tmpl)
            }
            #[inline]
            pub unsafe fn ObjectProtoToString(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::String> {
                Object_ObjectProtoToString(self, context)
            }
            #[inline]
            pub unsafe fn GetConstructorName(&mut self) -> root::v8::Local<root::v8::String> {
                Object_GetConstructorName(self)
            }
            #[inline]
            pub unsafe fn SetIntegrityLevel(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                level: root::v8::IntegrityLevel,
            ) -> root::v8::Maybe<bool> {
                Object_SetIntegrityLevel(self, context, level)
            }
            #[inline]
            pub unsafe fn InternalFieldCount(&mut self) -> ::std::os::raw::c_int {
                Object_InternalFieldCount(self)
            }
            #[inline]
            pub unsafe fn SetInternalField(
                &mut self,
                index: ::std::os::raw::c_int,
                value: root::v8::Local<root::v8::Value>,
            ) {
                Object_SetInternalField(self, index, value)
            }
            #[inline]
            pub unsafe fn SetAlignedPointerInInternalField(
                &mut self,
                index: ::std::os::raw::c_int,
                value: *mut ::std::os::raw::c_void,
            ) {
                Object_SetAlignedPointerInInternalField(self, index, value)
            }
            #[inline]
            pub unsafe fn SetAlignedPointerInInternalFields(
                &mut self,
                argc: ::std::os::raw::c_int,
                indices: *mut ::std::os::raw::c_int,
                values: *mut *mut ::std::os::raw::c_void,
            ) {
                Object_SetAlignedPointerInInternalFields(self, argc, indices, values)
            }
            #[inline]
            pub unsafe fn HasOwnProperty(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<bool> {
                Object_HasOwnProperty(self, context, key)
            }
            #[inline]
            pub unsafe fn HasOwnProperty1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool> {
                Object_HasOwnProperty1(self, context, index)
            }
            #[inline]
            pub unsafe fn HasRealNamedProperty(
                &mut self,
                key: root::v8::Local<root::v8::String>,
            ) -> bool {
                Object_HasRealNamedProperty(self, key)
            }
            #[inline]
            pub unsafe fn HasRealNamedProperty1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<bool> {
                Object_HasRealNamedProperty1(self, context, key)
            }
            #[inline]
            pub unsafe fn HasRealIndexedProperty(&mut self, index: u32) -> bool {
                Object_HasRealIndexedProperty(self, index)
            }
            #[inline]
            pub unsafe fn HasRealIndexedProperty1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                index: u32,
            ) -> root::v8::Maybe<bool> {
                Object_HasRealIndexedProperty1(self, context, index)
            }
            #[inline]
            pub unsafe fn HasRealNamedCallbackProperty(
                &mut self,
                key: root::v8::Local<root::v8::String>,
            ) -> bool {
                Object_HasRealNamedCallbackProperty(self, key)
            }
            #[inline]
            pub unsafe fn HasRealNamedCallbackProperty1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<bool> {
                Object_HasRealNamedCallbackProperty1(self, context, key)
            }
            #[inline]
            pub unsafe fn GetRealNamedPropertyInPrototypeChain(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_GetRealNamedPropertyInPrototypeChain(self, context, key)
            }
            #[inline]
            pub unsafe fn GetRealNamedPropertyAttributesInPrototypeChain(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<root::v8::PropertyAttribute> {
                Object_GetRealNamedPropertyAttributesInPrototypeChain(self, context, key)
            }
            #[inline]
            pub unsafe fn GetRealNamedProperty(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_GetRealNamedProperty(self, context, key)
            }
            #[inline]
            pub unsafe fn GetRealNamedPropertyAttributes(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Name>,
            ) -> root::v8::Maybe<root::v8::PropertyAttribute> {
                Object_GetRealNamedPropertyAttributes(self, context, key)
            }
            #[inline]
            pub unsafe fn HasNamedLookupInterceptor(&mut self) -> bool {
                Object_HasNamedLookupInterceptor(self)
            }
            #[inline]
            pub unsafe fn HasIndexedLookupInterceptor(&mut self) -> bool {
                Object_HasIndexedLookupInterceptor(self)
            }
            #[inline]
            pub unsafe fn GetIdentityHash(&mut self) -> ::std::os::raw::c_int {
                Object_GetIdentityHash(self)
            }
            #[inline]
            pub unsafe fn Clone(&mut self) -> root::v8::Local<root::v8::Object> {
                Object_Clone(self)
            }
            #[inline]
            pub unsafe fn CreationContext(&mut self) -> root::v8::Local<root::v8::Context> {
                Object_CreationContext(self)
            }
            #[inline]
            pub unsafe fn IsCallable(&mut self) -> bool {
                Object_IsCallable(self)
            }
            #[inline]
            pub unsafe fn IsConstructor(&mut self) -> bool {
                Object_IsConstructor(self)
            }
            #[inline]
            pub unsafe fn CallAsFunction(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                recv: root::v8::Local<root::v8::Value>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_CallAsFunction(self, context, recv, argc, argv)
            }
            #[inline]
            pub unsafe fn CallAsConstructor(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Object_CallAsConstructor(self, context, argc, argv)
            }
            #[inline]
            pub unsafe fn GetIsolate(&mut self) -> *mut root::v8::Isolate {
                Object_GetIsolate(self)
            }
            #[inline]
            pub unsafe fn PreviewEntries(
                &mut self,
                is_key_value: *mut bool,
            ) -> root::v8::MaybeLocal<root::v8::Array> {
                Object_PreviewEntries(self, is_key_value)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Object> {
                Object_New(isolate)
            }
        }
        /// An instance of the built-in array constructor (ECMA-262, 15.4.2).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Array() {
            assert_eq!(
                ::std::mem::size_of::<Array>(),
                1usize,
                concat!("Size of: ", stringify!(Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Length@Array@v8@@QEBAIXZ"]
            pub fn Array_Length(this: *const root::v8::Array) -> u32;
        }
        extern "C" {
            /// Creates a JavaScript array with the given length. If the length
            /// is negative the returned array will have length 0.
            #[link_name = "\u{1}?New@Array@v8@@SA?AV?$Local@VArray@v8@@@2@PEAVIsolate@2@H@Z"]
            pub fn Array_New(
                isolate: *mut root::v8::Isolate,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::Array>;
        }
        impl Array {
            #[inline]
            pub unsafe fn Length(&self) -> u32 {
                Array_Length(self)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::Array> {
                Array_New(isolate, length)
            }
        }
        /// An instance of the built-in Map constructor (ECMA-262, 6th Edition, 23.1.1).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Map {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Map() {
            assert_eq!(
                ::std::mem::size_of::<Map>(),
                1usize,
                concat!("Size of: ", stringify!(Map))
            );
            assert_eq!(
                ::std::mem::align_of::<Map>(),
                1usize,
                concat!("Alignment of ", stringify!(Map))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Size@Map@v8@@QEBA_KXZ"]
            pub fn Map_Size(this: *const root::v8::Map) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?Clear@Map@v8@@QEAAXXZ"]
            pub fn Map_Clear(this: *mut root::v8::Map);
        }
        extern "C" {
            #[link_name = "\u{1}?Get@Map@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Map_Get(
                this: *mut root::v8::Map,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Map@v8@@QEAA?AV?$MaybeLocal@VMap@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@1@Z"]
            pub fn Map_Set(
                this: *mut root::v8::Map,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Map>;
        }
        extern "C" {
            #[link_name = "\u{1}?Has@Map@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Map_Has(
                this: *mut root::v8::Map,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Delete@Map@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Map_Delete(
                this: *mut root::v8::Map,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Returns an array of length Size() * 2, where index N is the Nth key and
            /// index N + 1 is the Nth value.
            #[link_name = "\u{1}?AsArray@Map@v8@@QEBA?AV?$Local@VArray@v8@@@2@XZ"]
            pub fn Map_AsArray(this: *const root::v8::Map) -> root::v8::Local<root::v8::Array>;
        }
        extern "C" {
            /// Creates a new empty Map.
            #[link_name = "\u{1}?New@Map@v8@@SA?AV?$Local@VMap@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Map_New(isolate: *mut root::v8::Isolate) -> root::v8::Local<root::v8::Map>;
        }
        impl Map {
            #[inline]
            pub unsafe fn Size(&self) -> usize {
                Map_Size(self)
            }
            #[inline]
            pub unsafe fn Clear(&mut self) {
                Map_Clear(self)
            }
            #[inline]
            pub unsafe fn Get(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Map_Get(self, context, key)
            }
            #[inline]
            pub unsafe fn Set(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Map> {
                Map_Set(self, context, key, value)
            }
            #[inline]
            pub unsafe fn Has(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Map_Has(self, context, key)
            }
            #[inline]
            pub unsafe fn Delete(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Map_Delete(self, context, key)
            }
            #[inline]
            pub unsafe fn AsArray(&self) -> root::v8::Local<root::v8::Array> {
                Map_AsArray(self)
            }
            #[inline]
            pub unsafe fn New(isolate: *mut root::v8::Isolate) -> root::v8::Local<root::v8::Map> {
                Map_New(isolate)
            }
        }
        /// An instance of the built-in Set constructor (ECMA-262, 6th Edition, 23.2.1).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Set {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Set() {
            assert_eq!(
                ::std::mem::size_of::<Set>(),
                1usize,
                concat!("Size of: ", stringify!(Set))
            );
            assert_eq!(
                ::std::mem::align_of::<Set>(),
                1usize,
                concat!("Alignment of ", stringify!(Set))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Size@Set@v8@@QEBA_KXZ"]
            pub fn Set_Size(this: *const root::v8::Set) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?Clear@Set@v8@@QEAAXXZ"]
            pub fn Set_Clear(this: *mut root::v8::Set);
        }
        extern "C" {
            #[link_name = "\u{1}?Add@Set@v8@@QEAA?AV?$MaybeLocal@VSet@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Set_Add(
                this: *mut root::v8::Set,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Set>;
        }
        extern "C" {
            #[link_name = "\u{1}?Has@Set@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Set_Has(
                this: *mut root::v8::Set,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Delete@Set@v8@@QEAA?AV?$Maybe@_N@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Set_Delete(
                this: *mut root::v8::Set,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            /// Returns an array of the keys in this Set.
            #[link_name = "\u{1}?AsArray@Set@v8@@QEBA?AV?$Local@VArray@v8@@@2@XZ"]
            pub fn Set_AsArray(this: *const root::v8::Set) -> root::v8::Local<root::v8::Array>;
        }
        extern "C" {
            /// Creates a new empty Set.
            #[link_name = "\u{1}?New@Set@v8@@SA?AV?$Local@VSet@v8@@@2@PEAVIsolate@2@@Z"]
            pub fn Set_New(isolate: *mut root::v8::Isolate) -> root::v8::Local<root::v8::Set>;
        }
        impl Set {
            #[inline]
            pub unsafe fn Size(&self) -> usize {
                Set_Size(self)
            }
            #[inline]
            pub unsafe fn Clear(&mut self) {
                Set_Clear(self)
            }
            #[inline]
            pub unsafe fn Add(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Set> {
                Set_Add(self, context, key)
            }
            #[inline]
            pub unsafe fn Has(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Set_Has(self, context, key)
            }
            #[inline]
            pub unsafe fn Delete(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                key: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Set_Delete(self, context, key)
            }
            #[inline]
            pub unsafe fn AsArray(&self) -> root::v8::Local<root::v8::Array> {
                Set_AsArray(self)
            }
            #[inline]
            pub unsafe fn New(isolate: *mut root::v8::Isolate) -> root::v8::Local<root::v8::Set> {
                Set_New(isolate)
            }
        }
        /// The argument information given to function call callbacks.  This
        /// class provides access to information about the context of the call,
        /// including the receiver, the number and values of arguments, and
        /// the holder of the function.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct FunctionCallbackInfo {
            pub implicit_args_: *mut *mut root::v8::internal::Object,
            pub values_: *mut *mut root::v8::internal::Object,
            pub length_: ::std::os::raw::c_int,
        }
        /// The information passed to a property callback about the context
        /// of the property access.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PropertyCallbackInfo {
            pub args_: *mut *mut root::v8::internal::Object,
        }
        pub type FunctionCallback = ::std::option::Option<
            unsafe extern "C" fn(info: *const root::v8::FunctionCallbackInfo),
        >;
        pub const ConstructorBehavior_kThrow: root::v8::ConstructorBehavior = 0;
        pub const ConstructorBehavior_kAllow: root::v8::ConstructorBehavior = 1;
        pub type ConstructorBehavior = i32;
        /// A JavaScript function object (ECMA-262, 15.3).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Function {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}?kLineOffsetNotFound@Function@v8@@2HB"]
            pub static mut Function_kLineOffsetNotFound: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_Function() {
            assert_eq!(
                ::std::mem::size_of::<Function>(),
                1usize,
                concat!("Size of: ", stringify!(Function))
            );
            assert_eq!(
                ::std::mem::align_of::<Function>(),
                1usize,
                concat!("Alignment of ", stringify!(Function))
            );
        }
        extern "C" {
            /// Create a function in the current execution context
            /// for a given FunctionCallback.
            #[link_name = "\u{1}?New@Function@v8@@SA?AV?$MaybeLocal@VFunction@v8@@@2@V?$Local@VContext@v8@@@2@P6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@HW4ConstructorBehavior@2@W4SideEffectType@2@@Z"]
            pub fn Function_New(
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                length: ::std::os::raw::c_int,
                behavior: root::v8::ConstructorBehavior,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::MaybeLocal<root::v8::Function>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Function@v8@@SA?AV?$Local@VFunction@v8@@@2@PEAVIsolate@2@P6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@H@Z"]
            pub fn Function_New1(
                isolate: *mut root::v8::Isolate,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::Function>;
        }
        extern "C" {
            #[link_name = "\u{1}?NewInstance@Function@v8@@QEBA?AV?$MaybeLocal@VObject@v8@@@2@V?$Local@VContext@v8@@@2@HQEAV?$Local@VValue@v8@@@2@@Z"]
            pub fn Function_NewInstance(
                this: *const root::v8::Function,
                context: root::v8::Local<root::v8::Context>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Object>;
        }
        extern "C" {
            /// When side effect checks are enabled, passing kHasNoSideEffect allows the
            /// constructor to be invoked without throwing. Calls made within the
            /// constructor are still checked.
            #[link_name = "\u{1}?NewInstanceWithSideEffectType@Function@v8@@QEBA?AV?$MaybeLocal@VObject@v8@@@2@V?$Local@VContext@v8@@@2@HQEAV?$Local@VValue@v8@@@2@W4SideEffectType@2@@Z"]
            pub fn Function_NewInstanceWithSideEffectType(
                this: *const root::v8::Function,
                context: root::v8::Local<root::v8::Context>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::MaybeLocal<root::v8::Object>;
        }
        extern "C" {
            #[link_name = "\u{1}?Call@Function@v8@@QEAA?AV?$Local@VValue@v8@@@2@V32@HQEAV32@@Z"]
            pub fn Function_Call(
                this: *mut root::v8::Function,
                recv: root::v8::Local<root::v8::Value>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Call@Function@v8@@QEAA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VValue@v8@@@2@HQEAV52@@Z"]
            pub fn Function_Call1(
                this: *mut root::v8::Function,
                context: root::v8::Local<root::v8::Context>,
                recv: root::v8::Local<root::v8::Value>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?SetName@Function@v8@@QEAAXV?$Local@VString@v8@@@2@@Z"]
            pub fn Function_SetName(
                this: *mut root::v8::Function,
                name: root::v8::Local<root::v8::String>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GetName@Function@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Function_GetName(
                this: *const root::v8::Function,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Name inferred from variable or property assignment of this function.
            /// Used to facilitate debugging and profiling of JavaScript code written
            /// in an OO style, where many functions are anonymous but are assigned
            /// to object properties.
            #[link_name = "\u{1}?GetInferredName@Function@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Function_GetInferredName(
                this: *const root::v8::Function,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// displayName if it is set, otherwise name if it is configured, otherwise
            /// function name, otherwise inferred name.
            #[link_name = "\u{1}?GetDebugName@Function@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Function_GetDebugName(
                this: *const root::v8::Function,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// User-defined name assigned to the "displayName" property of this function.
            /// Used to facilitate debugging and profiling of JavaScript code.
            #[link_name = "\u{1}?GetDisplayName@Function@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Function_GetDisplayName(
                this: *const root::v8::Function,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Returns zero based line number of function body and
            /// kLineOffsetNotFound if no information available.
            #[link_name = "\u{1}?GetScriptLineNumber@Function@v8@@QEBAHXZ"]
            pub fn Function_GetScriptLineNumber(
                this: *const root::v8::Function,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns zero based column number of function body and
            /// kLineOffsetNotFound if no information available.
            #[link_name = "\u{1}?GetScriptColumnNumber@Function@v8@@QEBAHXZ"]
            pub fn Function_GetScriptColumnNumber(
                this: *const root::v8::Function,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns scriptId.
            #[link_name = "\u{1}?ScriptId@Function@v8@@QEBAHXZ"]
            pub fn Function_ScriptId(this: *const root::v8::Function) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns the original function if this function is bound, else returns
            /// v8::Undefined.
            #[link_name = "\u{1}?GetBoundFunction@Function@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Function_GetBoundFunction(
                this: *const root::v8::Function,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetScriptOrigin@Function@v8@@QEBA?AVScriptOrigin@2@XZ"]
            pub fn Function_GetScriptOrigin(
                this: *const root::v8::Function,
            ) -> root::v8::ScriptOrigin;
        }
        impl Function {
            #[inline]
            pub unsafe fn New(
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                length: ::std::os::raw::c_int,
                behavior: root::v8::ConstructorBehavior,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::MaybeLocal<root::v8::Function> {
                Function_New(context, callback, data, length, behavior, side_effect_type)
            }
            #[inline]
            pub unsafe fn New1(
                isolate: *mut root::v8::Isolate,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                length: ::std::os::raw::c_int,
            ) -> root::v8::Local<root::v8::Function> {
                Function_New1(isolate, callback, data, length)
            }
            #[inline]
            pub unsafe fn NewInstance(
                &self,
                context: root::v8::Local<root::v8::Context>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Object> {
                Function_NewInstance(self, context, argc, argv)
            }
            #[inline]
            pub unsafe fn NewInstanceWithSideEffectType(
                &self,
                context: root::v8::Local<root::v8::Context>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::MaybeLocal<root::v8::Object> {
                Function_NewInstanceWithSideEffectType(self, context, argc, argv, side_effect_type)
            }
            #[inline]
            pub unsafe fn Call(
                &mut self,
                recv: root::v8::Local<root::v8::Value>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::Value> {
                Function_Call(self, recv, argc, argv)
            }
            #[inline]
            pub unsafe fn Call1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                recv: root::v8::Local<root::v8::Value>,
                argc: ::std::os::raw::c_int,
                argv: *mut root::v8::Local<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Function_Call1(self, context, recv, argc, argv)
            }
            #[inline]
            pub unsafe fn SetName(&mut self, name: root::v8::Local<root::v8::String>) {
                Function_SetName(self, name)
            }
            #[inline]
            pub unsafe fn GetName(&self) -> root::v8::Local<root::v8::Value> {
                Function_GetName(self)
            }
            #[inline]
            pub unsafe fn GetInferredName(&self) -> root::v8::Local<root::v8::Value> {
                Function_GetInferredName(self)
            }
            #[inline]
            pub unsafe fn GetDebugName(&self) -> root::v8::Local<root::v8::Value> {
                Function_GetDebugName(self)
            }
            #[inline]
            pub unsafe fn GetDisplayName(&self) -> root::v8::Local<root::v8::Value> {
                Function_GetDisplayName(self)
            }
            #[inline]
            pub unsafe fn GetScriptLineNumber(&self) -> ::std::os::raw::c_int {
                Function_GetScriptLineNumber(self)
            }
            #[inline]
            pub unsafe fn GetScriptColumnNumber(&self) -> ::std::os::raw::c_int {
                Function_GetScriptColumnNumber(self)
            }
            #[inline]
            pub unsafe fn ScriptId(&self) -> ::std::os::raw::c_int {
                Function_ScriptId(self)
            }
            #[inline]
            pub unsafe fn GetBoundFunction(&self) -> root::v8::Local<root::v8::Value> {
                Function_GetBoundFunction(self)
            }
            #[inline]
            pub unsafe fn GetScriptOrigin(&self) -> root::v8::ScriptOrigin {
                Function_GetScriptOrigin(self)
            }
        }
        /// An instance of the built-in Promise constructor (ES6 draft).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Promise {
            pub _address: u8,
        }
        pub const Promise_PromiseState_kPending: root::v8::Promise_PromiseState = 0;
        pub const Promise_PromiseState_kFulfilled: root::v8::Promise_PromiseState = 1;
        pub const Promise_PromiseState_kRejected: root::v8::Promise_PromiseState = 2;
        /// State of the promise. Each value corresponds to one of the possible values
        /// of the [[PromiseState]] field.
        pub type Promise_PromiseState = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Promise_Resolver {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Promise_Resolver() {
            assert_eq!(
                ::std::mem::size_of::<Promise_Resolver>(),
                1usize,
                concat!("Size of: ", stringify!(Promise_Resolver))
            );
            assert_eq!(
                ::std::mem::align_of::<Promise_Resolver>(),
                1usize,
                concat!("Alignment of ", stringify!(Promise_Resolver))
            );
        }
        extern "C" {
            /// Create a new resolver, along with an associated promise in pending state.
            #[link_name = "\u{1}?New@Resolver@Promise@v8@@SA?AV?$MaybeLocal@VResolver@Promise@v8@@@3@V?$Local@VContext@v8@@@3@@Z"]
            pub fn Promise_Resolver_New(
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Promise_Resolver>;
        }
        extern "C" {
            /// Extract the associated promise.
            #[link_name = "\u{1}?GetPromise@Resolver@Promise@v8@@QEAA?AV?$Local@VPromise@v8@@@3@XZ"]
            pub fn Promise_Resolver_GetPromise(
                this: *mut root::v8::Promise_Resolver,
            ) -> root::v8::Local<root::v8::Promise>;
        }
        extern "C" {
            /// Resolve/reject the associated promise with a given value.
            /// Ignored if the promise is no longer pending.
            #[link_name = "\u{1}?Resolve@Resolver@Promise@v8@@QEAA?AV?$Maybe@_N@3@V?$Local@VContext@v8@@@3@V?$Local@VValue@v8@@@3@@Z"]
            pub fn Promise_Resolver_Resolve(
                this: *mut root::v8::Promise_Resolver,
                context: root::v8::Local<root::v8::Context>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        extern "C" {
            #[link_name = "\u{1}?Reject@Resolver@Promise@v8@@QEAA?AV?$Maybe@_N@3@V?$Local@VContext@v8@@@3@V?$Local@VValue@v8@@@3@@Z"]
            pub fn Promise_Resolver_Reject(
                this: *mut root::v8::Promise_Resolver,
                context: root::v8::Local<root::v8::Context>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool>;
        }
        impl Promise_Resolver {
            #[inline]
            pub unsafe fn New(
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Promise_Resolver> {
                Promise_Resolver_New(context)
            }
            #[inline]
            pub unsafe fn GetPromise(&mut self) -> root::v8::Local<root::v8::Promise> {
                Promise_Resolver_GetPromise(self)
            }
            #[inline]
            pub unsafe fn Resolve(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Promise_Resolver_Resolve(self, context, value)
            }
            #[inline]
            pub unsafe fn Reject(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                value: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Maybe<bool> {
                Promise_Resolver_Reject(self, context, value)
            }
        }
        pub const Promise_kEmbedderFieldCount: ::std::os::raw::c_int = 0;
        #[test]
        fn bindgen_test_layout_Promise() {
            assert_eq!(
                ::std::mem::size_of::<Promise>(),
                1usize,
                concat!("Size of: ", stringify!(Promise))
            );
            assert_eq!(
                ::std::mem::align_of::<Promise>(),
                1usize,
                concat!("Alignment of ", stringify!(Promise))
            );
        }
        extern "C" {
            /// Register a resolution/rejection handler with a promise.
            /// The handler is given the respective resolution/rejection value as
            /// an argument. If the promise is already resolved/rejected, the handler is
            /// invoked at the end of turn.
            #[link_name = "\u{1}?Catch@Promise@v8@@QEAA?AV?$MaybeLocal@VPromise@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VFunction@v8@@@2@@Z"]
            pub fn Promise_Catch(
                this: *mut root::v8::Promise,
                context: root::v8::Local<root::v8::Context>,
                handler: root::v8::Local<root::v8::Function>,
            ) -> root::v8::MaybeLocal<root::v8::Promise>;
        }
        extern "C" {
            #[link_name = "\u{1}?Then@Promise@v8@@QEAA?AV?$MaybeLocal@VPromise@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VFunction@v8@@@2@@Z"]
            pub fn Promise_Then(
                this: *mut root::v8::Promise,
                context: root::v8::Local<root::v8::Context>,
                handler: root::v8::Local<root::v8::Function>,
            ) -> root::v8::MaybeLocal<root::v8::Promise>;
        }
        extern "C" {
            /// Returns true if the promise has at least one derived promise, and
            /// therefore resolve/reject handlers (including default handler).
            #[link_name = "\u{1}?HasHandler@Promise@v8@@QEAA_NXZ"]
            pub fn Promise_HasHandler(this: *mut root::v8::Promise) -> bool;
        }
        extern "C" {
            /// Returns the content of the [[PromiseResult]] field. The Promise must not
            /// be pending.
            #[link_name = "\u{1}?Result@Promise@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Promise_Result(this: *mut root::v8::Promise)
                -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Returns the value of the [[PromiseState]] field.
            #[link_name = "\u{1}?State@Promise@v8@@QEAA?AW4PromiseState@12@XZ"]
            pub fn Promise_State(this: *mut root::v8::Promise) -> root::v8::Promise_PromiseState;
        }
        impl Promise {
            #[inline]
            pub unsafe fn Catch(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                handler: root::v8::Local<root::v8::Function>,
            ) -> root::v8::MaybeLocal<root::v8::Promise> {
                Promise_Catch(self, context, handler)
            }
            #[inline]
            pub unsafe fn Then(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                handler: root::v8::Local<root::v8::Function>,
            ) -> root::v8::MaybeLocal<root::v8::Promise> {
                Promise_Then(self, context, handler)
            }
            #[inline]
            pub unsafe fn HasHandler(&mut self) -> bool {
                Promise_HasHandler(self)
            }
            #[inline]
            pub unsafe fn Result(&mut self) -> root::v8::Local<root::v8::Value> {
                Promise_Result(self)
            }
            #[inline]
            pub unsafe fn State(&mut self) -> root::v8::Promise_PromiseState {
                Promise_State(self)
            }
        }
        /// An instance of a Property Descriptor, see Ecma-262 6.2.4.
        ///
        /// Properties in a descriptor are present or absent. If you do not set
        /// `enumerable`, `configurable`, and `writable`, they are absent. If `value`,
        /// `get`, or `set` are absent, but you must specify them in the constructor, use
        /// empty handles.
        ///
        /// Accessors `get` and `set` must be callable or undefined if they are present.
        ///
        /// \note Only query properties if they are present, i.e., call `x()` only if
        /// `has_x()` returns true.
        ///
        /// \code
        /// // var desc = {writable: false}
        /// v8::PropertyDescriptor d(Local<Value>()), false);
        /// d.value(); // error, value not set
        /// if (d.has_writable()) {
        /// d.writable(); // false
        /// }
        ///
        /// // var desc = {value: undefined}
        /// v8::PropertyDescriptor d(v8::Undefined(isolate));
        ///
        /// // var desc = {get: undefined}
        /// v8::PropertyDescriptor d(v8::Undefined(isolate), Local<Value>()));
        /// \endcode
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct PropertyDescriptor {
            pub private_: *mut root::v8::PropertyDescriptor_PrivateData,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyDescriptor_PrivateData {
            _unused: [u8; 0],
        }
        #[test]
        fn bindgen_test_layout_PropertyDescriptor() {
            assert_eq!(
                ::std::mem::size_of::<PropertyDescriptor>(),
                8usize,
                concat!("Size of: ", stringify!(PropertyDescriptor))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyDescriptor>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyDescriptor))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PropertyDescriptor>())).private_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(private_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}?value@PropertyDescriptor@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn PropertyDescriptor_value(
                this: *const root::v8::PropertyDescriptor,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?has_value@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_has_value(this: *const root::v8::PropertyDescriptor) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?get@PropertyDescriptor@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn PropertyDescriptor_get(
                this: *const root::v8::PropertyDescriptor,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?has_get@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_has_get(this: *const root::v8::PropertyDescriptor) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?set@PropertyDescriptor@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn PropertyDescriptor_set(
                this: *const root::v8::PropertyDescriptor,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?has_set@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_has_set(this: *const root::v8::PropertyDescriptor) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?set_enumerable@PropertyDescriptor@v8@@QEAAX_N@Z"]
            pub fn PropertyDescriptor_set_enumerable(
                this: *mut root::v8::PropertyDescriptor,
                enumerable: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?enumerable@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_enumerable(this: *const root::v8::PropertyDescriptor)
                -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?has_enumerable@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_has_enumerable(
                this: *const root::v8::PropertyDescriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?set_configurable@PropertyDescriptor@v8@@QEAAX_N@Z"]
            pub fn PropertyDescriptor_set_configurable(
                this: *mut root::v8::PropertyDescriptor,
                configurable: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?configurable@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_configurable(
                this: *const root::v8::PropertyDescriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?has_configurable@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_has_configurable(
                this: *const root::v8::PropertyDescriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?writable@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_writable(this: *const root::v8::PropertyDescriptor) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?has_writable@PropertyDescriptor@v8@@QEBA_NXZ"]
            pub fn PropertyDescriptor_has_writable(
                this: *const root::v8::PropertyDescriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0PropertyDescriptor@v8@@QEAA@XZ"]
            pub fn PropertyDescriptor_PropertyDescriptor(this: *mut root::v8::PropertyDescriptor);
        }
        extern "C" {
            #[link_name = "\u{1}??0PropertyDescriptor@v8@@QEAA@V?$Local@VValue@v8@@@1@@Z"]
            pub fn PropertyDescriptor_PropertyDescriptor1(
                this: *mut root::v8::PropertyDescriptor,
                value: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0PropertyDescriptor@v8@@QEAA@V?$Local@VValue@v8@@@1@_N@Z"]
            pub fn PropertyDescriptor_PropertyDescriptor2(
                this: *mut root::v8::PropertyDescriptor,
                value: root::v8::Local<root::v8::Value>,
                writable: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0PropertyDescriptor@v8@@QEAA@V?$Local@VValue@v8@@@1@0@Z"]
            pub fn PropertyDescriptor_PropertyDescriptor3(
                this: *mut root::v8::PropertyDescriptor,
                get: root::v8::Local<root::v8::Value>,
                set: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DPropertyDescriptor@v8@@QEAAXXZ"]
            pub fn PropertyDescriptor_PropertyDescriptor_destructor(
                this: *mut root::v8::PropertyDescriptor,
            );
        }
        impl PropertyDescriptor {
            #[inline]
            pub unsafe fn value(&self) -> root::v8::Local<root::v8::Value> {
                PropertyDescriptor_value(self)
            }
            #[inline]
            pub unsafe fn has_value(&self) -> bool {
                PropertyDescriptor_has_value(self)
            }
            #[inline]
            pub unsafe fn get(&self) -> root::v8::Local<root::v8::Value> {
                PropertyDescriptor_get(self)
            }
            #[inline]
            pub unsafe fn has_get(&self) -> bool {
                PropertyDescriptor_has_get(self)
            }
            #[inline]
            pub unsafe fn set(&self) -> root::v8::Local<root::v8::Value> {
                PropertyDescriptor_set(self)
            }
            #[inline]
            pub unsafe fn has_set(&self) -> bool {
                PropertyDescriptor_has_set(self)
            }
            #[inline]
            pub unsafe fn set_enumerable(&mut self, enumerable: bool) {
                PropertyDescriptor_set_enumerable(self, enumerable)
            }
            #[inline]
            pub unsafe fn enumerable(&self) -> bool {
                PropertyDescriptor_enumerable(self)
            }
            #[inline]
            pub unsafe fn has_enumerable(&self) -> bool {
                PropertyDescriptor_has_enumerable(self)
            }
            #[inline]
            pub unsafe fn set_configurable(&mut self, configurable: bool) {
                PropertyDescriptor_set_configurable(self, configurable)
            }
            #[inline]
            pub unsafe fn configurable(&self) -> bool {
                PropertyDescriptor_configurable(self)
            }
            #[inline]
            pub unsafe fn has_configurable(&self) -> bool {
                PropertyDescriptor_has_configurable(self)
            }
            #[inline]
            pub unsafe fn writable(&self) -> bool {
                PropertyDescriptor_writable(self)
            }
            #[inline]
            pub unsafe fn has_writable(&self) -> bool {
                PropertyDescriptor_has_writable(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PropertyDescriptor_PropertyDescriptor(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(value: root::v8::Local<root::v8::Value>) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PropertyDescriptor_PropertyDescriptor1(&mut __bindgen_tmp, value);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(value: root::v8::Local<root::v8::Value>, writable: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PropertyDescriptor_PropertyDescriptor2(&mut __bindgen_tmp, value, writable);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(
                get: root::v8::Local<root::v8::Value>,
                set: root::v8::Local<root::v8::Value>,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PropertyDescriptor_PropertyDescriptor3(&mut __bindgen_tmp, get, set);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                PropertyDescriptor_PropertyDescriptor_destructor(self)
            }
        }
        /// An instance of the built-in Proxy constructor (ECMA-262, 6th Edition,
        /// 26.2.1).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Proxy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Proxy() {
            assert_eq!(
                ::std::mem::size_of::<Proxy>(),
                1usize,
                concat!("Size of: ", stringify!(Proxy))
            );
            assert_eq!(
                ::std::mem::align_of::<Proxy>(),
                1usize,
                concat!("Alignment of ", stringify!(Proxy))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GetTarget@Proxy@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Proxy_GetTarget(this: *mut root::v8::Proxy) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetHandler@Proxy@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Proxy_GetHandler(this: *mut root::v8::Proxy)
                -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?IsRevoked@Proxy@v8@@QEAA_NXZ"]
            pub fn Proxy_IsRevoked(this: *mut root::v8::Proxy) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Revoke@Proxy@v8@@QEAAXXZ"]
            pub fn Proxy_Revoke(this: *mut root::v8::Proxy);
        }
        extern "C" {
            /// Creates a new Proxy for the target object.
            #[link_name = "\u{1}?New@Proxy@v8@@SA?AV?$MaybeLocal@VProxy@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VObject@v8@@@2@1@Z"]
            pub fn Proxy_New(
                context: root::v8::Local<root::v8::Context>,
                local_target: root::v8::Local<root::v8::Object>,
                local_handler: root::v8::Local<root::v8::Object>,
            ) -> root::v8::MaybeLocal<root::v8::Proxy>;
        }
        impl Proxy {
            #[inline]
            pub unsafe fn GetTarget(&mut self) -> root::v8::Local<root::v8::Value> {
                Proxy_GetTarget(self)
            }
            #[inline]
            pub unsafe fn GetHandler(&mut self) -> root::v8::Local<root::v8::Value> {
                Proxy_GetHandler(self)
            }
            #[inline]
            pub unsafe fn IsRevoked(&mut self) -> bool {
                Proxy_IsRevoked(self)
            }
            #[inline]
            pub unsafe fn Revoke(&mut self) {
                Proxy_Revoke(self)
            }
            #[inline]
            pub unsafe fn New(
                context: root::v8::Local<root::v8::Context>,
                local_target: root::v8::Local<root::v8::Object>,
                local_handler: root::v8::Local<root::v8::Object>,
            ) -> root::v8::MaybeLocal<root::v8::Proxy> {
                Proxy_New(context, local_target, local_handler)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct WasmCompiledModule {
            pub _address: u8,
        }
        pub type WasmCompiledModule_SerializedModule = [u64; 2usize];
        pub type WasmCompiledModule_CallerOwnedBuffer = [u64; 2usize];
        /// A unowned reference to a byte buffer.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct WasmCompiledModule_BufferReference {
            pub start: *const u8,
            pub size: usize,
        }
        #[test]
        fn bindgen_test_layout_WasmCompiledModule_BufferReference() {
            assert_eq!(
                ::std::mem::size_of::<WasmCompiledModule_BufferReference>(),
                16usize,
                concat!("Size of: ", stringify!(WasmCompiledModule_BufferReference))
            );
            assert_eq!(
                ::std::mem::align_of::<WasmCompiledModule_BufferReference>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(WasmCompiledModule_BufferReference)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmCompiledModule_BufferReference>())).start as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmCompiledModule_BufferReference),
                    "::",
                    stringify!(start)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmCompiledModule_BufferReference>())).size as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmCompiledModule_BufferReference),
                    "::",
                    stringify!(size)
                )
            );
        }
        /// An opaque, native heap object for transferring wasm modules. It
        /// supports move semantics, and does not support copy semantics.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct WasmCompiledModule_TransferrableModule {
            pub shared_module_: root::v8::WasmCompiledModule_TransferrableModule_SharedModule,
            pub serialized_: root::v8::WasmCompiledModule_TransferrableModule_OwnedBuffer,
            pub wire_bytes_: root::v8::WasmCompiledModule_TransferrableModule_OwnedBuffer,
        }
        pub type WasmCompiledModule_TransferrableModule_SharedModule = [u64; 2usize];
        pub type WasmCompiledModule_TransferrableModule_OwnedBuffer = [u64; 2usize];
        #[test]
        fn bindgen_test_layout_WasmCompiledModule_TransferrableModule() {
            assert_eq!(
                ::std::mem::size_of::<WasmCompiledModule_TransferrableModule>(),
                48usize,
                concat!(
                    "Size of: ",
                    stringify!(WasmCompiledModule_TransferrableModule)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<WasmCompiledModule_TransferrableModule>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(WasmCompiledModule_TransferrableModule)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmCompiledModule_TransferrableModule>()))
                        .shared_module_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmCompiledModule_TransferrableModule),
                    "::",
                    stringify!(shared_module_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmCompiledModule_TransferrableModule>())).serialized_
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmCompiledModule_TransferrableModule),
                    "::",
                    stringify!(serialized_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmCompiledModule_TransferrableModule>())).wire_bytes_
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmCompiledModule_TransferrableModule),
                    "::",
                    stringify!(wire_bytes_)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_WasmCompiledModule() {
            assert_eq!(
                ::std::mem::size_of::<WasmCompiledModule>(),
                1usize,
                concat!("Size of: ", stringify!(WasmCompiledModule))
            );
            assert_eq!(
                ::std::mem::align_of::<WasmCompiledModule>(),
                1usize,
                concat!("Alignment of ", stringify!(WasmCompiledModule))
            );
        }
        extern "C" {
            /// Get an in-memory, non-persistable, and context-independent (meaning,
            /// suitable for transfer to another Isolate and Context) representation
            /// of this wasm compiled module.
            #[link_name = "\u{1}?GetTransferrableModule@WasmCompiledModule@v8@@QEAA?AVTransferrableModule@12@XZ"]
            pub fn WasmCompiledModule_GetTransferrableModule(
                this: *mut root::v8::WasmCompiledModule,
            ) -> root::v8::WasmCompiledModule_TransferrableModule;
        }
        extern "C" {
            /// Efficiently re-create a WasmCompiledModule, without recompiling, from
            /// a TransferrableModule.
            #[link_name = "\u{1}?FromTransferrableModule@WasmCompiledModule@v8@@SA?AV?$MaybeLocal@VWasmCompiledModule@v8@@@2@PEAVIsolate@2@AEBVTransferrableModule@12@@Z"]
            pub fn WasmCompiledModule_FromTransferrableModule(
                isolate: *mut root::v8::Isolate,
                arg1: *const root::v8::WasmCompiledModule_TransferrableModule,
            ) -> root::v8::MaybeLocal<root::v8::WasmCompiledModule>;
        }
        extern "C" {
            /// Get the wasm-encoded bytes that were used to compile this module.
            #[link_name = "\u{1}?GetWasmWireBytesRef@WasmCompiledModule@v8@@QEAA?AUBufferReference@12@XZ"]
            pub fn WasmCompiledModule_GetWasmWireBytesRef(
                this: *mut root::v8::WasmCompiledModule,
            ) -> root::v8::WasmCompiledModule_BufferReference;
        }
        extern "C" {
            #[link_name = "\u{1}?GetWasmWireBytes@WasmCompiledModule@v8@@QEAA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn WasmCompiledModule_GetWasmWireBytes(
                this: *mut root::v8::WasmCompiledModule,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Serialize the compiled module. The serialized data does not include the
            /// uncompiled bytes.
            #[link_name = "\u{1}?Serialize@WasmCompiledModule@v8@@QEAA?AU?$pair@V?$unique_ptr@$$BY0A@$$CBEU?$default_delete@$$BY0A@$$CBE@std@@@std@@_K@std@@XZ"]
            pub fn WasmCompiledModule_Serialize(
                this: *mut root::v8::WasmCompiledModule,
            ) -> root::v8::WasmCompiledModule_SerializedModule;
        }
        extern "C" {
            /// If possible, deserialize the module, otherwise compile it from the provided
            /// uncompiled bytes.
            #[link_name = "\u{1}?DeserializeOrCompile@WasmCompiledModule@v8@@SA?AV?$MaybeLocal@VWasmCompiledModule@v8@@@2@PEAVIsolate@2@UBufferReference@12@1@Z"]
            pub fn WasmCompiledModule_DeserializeOrCompile(
                isolate: *mut root::v8::Isolate,
                serialized_module: root::v8::WasmCompiledModule_BufferReference,
                wire_bytes: root::v8::WasmCompiledModule_BufferReference,
            ) -> root::v8::MaybeLocal<root::v8::WasmCompiledModule>;
        }
        impl WasmCompiledModule {
            #[inline]
            pub unsafe fn GetTransferrableModule(
                &mut self,
            ) -> root::v8::WasmCompiledModule_TransferrableModule {
                WasmCompiledModule_GetTransferrableModule(self)
            }
            #[inline]
            pub unsafe fn FromTransferrableModule(
                isolate: *mut root::v8::Isolate,
                arg1: *const root::v8::WasmCompiledModule_TransferrableModule,
            ) -> root::v8::MaybeLocal<root::v8::WasmCompiledModule> {
                WasmCompiledModule_FromTransferrableModule(isolate, arg1)
            }
            #[inline]
            pub unsafe fn GetWasmWireBytesRef(
                &mut self,
            ) -> root::v8::WasmCompiledModule_BufferReference {
                WasmCompiledModule_GetWasmWireBytesRef(self)
            }
            #[inline]
            pub unsafe fn GetWasmWireBytes(&mut self) -> root::v8::Local<root::v8::String> {
                WasmCompiledModule_GetWasmWireBytes(self)
            }
            #[inline]
            pub unsafe fn Serialize(&mut self) -> root::v8::WasmCompiledModule_SerializedModule {
                WasmCompiledModule_Serialize(self)
            }
            #[inline]
            pub unsafe fn DeserializeOrCompile(
                isolate: *mut root::v8::Isolate,
                serialized_module: root::v8::WasmCompiledModule_BufferReference,
                wire_bytes: root::v8::WasmCompiledModule_BufferReference,
            ) -> root::v8::MaybeLocal<root::v8::WasmCompiledModule> {
                WasmCompiledModule_DeserializeOrCompile(isolate, serialized_module, wire_bytes)
            }
        }
        /// The V8 interface for WebAssembly streaming compilation. When streaming
        /// compilation is initiated, V8 passes a {WasmStreaming} object to the embedder
        /// such that the embedder can pass the input butes for streaming compilation to
        /// V8.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct WasmStreaming {
            pub impl_: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WasmStreaming_WasmStreamingImpl {
            _unused: [u8; 0],
        }
        #[test]
        fn bindgen_test_layout_WasmStreaming() {
            assert_eq!(
                ::std::mem::size_of::<WasmStreaming>(),
                8usize,
                concat!("Size of: ", stringify!(WasmStreaming))
            );
            assert_eq!(
                ::std::mem::align_of::<WasmStreaming>(),
                8usize,
                concat!("Alignment of ", stringify!(WasmStreaming))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<WasmStreaming>())).impl_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmStreaming),
                    "::",
                    stringify!(impl_)
                )
            );
        }
        extern "C" {
            /// Pass a new chunck of bytes to WebAssembly streaming compilation.
            /// The buffer passed into {OnBytesReceived} is owned by the caller.
            #[link_name = "\u{1}?OnBytesReceived@WasmStreaming@v8@@QEAAXPEBE_K@Z"]
            pub fn WasmStreaming_OnBytesReceived(
                this: *mut root::v8::WasmStreaming,
                bytes: *const u8,
                size: usize,
            );
        }
        extern "C" {
            /// {Finish} should be called after all received bytes where passed to
            /// {OnBytesReceived} to tell V8 that there will be no more bytes. {Finish}
            /// does not have to be called after {Abort} has been called already.
            #[link_name = "\u{1}?Finish@WasmStreaming@v8@@QEAAXXZ"]
            pub fn WasmStreaming_Finish(this: *mut root::v8::WasmStreaming);
        }
        extern "C" {
            /// Abort streaming compilation. If {exception} has a value, then the promise
            /// associated with streaming compilation is rejected with that value. If
            /// {exception} does not have value, the promise does not get rejected.
            #[link_name = "\u{1}?Abort@WasmStreaming@v8@@QEAAXV?$MaybeLocal@VValue@v8@@@2@@Z"]
            pub fn WasmStreaming_Abort(
                this: *mut root::v8::WasmStreaming,
                exception: root::v8::MaybeLocal<root::v8::Value>,
            );
        }
        extern "C" {
            /// Unpacks a {WasmStreaming} object wrapped in a  {Managed} for the embedder.
            /// Since the embedder is on the other side of the API, it cannot unpack the
            /// {Managed} itself.
            #[link_name = "\u{1}?Unpack@WasmStreaming@v8@@SA?AV?$shared_ptr@VWasmStreaming@v8@@@std@@PEAVIsolate@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn WasmStreaming_Unpack(
                isolate: *mut root::v8::Isolate,
                value: root::v8::Local<root::v8::Value>,
            ) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}??0WasmStreaming@v8@@QEAA@V?$unique_ptr@VWasmStreamingImpl@WasmStreaming@v8@@U?$default_delete@VWasmStreamingImpl@WasmStreaming@v8@@@std@@@std@@@Z"]
            pub fn WasmStreaming_WasmStreaming(this: *mut root::v8::WasmStreaming, impl_: u64);
        }
        extern "C" {
            #[link_name = "\u{1}??_DWasmStreaming@v8@@QEAAXXZ"]
            pub fn WasmStreaming_WasmStreaming_destructor(this: *mut root::v8::WasmStreaming);
        }
        impl WasmStreaming {
            #[inline]
            pub unsafe fn OnBytesReceived(&mut self, bytes: *const u8, size: usize) {
                WasmStreaming_OnBytesReceived(self, bytes, size)
            }
            #[inline]
            pub unsafe fn Finish(&mut self) {
                WasmStreaming_Finish(self)
            }
            #[inline]
            pub unsafe fn Abort(&mut self, exception: root::v8::MaybeLocal<root::v8::Value>) {
                WasmStreaming_Abort(self, exception)
            }
            #[inline]
            pub unsafe fn Unpack(
                isolate: *mut root::v8::Isolate,
                value: root::v8::Local<root::v8::Value>,
            ) -> u8 {
                WasmStreaming_Unpack(isolate, value)
            }
            #[inline]
            pub unsafe fn new(impl_: u64) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                WasmStreaming_WasmStreaming(&mut __bindgen_tmp, impl_);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                WasmStreaming_WasmStreaming_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct WasmModuleObjectBuilderStreaming {
            pub isolate_: *mut root::v8::Isolate,
            /// We don't need the static Copy API, so the default
            /// NonCopyablePersistentTraits would be sufficient, however,
            /// MSVC eagerly instantiates the Copy.
            /// We ensure we don't use Copy, however, by compiling with the
            /// defaults everywhere else.
            pub promise_: root::v8::Persistent<root::v8::Promise>,
            pub streaming_decoder_: [u64; 2usize],
        }
        #[test]
        fn bindgen_test_layout_WasmModuleObjectBuilderStreaming() {
            assert_eq!(
                ::std::mem::size_of::<WasmModuleObjectBuilderStreaming>(),
                32usize,
                concat!("Size of: ", stringify!(WasmModuleObjectBuilderStreaming))
            );
            assert_eq!(
                ::std::mem::align_of::<WasmModuleObjectBuilderStreaming>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(WasmModuleObjectBuilderStreaming)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmModuleObjectBuilderStreaming>())).isolate_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmModuleObjectBuilderStreaming),
                    "::",
                    stringify!(isolate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmModuleObjectBuilderStreaming>())).promise_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmModuleObjectBuilderStreaming),
                    "::",
                    stringify!(promise_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<WasmModuleObjectBuilderStreaming>())).streaming_decoder_
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WasmModuleObjectBuilderStreaming),
                    "::",
                    stringify!(streaming_decoder_)
                )
            );
        }
        extern "C" {
            /// The buffer passed into OnBytesReceived is owned by the caller.
            #[link_name = "\u{1}?OnBytesReceived@WasmModuleObjectBuilderStreaming@v8@@QEAAXPEBE_K@Z"]
            pub fn WasmModuleObjectBuilderStreaming_OnBytesReceived(
                this: *mut root::v8::WasmModuleObjectBuilderStreaming,
                arg1: *const u8,
                size: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Finish@WasmModuleObjectBuilderStreaming@v8@@QEAAXXZ"]
            pub fn WasmModuleObjectBuilderStreaming_Finish(
                this: *mut root::v8::WasmModuleObjectBuilderStreaming,
            );
        }
        extern "C" {
            /// Abort streaming compilation. If {exception} has a value, then the promise
            /// associated with streaming compilation is rejected with that value. If
            /// {exception} does not have value, the promise does not get rejected.
            #[link_name = "\u{1}?Abort@WasmModuleObjectBuilderStreaming@v8@@QEAAXV?$MaybeLocal@VValue@v8@@@2@@Z"]
            pub fn WasmModuleObjectBuilderStreaming_Abort(
                this: *mut root::v8::WasmModuleObjectBuilderStreaming,
                exception: root::v8::MaybeLocal<root::v8::Value>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GetPromise@WasmModuleObjectBuilderStreaming@v8@@QEAA?AV?$Local@VPromise@v8@@@2@XZ"]
            pub fn WasmModuleObjectBuilderStreaming_GetPromise(
                this: *mut root::v8::WasmModuleObjectBuilderStreaming,
            ) -> root::v8::Local<root::v8::Promise>;
        }
        extern "C" {
            #[link_name = "\u{1}??0WasmModuleObjectBuilderStreaming@v8@@QEAA@PEAVIsolate@1@@Z"]
            pub fn WasmModuleObjectBuilderStreaming_WasmModuleObjectBuilderStreaming(
                this: *mut root::v8::WasmModuleObjectBuilderStreaming,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DWasmModuleObjectBuilderStreaming@v8@@QEAAXXZ"]
            pub fn WasmModuleObjectBuilderStreaming_WasmModuleObjectBuilderStreaming_destructor(
                this: *mut root::v8::WasmModuleObjectBuilderStreaming,
            );
        }
        impl WasmModuleObjectBuilderStreaming {
            #[inline]
            pub unsafe fn OnBytesReceived(&mut self, arg1: *const u8, size: usize) {
                WasmModuleObjectBuilderStreaming_OnBytesReceived(self, arg1, size)
            }
            #[inline]
            pub unsafe fn Finish(&mut self) {
                WasmModuleObjectBuilderStreaming_Finish(self)
            }
            #[inline]
            pub unsafe fn Abort(&mut self, exception: root::v8::MaybeLocal<root::v8::Value>) {
                WasmModuleObjectBuilderStreaming_Abort(self, exception)
            }
            #[inline]
            pub unsafe fn GetPromise(&mut self) -> root::v8::Local<root::v8::Promise> {
                WasmModuleObjectBuilderStreaming_GetPromise(self)
            }
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                WasmModuleObjectBuilderStreaming_WasmModuleObjectBuilderStreaming(
                    &mut __bindgen_tmp,
                    isolate,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                WasmModuleObjectBuilderStreaming_WasmModuleObjectBuilderStreaming_destructor(self)
            }
        }
        pub const ArrayBufferCreationMode_kInternalized: root::v8::ArrayBufferCreationMode = 0;
        pub const ArrayBufferCreationMode_kExternalized: root::v8::ArrayBufferCreationMode = 1;
        pub type ArrayBufferCreationMode = i32;
        /// An instance of the built-in ArrayBuffer constructor (ES6 draft 15.13.5).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ArrayBuffer {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct ArrayBuffer_Allocator__bindgen_vtable(::std::os::raw::c_void);
        /// A thread-safe allocator that V8 uses to allocate |ArrayBuffer|'s memory.
        /// The allocator is a global V8 setting. It has to be set via
        /// Isolate::CreateParams.
        ///
        /// Memory allocated through this allocator by V8 is accounted for as external
        /// memory by V8. Note that V8 keeps track of the memory for all internalized
        /// |ArrayBuffer|s. Responsibility for tracking external memory (using
        /// Isolate::AdjustAmountOfExternalAllocatedMemory) is handed over to the
        /// embedder upon externalization and taken over upon internalization (creating
        /// an internalized buffer from an existing buffer).
        ///
        /// Note that it is unsafe to call back into V8 from any of the allocator
        /// functions.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ArrayBuffer_Allocator {
            pub vtable_: *const ArrayBuffer_Allocator__bindgen_vtable,
        }
        pub const ArrayBuffer_Allocator_AllocationMode_kNormal:
            root::v8::ArrayBuffer_Allocator_AllocationMode = 0;
        pub const ArrayBuffer_Allocator_AllocationMode_kReservation:
            root::v8::ArrayBuffer_Allocator_AllocationMode = 1;
        /// ArrayBuffer allocation mode. kNormal is a malloc/free style allocation,
        /// while kReservation is for larger allocations with the ability to set
        /// access permissions.
        pub type ArrayBuffer_Allocator_AllocationMode = i32;
        #[test]
        fn bindgen_test_layout_ArrayBuffer_Allocator() {
            assert_eq!(
                ::std::mem::size_of::<ArrayBuffer_Allocator>(),
                8usize,
                concat!("Size of: ", stringify!(ArrayBuffer_Allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<ArrayBuffer_Allocator>(),
                8usize,
                concat!("Alignment of ", stringify!(ArrayBuffer_Allocator))
            );
        }
        extern "C" {
            /// malloc/free based convenience allocator.
            ///
            /// Caller takes ownership, i.e. the returned object needs to be freed using
            /// |delete allocator| once it is no longer in use.
            #[link_name = "\u{1}?NewDefaultAllocator@Allocator@ArrayBuffer@v8@@SAPEAV123@XZ"]
            pub fn ArrayBuffer_Allocator_NewDefaultAllocator(
) -> *mut root::v8::ArrayBuffer_Allocator;
        }
        impl ArrayBuffer_Allocator {
            #[inline]
            pub unsafe fn NewDefaultAllocator() -> *mut root::v8::ArrayBuffer_Allocator {
                ArrayBuffer_Allocator_NewDefaultAllocator()
            }
        }
        /// The contents of an |ArrayBuffer|. Externalization of |ArrayBuffer|
        /// returns an instance of this class, populated, with a pointer to data
        /// and byte length.
        ///
        /// The Data pointer of ArrayBuffer::Contents must be freed using the provided
        /// deleter, which will call ArrayBuffer::Allocator::Free if the buffer
        /// was allocated with ArraryBuffer::Allocator::Allocate.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ArrayBuffer_Contents {
            pub data_: *mut ::std::os::raw::c_void,
            pub byte_length_: usize,
            pub allocation_base_: *mut ::std::os::raw::c_void,
            pub allocation_length_: usize,
            pub allocation_mode_: root::v8::ArrayBuffer_Allocator_AllocationMode,
            pub deleter_: root::v8::ArrayBuffer_Contents_DeleterCallback,
            pub deleter_data_: *mut ::std::os::raw::c_void,
        }
        pub type ArrayBuffer_Contents_DeleterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                buffer: *mut ::std::os::raw::c_void,
                length: usize,
                info: *mut ::std::os::raw::c_void,
            ),
        >;
        #[test]
        fn bindgen_test_layout_ArrayBuffer_Contents() {
            assert_eq!(
                ::std::mem::size_of::<ArrayBuffer_Contents>(),
                56usize,
                concat!("Size of: ", stringify!(ArrayBuffer_Contents))
            );
            assert_eq!(
                ::std::mem::align_of::<ArrayBuffer_Contents>(),
                8usize,
                concat!("Alignment of ", stringify!(ArrayBuffer_Contents))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ArrayBuffer_Contents>())).data_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBuffer_Contents),
                    "::",
                    stringify!(data_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ArrayBuffer_Contents>())).byte_length_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBuffer_Contents),
                    "::",
                    stringify!(byte_length_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ArrayBuffer_Contents>())).allocation_base_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBuffer_Contents),
                    "::",
                    stringify!(allocation_base_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ArrayBuffer_Contents>())).allocation_length_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBuffer_Contents),
                    "::",
                    stringify!(allocation_length_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ArrayBuffer_Contents>())).allocation_mode_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBuffer_Contents),
                    "::",
                    stringify!(allocation_mode_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ArrayBuffer_Contents>())).deleter_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBuffer_Contents),
                    "::",
                    stringify!(deleter_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ArrayBuffer_Contents>())).deleter_data_ as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ArrayBuffer_Contents),
                    "::",
                    stringify!(deleter_data_)
                )
            );
        }
        pub const ArrayBuffer_kInternalFieldCount: ::std::os::raw::c_int = 2;
        pub const ArrayBuffer_kEmbedderFieldCount: ::std::os::raw::c_int = 2;
        #[test]
        fn bindgen_test_layout_ArrayBuffer() {
            assert_eq!(
                ::std::mem::size_of::<ArrayBuffer>(),
                1usize,
                concat!("Size of: ", stringify!(ArrayBuffer))
            );
            assert_eq!(
                ::std::mem::align_of::<ArrayBuffer>(),
                1usize,
                concat!("Alignment of ", stringify!(ArrayBuffer))
            );
        }
        extern "C" {
            /// Data length in bytes.
            #[link_name = "\u{1}?ByteLength@ArrayBuffer@v8@@QEBA_KXZ"]
            pub fn ArrayBuffer_ByteLength(this: *const root::v8::ArrayBuffer) -> usize;
        }
        extern "C" {
            /// Create a new ArrayBuffer. Allocate |byte_length| bytes.
            /// Allocated memory will be owned by a created ArrayBuffer and
            /// will be deallocated when it is garbage-collected,
            /// unless the object is externalized.
            #[link_name = "\u{1}?New@ArrayBuffer@v8@@SA?AV?$Local@VArrayBuffer@v8@@@2@PEAVIsolate@2@_K@Z"]
            pub fn ArrayBuffer_New(
                isolate: *mut root::v8::Isolate,
                byte_length: usize,
            ) -> root::v8::Local<root::v8::ArrayBuffer>;
        }
        extern "C" {
            /// Create a new ArrayBuffer over an existing memory block.
            /// The created array buffer is by default immediately in externalized state.
            /// In externalized state, the memory block will not be reclaimed when a
            /// created ArrayBuffer is garbage-collected.
            /// In internalized state, the memory block will be released using
            /// |Allocator::Free| once all ArrayBuffers referencing it are collected by
            /// the garbage collector.
            #[link_name = "\u{1}?New@ArrayBuffer@v8@@SA?AV?$Local@VArrayBuffer@v8@@@2@PEAVIsolate@2@PEAX_KW4ArrayBufferCreationMode@2@@Z"]
            pub fn ArrayBuffer_New1(
                isolate: *mut root::v8::Isolate,
                data: *mut ::std::os::raw::c_void,
                byte_length: usize,
                mode: root::v8::ArrayBufferCreationMode,
            ) -> root::v8::Local<root::v8::ArrayBuffer>;
        }
        extern "C" {
            /// Returns true if ArrayBuffer is externalized, that is, does not
            /// own its memory block.
            #[link_name = "\u{1}?IsExternal@ArrayBuffer@v8@@QEBA_NXZ"]
            pub fn ArrayBuffer_IsExternal(this: *const root::v8::ArrayBuffer) -> bool;
        }
        extern "C" {
            /// Returns true if this ArrayBuffer may be neutered.
            #[link_name = "\u{1}?IsNeuterable@ArrayBuffer@v8@@QEBA_NXZ"]
            pub fn ArrayBuffer_IsNeuterable(this: *const root::v8::ArrayBuffer) -> bool;
        }
        extern "C" {
            /// Neuters this ArrayBuffer and all its views (typed arrays).
            /// Neutering sets the byte length of the buffer and all typed arrays to zero,
            /// preventing JavaScript from ever accessing underlying backing store.
            /// ArrayBuffer should have been externalized and must be neuterable.
            #[link_name = "\u{1}?Neuter@ArrayBuffer@v8@@QEAAXXZ"]
            pub fn ArrayBuffer_Neuter(this: *mut root::v8::ArrayBuffer);
        }
        extern "C" {
            /// Make this ArrayBuffer external. The pointer to underlying memory block
            /// and byte length are returned as |Contents| structure. After ArrayBuffer
            /// had been externalized, it does no longer own the memory block. The caller
            /// should take steps to free memory when it is no longer needed.
            ///
            /// The Data pointer of ArrayBuffer::Contents must be freed using the provided
            /// deleter, which will call ArrayBuffer::Allocator::Free if the buffer
            /// was allocated with ArraryBuffer::Allocator::Allocate.
            #[link_name = "\u{1}?Externalize@ArrayBuffer@v8@@QEAA?AVContents@12@XZ"]
            pub fn ArrayBuffer_Externalize(
                this: *mut root::v8::ArrayBuffer,
            ) -> root::v8::ArrayBuffer_Contents;
        }
        extern "C" {
            /// Get a pointer to the ArrayBuffer's underlying memory block without
            /// externalizing it. If the ArrayBuffer is not externalized, this pointer
            /// will become invalid as soon as the ArrayBuffer gets garbage collected.
            ///
            /// The embedder should make sure to hold a strong reference to the
            /// ArrayBuffer while accessing this pointer.
            #[link_name = "\u{1}?GetContents@ArrayBuffer@v8@@QEAA?AVContents@12@XZ"]
            pub fn ArrayBuffer_GetContents(
                this: *mut root::v8::ArrayBuffer,
            ) -> root::v8::ArrayBuffer_Contents;
        }
        impl ArrayBuffer {
            #[inline]
            pub unsafe fn ByteLength(&self) -> usize {
                ArrayBuffer_ByteLength(self)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                byte_length: usize,
            ) -> root::v8::Local<root::v8::ArrayBuffer> {
                ArrayBuffer_New(isolate, byte_length)
            }
            #[inline]
            pub unsafe fn New1(
                isolate: *mut root::v8::Isolate,
                data: *mut ::std::os::raw::c_void,
                byte_length: usize,
                mode: root::v8::ArrayBufferCreationMode,
            ) -> root::v8::Local<root::v8::ArrayBuffer> {
                ArrayBuffer_New1(isolate, data, byte_length, mode)
            }
            #[inline]
            pub unsafe fn IsExternal(&self) -> bool {
                ArrayBuffer_IsExternal(self)
            }
            #[inline]
            pub unsafe fn IsNeuterable(&self) -> bool {
                ArrayBuffer_IsNeuterable(self)
            }
            #[inline]
            pub unsafe fn Neuter(&mut self) {
                ArrayBuffer_Neuter(self)
            }
            #[inline]
            pub unsafe fn Externalize(&mut self) -> root::v8::ArrayBuffer_Contents {
                ArrayBuffer_Externalize(self)
            }
            #[inline]
            pub unsafe fn GetContents(&mut self) -> root::v8::ArrayBuffer_Contents {
                ArrayBuffer_GetContents(self)
            }
        }
        /// A base class for an instance of one of "views" over ArrayBuffer,
        /// including TypedArrays and DataView (ES6 draft 15.13).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ArrayBufferView {
            pub _address: u8,
        }
        pub const ArrayBufferView_kInternalFieldCount: ::std::os::raw::c_int = 2;
        pub const ArrayBufferView_kEmbedderFieldCount: ::std::os::raw::c_int = 2;
        #[test]
        fn bindgen_test_layout_ArrayBufferView() {
            assert_eq!(
                ::std::mem::size_of::<ArrayBufferView>(),
                1usize,
                concat!("Size of: ", stringify!(ArrayBufferView))
            );
            assert_eq!(
                ::std::mem::align_of::<ArrayBufferView>(),
                1usize,
                concat!("Alignment of ", stringify!(ArrayBufferView))
            );
        }
        extern "C" {
            /// Returns underlying ArrayBuffer.
            #[link_name = "\u{1}?Buffer@ArrayBufferView@v8@@QEAA?AV?$Local@VArrayBuffer@v8@@@2@XZ"]
            pub fn ArrayBufferView_Buffer(
                this: *mut root::v8::ArrayBufferView,
            ) -> root::v8::Local<root::v8::ArrayBuffer>;
        }
        extern "C" {
            /// Byte offset in |Buffer|.
            #[link_name = "\u{1}?ByteOffset@ArrayBufferView@v8@@QEAA_KXZ"]
            pub fn ArrayBufferView_ByteOffset(this: *mut root::v8::ArrayBufferView) -> usize;
        }
        extern "C" {
            /// Size of a view in bytes.
            #[link_name = "\u{1}?ByteLength@ArrayBufferView@v8@@QEAA_KXZ"]
            pub fn ArrayBufferView_ByteLength(this: *mut root::v8::ArrayBufferView) -> usize;
        }
        extern "C" {
            /// Copy the contents of the ArrayBufferView's buffer to an embedder defined
            /// memory without additional overhead that calling ArrayBufferView::Buffer
            /// might incur.
            ///
            /// Will write at most min(|byte_length|, ByteLength) bytes starting at
            /// ByteOffset of the underlying buffer to the memory starting at |dest|.
            /// Returns the number of bytes actually written.
            #[link_name = "\u{1}?CopyContents@ArrayBufferView@v8@@QEAA_KPEAX_K@Z"]
            pub fn ArrayBufferView_CopyContents(
                this: *mut root::v8::ArrayBufferView,
                dest: *mut ::std::os::raw::c_void,
                byte_length: usize,
            ) -> usize;
        }
        extern "C" {
            /// Returns true if ArrayBufferView's backing ArrayBuffer has already been
            /// allocated.
            #[link_name = "\u{1}?HasBuffer@ArrayBufferView@v8@@QEBA_NXZ"]
            pub fn ArrayBufferView_HasBuffer(this: *const root::v8::ArrayBufferView) -> bool;
        }
        impl ArrayBufferView {
            #[inline]
            pub unsafe fn Buffer(&mut self) -> root::v8::Local<root::v8::ArrayBuffer> {
                ArrayBufferView_Buffer(self)
            }
            #[inline]
            pub unsafe fn ByteOffset(&mut self) -> usize {
                ArrayBufferView_ByteOffset(self)
            }
            #[inline]
            pub unsafe fn ByteLength(&mut self) -> usize {
                ArrayBufferView_ByteLength(self)
            }
            #[inline]
            pub unsafe fn CopyContents(
                &mut self,
                dest: *mut ::std::os::raw::c_void,
                byte_length: usize,
            ) -> usize {
                ArrayBufferView_CopyContents(self, dest, byte_length)
            }
            #[inline]
            pub unsafe fn HasBuffer(&self) -> bool {
                ArrayBufferView_HasBuffer(self)
            }
        }
        /// A base class for an instance of TypedArray series of constructors
        /// (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct TypedArray {
            pub _address: u8,
        }
        pub const TypedArray_kMaxLength: usize = 2147483647;
        #[test]
        fn bindgen_test_layout_TypedArray() {
            assert_eq!(
                ::std::mem::size_of::<TypedArray>(),
                1usize,
                concat!("Size of: ", stringify!(TypedArray))
            );
            assert_eq!(
                ::std::mem::align_of::<TypedArray>(),
                1usize,
                concat!("Alignment of ", stringify!(TypedArray))
            );
        }
        extern "C" {
            /// Number of elements in this typed array
            /// (e.g. for Int16Array, |ByteLength|/2).
            #[link_name = "\u{1}?Length@TypedArray@v8@@QEAA_KXZ"]
            pub fn TypedArray_Length(this: *mut root::v8::TypedArray) -> usize;
        }
        impl TypedArray {
            #[inline]
            pub unsafe fn Length(&mut self) -> usize {
                TypedArray_Length(self)
            }
        }
        /// An instance of Uint8Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Uint8Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Uint8Array() {
            assert_eq!(
                ::std::mem::size_of::<Uint8Array>(),
                1usize,
                concat!("Size of: ", stringify!(Uint8Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Uint8Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Uint8Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint8Array@v8@@SA?AV?$Local@VUint8Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint8Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint8Array@v8@@SA?AV?$Local@VUint8Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint8Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8Array>;
        }
        impl Uint8Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8Array> {
                Uint8Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8Array> {
                Uint8Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Uint8ClampedArray constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Uint8ClampedArray {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Uint8ClampedArray() {
            assert_eq!(
                ::std::mem::size_of::<Uint8ClampedArray>(),
                1usize,
                concat!("Size of: ", stringify!(Uint8ClampedArray))
            );
            assert_eq!(
                ::std::mem::align_of::<Uint8ClampedArray>(),
                1usize,
                concat!("Alignment of ", stringify!(Uint8ClampedArray))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint8ClampedArray@v8@@SA?AV?$Local@VUint8ClampedArray@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint8ClampedArray_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8ClampedArray>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint8ClampedArray@v8@@SA?AV?$Local@VUint8ClampedArray@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint8ClampedArray_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8ClampedArray>;
        }
        impl Uint8ClampedArray {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8ClampedArray> {
                Uint8ClampedArray_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint8ClampedArray> {
                Uint8ClampedArray_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Int8Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Int8Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Int8Array() {
            assert_eq!(
                ::std::mem::size_of::<Int8Array>(),
                1usize,
                concat!("Size of: ", stringify!(Int8Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Int8Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Int8Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Int8Array@v8@@SA?AV?$Local@VInt8Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Int8Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int8Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Int8Array@v8@@SA?AV?$Local@VInt8Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Int8Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int8Array>;
        }
        impl Int8Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int8Array> {
                Int8Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int8Array> {
                Int8Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Uint16Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Uint16Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Uint16Array() {
            assert_eq!(
                ::std::mem::size_of::<Uint16Array>(),
                1usize,
                concat!("Size of: ", stringify!(Uint16Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Uint16Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Uint16Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint16Array@v8@@SA?AV?$Local@VUint16Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint16Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint16Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint16Array@v8@@SA?AV?$Local@VUint16Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint16Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint16Array>;
        }
        impl Uint16Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint16Array> {
                Uint16Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint16Array> {
                Uint16Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Int16Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Int16Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Int16Array() {
            assert_eq!(
                ::std::mem::size_of::<Int16Array>(),
                1usize,
                concat!("Size of: ", stringify!(Int16Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Int16Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Int16Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Int16Array@v8@@SA?AV?$Local@VInt16Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Int16Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int16Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Int16Array@v8@@SA?AV?$Local@VInt16Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Int16Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int16Array>;
        }
        impl Int16Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int16Array> {
                Int16Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int16Array> {
                Int16Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Uint32Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Uint32Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Uint32Array() {
            assert_eq!(
                ::std::mem::size_of::<Uint32Array>(),
                1usize,
                concat!("Size of: ", stringify!(Uint32Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Uint32Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Uint32Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint32Array@v8@@SA?AV?$Local@VUint32Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint32Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint32Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Uint32Array@v8@@SA?AV?$Local@VUint32Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Uint32Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint32Array>;
        }
        impl Uint32Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint32Array> {
                Uint32Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Uint32Array> {
                Uint32Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Int32Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Int32Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Int32Array() {
            assert_eq!(
                ::std::mem::size_of::<Int32Array>(),
                1usize,
                concat!("Size of: ", stringify!(Int32Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Int32Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Int32Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Int32Array@v8@@SA?AV?$Local@VInt32Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Int32Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int32Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Int32Array@v8@@SA?AV?$Local@VInt32Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Int32Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int32Array>;
        }
        impl Int32Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int32Array> {
                Int32Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Int32Array> {
                Int32Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Float32Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Float32Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Float32Array() {
            assert_eq!(
                ::std::mem::size_of::<Float32Array>(),
                1usize,
                concat!("Size of: ", stringify!(Float32Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Float32Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Float32Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Float32Array@v8@@SA?AV?$Local@VFloat32Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Float32Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float32Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Float32Array@v8@@SA?AV?$Local@VFloat32Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Float32Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float32Array>;
        }
        impl Float32Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float32Array> {
                Float32Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float32Array> {
                Float32Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of Float64Array constructor (ES6 draft 15.13.6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Float64Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Float64Array() {
            assert_eq!(
                ::std::mem::size_of::<Float64Array>(),
                1usize,
                concat!("Size of: ", stringify!(Float64Array))
            );
            assert_eq!(
                ::std::mem::align_of::<Float64Array>(),
                1usize,
                concat!("Alignment of ", stringify!(Float64Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Float64Array@v8@@SA?AV?$Local@VFloat64Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Float64Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float64Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Float64Array@v8@@SA?AV?$Local@VFloat64Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn Float64Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float64Array>;
        }
        impl Float64Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float64Array> {
                Float64Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::Float64Array> {
                Float64Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of BigInt64Array constructor.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct BigInt64Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_BigInt64Array() {
            assert_eq!(
                ::std::mem::size_of::<BigInt64Array>(),
                1usize,
                concat!("Size of: ", stringify!(BigInt64Array))
            );
            assert_eq!(
                ::std::mem::align_of::<BigInt64Array>(),
                1usize,
                concat!("Alignment of ", stringify!(BigInt64Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@BigInt64Array@v8@@SA?AV?$Local@VBigInt64Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn BigInt64Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigInt64Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@BigInt64Array@v8@@SA?AV?$Local@VBigInt64Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn BigInt64Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigInt64Array>;
        }
        impl BigInt64Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigInt64Array> {
                BigInt64Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigInt64Array> {
                BigInt64Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of BigUint64Array constructor.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct BigUint64Array {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_BigUint64Array() {
            assert_eq!(
                ::std::mem::size_of::<BigUint64Array>(),
                1usize,
                concat!("Size of: ", stringify!(BigUint64Array))
            );
            assert_eq!(
                ::std::mem::align_of::<BigUint64Array>(),
                1usize,
                concat!("Alignment of ", stringify!(BigUint64Array))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@BigUint64Array@v8@@SA?AV?$Local@VBigUint64Array@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn BigUint64Array_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigUint64Array>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@BigUint64Array@v8@@SA?AV?$Local@VBigUint64Array@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn BigUint64Array_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigUint64Array>;
        }
        impl BigUint64Array {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigUint64Array> {
                BigUint64Array_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::BigUint64Array> {
                BigUint64Array_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of DataView constructor (ES6 draft 15.13.7).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct DataView {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_DataView() {
            assert_eq!(
                ::std::mem::size_of::<DataView>(),
                1usize,
                concat!("Size of: ", stringify!(DataView))
            );
            assert_eq!(
                ::std::mem::align_of::<DataView>(),
                1usize,
                concat!("Alignment of ", stringify!(DataView))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@DataView@v8@@SA?AV?$Local@VDataView@v8@@@2@V?$Local@VArrayBuffer@v8@@@2@_K1@Z"]
            pub fn DataView_New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::DataView>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@DataView@v8@@SA?AV?$Local@VDataView@v8@@@2@V?$Local@VSharedArrayBuffer@v8@@@2@_K1@Z"]
            pub fn DataView_New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::DataView>;
        }
        impl DataView {
            #[inline]
            pub unsafe fn New(
                array_buffer: root::v8::Local<root::v8::ArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::DataView> {
                DataView_New(array_buffer, byte_offset, length)
            }
            #[inline]
            pub unsafe fn New1(
                shared_array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                byte_offset: usize,
                length: usize,
            ) -> root::v8::Local<root::v8::DataView> {
                DataView_New1(shared_array_buffer, byte_offset, length)
            }
        }
        /// An instance of the built-in SharedArrayBuffer constructor.
        /// This API is experimental and may change significantly.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct SharedArrayBuffer {
            pub _address: u8,
        }
        /// The contents of an |SharedArrayBuffer|. Externalization of
        /// |SharedArrayBuffer| returns an instance of this class, populated, with a
        /// pointer to data and byte length.
        ///
        /// The Data pointer of ArrayBuffer::Contents must be freed using the provided
        /// deleter, which will call ArrayBuffer::Allocator::Free if the buffer
        /// was allocated with ArraryBuffer::Allocator::Allocate.
        ///
        /// This API is experimental and may change significantly.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct SharedArrayBuffer_Contents {
            pub data_: *mut ::std::os::raw::c_void,
            pub byte_length_: usize,
            pub allocation_base_: *mut ::std::os::raw::c_void,
            pub allocation_length_: usize,
            pub allocation_mode_: root::v8::ArrayBuffer_Allocator_AllocationMode,
            pub deleter_: root::v8::SharedArrayBuffer_Contents_DeleterCallback,
            pub deleter_data_: *mut ::std::os::raw::c_void,
        }
        pub type SharedArrayBuffer_Contents_Allocator = root::v8::ArrayBuffer_Allocator;
        pub type SharedArrayBuffer_Contents_DeleterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                buffer: *mut ::std::os::raw::c_void,
                length: usize,
                info: *mut ::std::os::raw::c_void,
            ),
        >;
        #[test]
        fn bindgen_test_layout_SharedArrayBuffer_Contents() {
            assert_eq!(
                ::std::mem::size_of::<SharedArrayBuffer_Contents>(),
                56usize,
                concat!("Size of: ", stringify!(SharedArrayBuffer_Contents))
            );
            assert_eq!(
                ::std::mem::align_of::<SharedArrayBuffer_Contents>(),
                8usize,
                concat!("Alignment of ", stringify!(SharedArrayBuffer_Contents))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayBuffer_Contents>())).data_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayBuffer_Contents),
                    "::",
                    stringify!(data_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayBuffer_Contents>())).byte_length_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayBuffer_Contents),
                    "::",
                    stringify!(byte_length_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayBuffer_Contents>())).allocation_base_
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayBuffer_Contents),
                    "::",
                    stringify!(allocation_base_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayBuffer_Contents>())).allocation_length_
                        as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayBuffer_Contents),
                    "::",
                    stringify!(allocation_length_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayBuffer_Contents>())).allocation_mode_
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayBuffer_Contents),
                    "::",
                    stringify!(allocation_mode_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayBuffer_Contents>())).deleter_ as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayBuffer_Contents),
                    "::",
                    stringify!(deleter_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayBuffer_Contents>())).deleter_data_ as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayBuffer_Contents),
                    "::",
                    stringify!(deleter_data_)
                )
            );
        }
        pub const SharedArrayBuffer_kInternalFieldCount: ::std::os::raw::c_int = 2;
        #[test]
        fn bindgen_test_layout_SharedArrayBuffer() {
            assert_eq!(
                ::std::mem::size_of::<SharedArrayBuffer>(),
                1usize,
                concat!("Size of: ", stringify!(SharedArrayBuffer))
            );
            assert_eq!(
                ::std::mem::align_of::<SharedArrayBuffer>(),
                1usize,
                concat!("Alignment of ", stringify!(SharedArrayBuffer))
            );
        }
        extern "C" {
            /// Data length in bytes.
            #[link_name = "\u{1}?ByteLength@SharedArrayBuffer@v8@@QEBA_KXZ"]
            pub fn SharedArrayBuffer_ByteLength(this: *const root::v8::SharedArrayBuffer) -> usize;
        }
        extern "C" {
            /// Create a new SharedArrayBuffer. Allocate |byte_length| bytes.
            /// Allocated memory will be owned by a created SharedArrayBuffer and
            /// will be deallocated when it is garbage-collected,
            /// unless the object is externalized.
            #[link_name = "\u{1}?New@SharedArrayBuffer@v8@@SA?AV?$Local@VSharedArrayBuffer@v8@@@2@PEAVIsolate@2@_K@Z"]
            pub fn SharedArrayBuffer_New(
                isolate: *mut root::v8::Isolate,
                byte_length: usize,
            ) -> root::v8::Local<root::v8::SharedArrayBuffer>;
        }
        extern "C" {
            /// Create a new SharedArrayBuffer over an existing memory block.  The created
            /// array buffer is immediately in externalized state unless otherwise
            /// specified. The memory block will not be reclaimed when a created
            /// SharedArrayBuffer is garbage-collected.
            #[link_name = "\u{1}?New@SharedArrayBuffer@v8@@SA?AV?$Local@VSharedArrayBuffer@v8@@@2@PEAVIsolate@2@PEAX_KW4ArrayBufferCreationMode@2@@Z"]
            pub fn SharedArrayBuffer_New1(
                isolate: *mut root::v8::Isolate,
                data: *mut ::std::os::raw::c_void,
                byte_length: usize,
                mode: root::v8::ArrayBufferCreationMode,
            ) -> root::v8::Local<root::v8::SharedArrayBuffer>;
        }
        extern "C" {
            /// Returns true if SharedArrayBuffer is externalized, that is, does not
            /// own its memory block.
            #[link_name = "\u{1}?IsExternal@SharedArrayBuffer@v8@@QEBA_NXZ"]
            pub fn SharedArrayBuffer_IsExternal(this: *const root::v8::SharedArrayBuffer) -> bool;
        }
        extern "C" {
            /// Make this SharedArrayBuffer external. The pointer to underlying memory
            /// block and byte length are returned as |Contents| structure. After
            /// SharedArrayBuffer had been externalized, it does no longer own the memory
            /// block. The caller should take steps to free memory when it is no longer
            /// needed.
            ///
            /// The memory block is guaranteed to be allocated with |Allocator::Allocate|
            /// by the allocator specified in
            /// v8::Isolate::CreateParams::array_buffer_allocator.
            ///
            #[link_name = "\u{1}?Externalize@SharedArrayBuffer@v8@@QEAA?AVContents@12@XZ"]
            pub fn SharedArrayBuffer_Externalize(
                this: *mut root::v8::SharedArrayBuffer,
            ) -> root::v8::SharedArrayBuffer_Contents;
        }
        extern "C" {
            /// Get a pointer to the ArrayBuffer's underlying memory block without
            /// externalizing it. If the ArrayBuffer is not externalized, this pointer
            /// will become invalid as soon as the ArrayBuffer became garbage collected.
            ///
            /// The embedder should make sure to hold a strong reference to the
            /// ArrayBuffer while accessing this pointer.
            ///
            /// The memory block is guaranteed to be allocated with |Allocator::Allocate|
            /// by the allocator specified in
            /// v8::Isolate::CreateParams::array_buffer_allocator.
            #[link_name = "\u{1}?GetContents@SharedArrayBuffer@v8@@QEAA?AVContents@12@XZ"]
            pub fn SharedArrayBuffer_GetContents(
                this: *mut root::v8::SharedArrayBuffer,
            ) -> root::v8::SharedArrayBuffer_Contents;
        }
        impl SharedArrayBuffer {
            #[inline]
            pub unsafe fn ByteLength(&self) -> usize {
                SharedArrayBuffer_ByteLength(self)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                byte_length: usize,
            ) -> root::v8::Local<root::v8::SharedArrayBuffer> {
                SharedArrayBuffer_New(isolate, byte_length)
            }
            #[inline]
            pub unsafe fn New1(
                isolate: *mut root::v8::Isolate,
                data: *mut ::std::os::raw::c_void,
                byte_length: usize,
                mode: root::v8::ArrayBufferCreationMode,
            ) -> root::v8::Local<root::v8::SharedArrayBuffer> {
                SharedArrayBuffer_New1(isolate, data, byte_length, mode)
            }
            #[inline]
            pub unsafe fn IsExternal(&self) -> bool {
                SharedArrayBuffer_IsExternal(self)
            }
            #[inline]
            pub unsafe fn Externalize(&mut self) -> root::v8::SharedArrayBuffer_Contents {
                SharedArrayBuffer_Externalize(self)
            }
            #[inline]
            pub unsafe fn GetContents(&mut self) -> root::v8::SharedArrayBuffer_Contents {
                SharedArrayBuffer_GetContents(self)
            }
        }
        /// An instance of the built-in Date constructor (ECMA-262, 15.9).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Date {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Date() {
            assert_eq!(
                ::std::mem::size_of::<Date>(),
                1usize,
                concat!("Size of: ", stringify!(Date))
            );
            assert_eq!(
                ::std::mem::align_of::<Date>(),
                1usize,
                concat!("Alignment of ", stringify!(Date))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Date@v8@@SA?AV?$Local@VValue@v8@@@2@PEAVIsolate@2@N@Z"]
            pub fn Date_New(
                isolate: *mut root::v8::Isolate,
                time: f64,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?New@Date@v8@@SA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@N@Z"]
            pub fn Date_New1(
                context: root::v8::Local<root::v8::Context>,
                time: f64,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// A specialization of Value::NumberValue that is more efficient
            /// because we know the structure of this object.
            #[link_name = "\u{1}?ValueOf@Date@v8@@QEBANXZ"]
            pub fn Date_ValueOf(this: *const root::v8::Date) -> f64;
        }
        extern "C" {
            /// Notification that the embedder has changed the time zone,
            /// daylight savings time, or other date / time configuration
            /// parameters.  V8 keeps a cache of various values used for
            /// date / time computation.  This notification will reset
            /// those cached values for the current context so that date /
            /// time configuration changes would be reflected in the Date
            /// object.
            ///
            /// This API should not be called more than needed as it will
            /// negatively impact the performance of date operations.
            #[link_name = "\u{1}?DateTimeConfigurationChangeNotification@Date@v8@@SAXPEAVIsolate@2@@Z"]
            pub fn Date_DateTimeConfigurationChangeNotification(isolate: *mut root::v8::Isolate);
        }
        impl Date {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                time: f64,
            ) -> root::v8::Local<root::v8::Value> {
                Date_New(isolate, time)
            }
            #[inline]
            pub unsafe fn New1(
                context: root::v8::Local<root::v8::Context>,
                time: f64,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                Date_New1(context, time)
            }
            #[inline]
            pub unsafe fn ValueOf(&self) -> f64 {
                Date_ValueOf(self)
            }
            #[inline]
            pub unsafe fn DateTimeConfigurationChangeNotification(isolate: *mut root::v8::Isolate) {
                Date_DateTimeConfigurationChangeNotification(isolate)
            }
        }
        /// A Number object (ECMA-262, 4.3.21).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct NumberObject {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_NumberObject() {
            assert_eq!(
                ::std::mem::size_of::<NumberObject>(),
                1usize,
                concat!("Size of: ", stringify!(NumberObject))
            );
            assert_eq!(
                ::std::mem::align_of::<NumberObject>(),
                1usize,
                concat!("Alignment of ", stringify!(NumberObject))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@NumberObject@v8@@SA?AV?$Local@VValue@v8@@@2@PEAVIsolate@2@N@Z"]
            pub fn NumberObject_New(
                isolate: *mut root::v8::Isolate,
                value: f64,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?ValueOf@NumberObject@v8@@QEBANXZ"]
            pub fn NumberObject_ValueOf(this: *const root::v8::NumberObject) -> f64;
        }
        impl NumberObject {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: f64,
            ) -> root::v8::Local<root::v8::Value> {
                NumberObject_New(isolate, value)
            }
            #[inline]
            pub unsafe fn ValueOf(&self) -> f64 {
                NumberObject_ValueOf(self)
            }
        }
        /// A BigInt object (https://tc39.github.io/proposal-bigint)
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct BigIntObject {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_BigIntObject() {
            assert_eq!(
                ::std::mem::size_of::<BigIntObject>(),
                1usize,
                concat!("Size of: ", stringify!(BigIntObject))
            );
            assert_eq!(
                ::std::mem::align_of::<BigIntObject>(),
                1usize,
                concat!("Alignment of ", stringify!(BigIntObject))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@BigIntObject@v8@@SA?AV?$Local@VValue@v8@@@2@PEAVIsolate@2@_J@Z"]
            pub fn BigIntObject_New(
                isolate: *mut root::v8::Isolate,
                value: i64,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?ValueOf@BigIntObject@v8@@QEBA?AV?$Local@VBigInt@v8@@@2@XZ"]
            pub fn BigIntObject_ValueOf(
                this: *const root::v8::BigIntObject,
            ) -> root::v8::Local<root::v8::BigInt>;
        }
        impl BigIntObject {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: i64,
            ) -> root::v8::Local<root::v8::Value> {
                BigIntObject_New(isolate, value)
            }
            #[inline]
            pub unsafe fn ValueOf(&self) -> root::v8::Local<root::v8::BigInt> {
                BigIntObject_ValueOf(self)
            }
        }
        /// A Boolean object (ECMA-262, 4.3.15).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct BooleanObject {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_BooleanObject() {
            assert_eq!(
                ::std::mem::size_of::<BooleanObject>(),
                1usize,
                concat!("Size of: ", stringify!(BooleanObject))
            );
            assert_eq!(
                ::std::mem::align_of::<BooleanObject>(),
                1usize,
                concat!("Alignment of ", stringify!(BooleanObject))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@BooleanObject@v8@@SA?AV?$Local@VValue@v8@@@2@PEAVIsolate@2@_N@Z"]
            pub fn BooleanObject_New(
                isolate: *mut root::v8::Isolate,
                value: bool,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?ValueOf@BooleanObject@v8@@QEBA_NXZ"]
            pub fn BooleanObject_ValueOf(this: *const root::v8::BooleanObject) -> bool;
        }
        impl BooleanObject {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: bool,
            ) -> root::v8::Local<root::v8::Value> {
                BooleanObject_New(isolate, value)
            }
            #[inline]
            pub unsafe fn ValueOf(&self) -> bool {
                BooleanObject_ValueOf(self)
            }
        }
        /// A String object (ECMA-262, 4.3.18).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct StringObject {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_StringObject() {
            assert_eq!(
                ::std::mem::size_of::<StringObject>(),
                1usize,
                concat!("Size of: ", stringify!(StringObject))
            );
            assert_eq!(
                ::std::mem::align_of::<StringObject>(),
                1usize,
                concat!("Alignment of ", stringify!(StringObject))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@StringObject@v8@@SA?AV?$Local@VValue@v8@@@2@PEAVIsolate@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn StringObject_New(
                isolate: *mut root::v8::Isolate,
                value: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?ValueOf@StringObject@v8@@QEBA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn StringObject_ValueOf(
                this: *const root::v8::StringObject,
            ) -> root::v8::Local<root::v8::String>;
        }
        impl StringObject {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Value> {
                StringObject_New(isolate, value)
            }
            #[inline]
            pub unsafe fn ValueOf(&self) -> root::v8::Local<root::v8::String> {
                StringObject_ValueOf(self)
            }
        }
        /// A Symbol object (ECMA-262 edition 6).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct SymbolObject {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_SymbolObject() {
            assert_eq!(
                ::std::mem::size_of::<SymbolObject>(),
                1usize,
                concat!("Size of: ", stringify!(SymbolObject))
            );
            assert_eq!(
                ::std::mem::align_of::<SymbolObject>(),
                1usize,
                concat!("Alignment of ", stringify!(SymbolObject))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@SymbolObject@v8@@SA?AV?$Local@VValue@v8@@@2@PEAVIsolate@2@V?$Local@VSymbol@v8@@@2@@Z"]
            pub fn SymbolObject_New(
                isolate: *mut root::v8::Isolate,
                value: root::v8::Local<root::v8::Symbol>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?ValueOf@SymbolObject@v8@@QEBA?AV?$Local@VSymbol@v8@@@2@XZ"]
            pub fn SymbolObject_ValueOf(
                this: *const root::v8::SymbolObject,
            ) -> root::v8::Local<root::v8::Symbol>;
        }
        impl SymbolObject {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: root::v8::Local<root::v8::Symbol>,
            ) -> root::v8::Local<root::v8::Value> {
                SymbolObject_New(isolate, value)
            }
            #[inline]
            pub unsafe fn ValueOf(&self) -> root::v8::Local<root::v8::Symbol> {
                SymbolObject_ValueOf(self)
            }
        }
        /// An instance of the built-in RegExp constructor (ECMA-262, 15.10).
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct RegExp {
            pub _address: u8,
        }
        pub const RegExp_Flags_kNone: root::v8::RegExp_Flags = 0;
        pub const RegExp_Flags_kGlobal: root::v8::RegExp_Flags = 1;
        pub const RegExp_Flags_kIgnoreCase: root::v8::RegExp_Flags = 2;
        pub const RegExp_Flags_kMultiline: root::v8::RegExp_Flags = 4;
        pub const RegExp_Flags_kSticky: root::v8::RegExp_Flags = 8;
        pub const RegExp_Flags_kUnicode: root::v8::RegExp_Flags = 16;
        pub const RegExp_Flags_kDotAll: root::v8::RegExp_Flags = 32;
        /// Regular expression flag bits. They can be or'ed to enable a set
        /// of flags.
        pub type RegExp_Flags = i32;
        #[test]
        fn bindgen_test_layout_RegExp() {
            assert_eq!(
                ::std::mem::size_of::<RegExp>(),
                1usize,
                concat!("Size of: ", stringify!(RegExp))
            );
            assert_eq!(
                ::std::mem::align_of::<RegExp>(),
                1usize,
                concat!("Alignment of ", stringify!(RegExp))
            );
        }
        extern "C" {
            /// Creates a regular expression from the given pattern string and
            /// the flags bit field. May throw a JavaScript exception as
            /// described in ECMA-262, 15.10.4.1.
            ///
            /// For example,
            /// RegExp::New(v8::String::New("foo"),
            /// static_cast<RegExp::Flags>(kGlobal | kMultiline))
            /// is equivalent to evaluating "/foo/gm".
            #[link_name = "\u{1}?New@RegExp@v8@@SA?AV?$MaybeLocal@VRegExp@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VString@v8@@@2@W4Flags@12@@Z"]
            pub fn RegExp_New(
                context: root::v8::Local<root::v8::Context>,
                pattern: root::v8::Local<root::v8::String>,
                flags: root::v8::RegExp_Flags,
            ) -> root::v8::MaybeLocal<root::v8::RegExp>;
        }
        extern "C" {
            /// Returns the value of the source property: a string representing
            /// the regular expression.
            #[link_name = "\u{1}?GetSource@RegExp@v8@@QEBA?AV?$Local@VString@v8@@@2@XZ"]
            pub fn RegExp_GetSource(
                this: *const root::v8::RegExp,
            ) -> root::v8::Local<root::v8::String>;
        }
        extern "C" {
            /// Returns the flags bit field.
            #[link_name = "\u{1}?GetFlags@RegExp@v8@@QEBA?AW4Flags@12@XZ"]
            pub fn RegExp_GetFlags(this: *const root::v8::RegExp) -> root::v8::RegExp_Flags;
        }
        impl RegExp {
            #[inline]
            pub unsafe fn New(
                context: root::v8::Local<root::v8::Context>,
                pattern: root::v8::Local<root::v8::String>,
                flags: root::v8::RegExp_Flags,
            ) -> root::v8::MaybeLocal<root::v8::RegExp> {
                RegExp_New(context, pattern, flags)
            }
            #[inline]
            pub unsafe fn GetSource(&self) -> root::v8::Local<root::v8::String> {
                RegExp_GetSource(self)
            }
            #[inline]
            pub unsafe fn GetFlags(&self) -> root::v8::RegExp_Flags {
                RegExp_GetFlags(self)
            }
        }
        /// A JavaScript value that wraps a C++ void*. This type of value is mainly used
        /// to associate C++ data structures with JavaScript objects.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct External {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_External() {
            assert_eq!(
                ::std::mem::size_of::<External>(),
                1usize,
                concat!("Size of: ", stringify!(External))
            );
            assert_eq!(
                ::std::mem::align_of::<External>(),
                1usize,
                concat!("Alignment of ", stringify!(External))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@External@v8@@SA?AV?$Local@VExternal@v8@@@2@PEAVIsolate@2@PEAX@Z"]
            pub fn External_New(
                isolate: *mut root::v8::Isolate,
                value: *mut ::std::os::raw::c_void,
            ) -> root::v8::Local<root::v8::External>;
        }
        extern "C" {
            #[link_name = "\u{1}?Value@External@v8@@QEBAPEAXXZ"]
            pub fn External_Value(this: *const root::v8::External) -> *mut ::std::os::raw::c_void;
        }
        impl External {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                value: *mut ::std::os::raw::c_void,
            ) -> root::v8::Local<root::v8::External> {
                External_New(isolate, value)
            }
            #[inline]
            pub unsafe fn Value(&self) -> *mut ::std::os::raw::c_void {
                External_Value(self)
            }
        }
        pub const Intrinsic_kArrayProto_entries: root::v8::Intrinsic = 0;
        pub const Intrinsic_kArrayProto_forEach: root::v8::Intrinsic = 1;
        pub const Intrinsic_kArrayProto_keys: root::v8::Intrinsic = 2;
        pub const Intrinsic_kArrayProto_values: root::v8::Intrinsic = 3;
        pub const Intrinsic_kErrorPrototype: root::v8::Intrinsic = 4;
        pub const Intrinsic_kIteratorPrototype: root::v8::Intrinsic = 5;
        pub type Intrinsic = i32;
        /// The superclass of object and function templates.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Template {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Template() {
            assert_eq!(
                ::std::mem::size_of::<Template>(),
                1usize,
                concat!("Size of: ", stringify!(Template))
            );
            assert_eq!(
                ::std::mem::align_of::<Template>(),
                1usize,
                concat!("Alignment of ", stringify!(Template))
            );
        }
        extern "C" {
            /// Adds a property to each instance created by this template.
            ///
            /// The property must be defined either as a primitive value, or a template.
            #[link_name = "\u{1}?Set@Template@v8@@QEAAXV?$Local@VName@v8@@@2@V?$Local@VData@v8@@@2@W4PropertyAttribute@2@@Z"]
            pub fn Template_Set(
                this: *mut root::v8::Template,
                name: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Data>,
                attributes: root::v8::PropertyAttribute,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetPrivate@Template@v8@@QEAAXV?$Local@VPrivate@v8@@@2@V?$Local@VData@v8@@@2@W4PropertyAttribute@2@@Z"]
            pub fn Template_SetPrivate(
                this: *mut root::v8::Template,
                name: root::v8::Local<root::v8::Private>,
                value: root::v8::Local<root::v8::Data>,
                attributes: root::v8::PropertyAttribute,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetAccessorProperty@Template@v8@@QEAAXV?$Local@VName@v8@@@2@V?$Local@VFunctionTemplate@v8@@@2@1W4PropertyAttribute@2@W4AccessControl@2@@Z"]
            pub fn Template_SetAccessorProperty(
                this: *mut root::v8::Template,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::Local<root::v8::FunctionTemplate>,
                setter: root::v8::Local<root::v8::FunctionTemplate>,
                attribute: root::v8::PropertyAttribute,
                settings: root::v8::AccessControl,
            );
        }
        extern "C" {
            /// Whenever the property with the given name is accessed on objects
            /// created from this Template the getter and setter callbacks
            /// are called instead of getting and setting the property directly
            /// on the JavaScript object.
            ///
            /// \param name The name of the property for which an accessor is added.
            /// \param getter The callback to invoke when getting the property.
            /// \param setter The callback to invoke when setting the property.
            /// \param data A piece of data that will be passed to the getter and setter
            /// callbacks whenever they are invoked.
            /// \param settings Access control settings for the accessor. This is a bit
            /// field consisting of one of more of
            /// DEFAULT = 0, ALL_CAN_READ = 1, or ALL_CAN_WRITE = 2.
            /// The default is to not allow cross-context access.
            /// ALL_CAN_READ means that all cross-context reads are allowed.
            /// ALL_CAN_WRITE means that all cross-context writes are allowed.
            /// The combination ALL_CAN_READ | ALL_CAN_WRITE can be used to allow all
            /// cross-context access.
            /// \param attribute The attributes of the property for which an accessor
            /// is added.
            /// \param signature The signature describes valid receivers for the accessor
            /// and is used to perform implicit instance checks against them. If the
            /// receiver is incompatible (i.e. is not an instance of the constructor as
            /// defined by FunctionTemplate::HasInstance()), an implicit TypeError is
            /// thrown and no callback is invoked.
            #[link_name = "\u{1}?SetNativeDataProperty@Template@v8@@QEAAXV?$Local@VString@v8@@@2@P6AX0AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZP6AX0V?$Local@VValue@v8@@@2@AEBV?$PropertyCallbackInfo@X@2@@Z3W4PropertyAttribute@2@V?$Local@VAccessorSignature@v8@@@2@W4AccessControl@2@W4SideEffectType@2@@Z"]
            pub fn Template_SetNativeDataProperty(
                this: *mut root::v8::Template,
                name: root::v8::Local<root::v8::String>,
                getter: root::v8::AccessorGetterCallback,
                setter: root::v8::AccessorSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                settings: root::v8::AccessControl,
                getter_side_effect_type: root::v8::SideEffectType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetNativeDataProperty@Template@v8@@QEAAXV?$Local@VName@v8@@@2@P6AX0AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZP6AX0V?$Local@VValue@v8@@@2@AEBV?$PropertyCallbackInfo@X@2@@Z3W4PropertyAttribute@2@V?$Local@VAccessorSignature@v8@@@2@W4AccessControl@2@W4SideEffectType@2@@Z"]
            pub fn Template_SetNativeDataProperty1(
                this: *mut root::v8::Template,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                settings: root::v8::AccessControl,
                getter_side_effect_type: root::v8::SideEffectType,
            );
        }
        extern "C" {
            /// Like SetNativeDataProperty, but V8 will replace the native data property
            /// with a real data property on first access.
            #[link_name = "\u{1}?SetLazyDataProperty@Template@v8@@QEAAXV?$Local@VName@v8@@@2@P6AX0AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@W4PropertyAttribute@2@W4SideEffectType@2@@Z"]
            pub fn Template_SetLazyDataProperty(
                this: *mut root::v8::Template,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attribute: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            );
        }
        extern "C" {
            /// During template instantiation, sets the value with the intrinsic property
            /// from the correct context.
            #[link_name = "\u{1}?SetIntrinsicDataProperty@Template@v8@@QEAAXV?$Local@VName@v8@@@2@W4Intrinsic@2@W4PropertyAttribute@2@@Z"]
            pub fn Template_SetIntrinsicDataProperty(
                this: *mut root::v8::Template,
                name: root::v8::Local<root::v8::Name>,
                intrinsic: root::v8::Intrinsic,
                attribute: root::v8::PropertyAttribute,
            );
        }
        impl Template {
            #[inline]
            pub unsafe fn Set(
                &mut self,
                name: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Data>,
                attributes: root::v8::PropertyAttribute,
            ) {
                Template_Set(self, name, value, attributes)
            }
            #[inline]
            pub unsafe fn SetPrivate(
                &mut self,
                name: root::v8::Local<root::v8::Private>,
                value: root::v8::Local<root::v8::Data>,
                attributes: root::v8::PropertyAttribute,
            ) {
                Template_SetPrivate(self, name, value, attributes)
            }
            #[inline]
            pub unsafe fn SetAccessorProperty(
                &mut self,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::Local<root::v8::FunctionTemplate>,
                setter: root::v8::Local<root::v8::FunctionTemplate>,
                attribute: root::v8::PropertyAttribute,
                settings: root::v8::AccessControl,
            ) {
                Template_SetAccessorProperty(self, name, getter, setter, attribute, settings)
            }
            #[inline]
            pub unsafe fn SetNativeDataProperty(
                &mut self,
                name: root::v8::Local<root::v8::String>,
                getter: root::v8::AccessorGetterCallback,
                setter: root::v8::AccessorSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                settings: root::v8::AccessControl,
                getter_side_effect_type: root::v8::SideEffectType,
            ) {
                Template_SetNativeDataProperty(
                    self,
                    name,
                    getter,
                    setter,
                    data,
                    attribute,
                    signature,
                    settings,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn SetNativeDataProperty1(
                &mut self,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                settings: root::v8::AccessControl,
                getter_side_effect_type: root::v8::SideEffectType,
            ) {
                Template_SetNativeDataProperty1(
                    self,
                    name,
                    getter,
                    setter,
                    data,
                    attribute,
                    signature,
                    settings,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn SetLazyDataProperty(
                &mut self,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                data: root::v8::Local<root::v8::Value>,
                attribute: root::v8::PropertyAttribute,
                getter_side_effect_type: root::v8::SideEffectType,
            ) {
                Template_SetLazyDataProperty(
                    self,
                    name,
                    getter,
                    data,
                    attribute,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn SetIntrinsicDataProperty(
                &mut self,
                name: root::v8::Local<root::v8::Name>,
                intrinsic: root::v8::Intrinsic,
                attribute: root::v8::PropertyAttribute,
            ) {
                Template_SetIntrinsicDataProperty(self, name, intrinsic, attribute)
            }
        }
        /// Interceptor for get requests on an object.
        ///
        /// Use `info.GetReturnValue().Set()` to set the return value of the
        /// intercepted get request.
        ///
        /// \param property The name of the property for which the request was
        /// intercepted.
        /// \param info Information about the intercepted request, such as
        /// isolate, receiver, return value, or whether running in `'use strict`' mode.
        /// See `PropertyCallbackInfo`.
        ///
        /// \code
        /// void GetterCallback(
        /// Local<Name> name,
        /// const v8::PropertyCallbackInfo<v8::Value>& info) {
        /// info.GetReturnValue().Set(v8_num(42));
        /// }
        ///
        /// v8::Local<v8::FunctionTemplate> templ =
        /// v8::FunctionTemplate::New(isolate);
        /// templ->InstanceTemplate()->SetHandler(
        /// v8::NamedPropertyHandlerConfiguration(GetterCallback));
        /// LocalContext env;
        /// env->Global()
        /// ->Set(env.local(), v8_str("obj"), templ->GetFunction(env.local())
        /// .ToLocalChecked()
        /// ->NewInstance(env.local())
        /// .ToLocalChecked())
        /// .FromJust();
        /// v8::Local<v8::Value> result = CompileRun("obj.a = 17; obj.a");
        /// CHECK(v8_num(42)->Equals(env.local(), result).FromJust());
        /// \endcode
        ///
        /// See also `ObjectTemplate::SetHandler`.
        pub type GenericNamedPropertyGetterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// Interceptor for set requests on an object.
        ///
        /// Use `info.GetReturnValue()` to indicate whether the request was intercepted
        /// or not. If the setter successfully intercepts the request, i.e., if the
        /// request should not be further executed, call
        /// `info.GetReturnValue().Set(value)`. If the setter
        /// did not intercept the request, i.e., if the request should be handled as
        /// if no interceptor is present, do not not call `Set()`.
        ///
        /// \param property The name of the property for which the request was
        /// intercepted.
        /// \param value The value which the property will have if the request
        /// is not intercepted.
        /// \param info Information about the intercepted request, such as
        /// isolate, receiver, return value, or whether running in `'use strict'` mode.
        /// See `PropertyCallbackInfo`.
        ///
        /// See also
        /// `ObjectTemplate::SetHandler.`
        pub type GenericNamedPropertySetterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                value: root::v8::Local<root::v8::Value>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// Intercepts all requests that query the attributes of the
        /// property, e.g., getOwnPropertyDescriptor(), propertyIsEnumerable(), and
        /// defineProperty().
        ///
        /// Use `info.GetReturnValue().Set(value)` to set the property attributes. The
        /// value is an integer encoding a `v8::PropertyAttribute`.
        ///
        /// \param property The name of the property for which the request was
        /// intercepted.
        /// \param info Information about the intercepted request, such as
        /// isolate, receiver, return value, or whether running in `'use strict'` mode.
        /// See `PropertyCallbackInfo`.
        ///
        /// \note Some functions query the property attributes internally, even though
        /// they do not return the attributes. For example, `hasOwnProperty()` can
        /// trigger this interceptor depending on the state of the object.
        ///
        /// See also
        /// `ObjectTemplate::SetHandler.`
        pub type GenericNamedPropertyQueryCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// Interceptor for delete requests on an object.
        ///
        /// Use `info.GetReturnValue()` to indicate whether the request was intercepted
        /// or not. If the deleter successfully intercepts the request, i.e., if the
        /// request should not be further executed, call
        /// `info.GetReturnValue().Set(value)` with a boolean `value`. The `value` is
        /// used as the return value of `delete`.
        ///
        /// \param property The name of the property for which the request was
        /// intercepted.
        /// \param info Information about the intercepted request, such as
        /// isolate, receiver, return value, or whether running in `'use strict'` mode.
        /// See `PropertyCallbackInfo`.
        ///
        /// \note If you need to mimic the behavior of `delete`, i.e., throw in strict
        /// mode instead of returning false, use `info.ShouldThrowOnError()` to determine
        /// if you are in strict mode.
        ///
        /// See also `ObjectTemplate::SetHandler.`
        pub type GenericNamedPropertyDeleterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// Returns an array containing the names of the properties the named
        /// property getter intercepts.
        ///
        /// Note: The values in the array must be of type v8::Name.
        pub type GenericNamedPropertyEnumeratorCallback = ::std::option::Option<
            unsafe extern "C" fn(info: *const root::v8::PropertyCallbackInfo),
        >;
        /// Interceptor for defineProperty requests on an object.
        ///
        /// Use `info.GetReturnValue()` to indicate whether the request was intercepted
        /// or not. If the definer successfully intercepts the request, i.e., if the
        /// request should not be further executed, call
        /// `info.GetReturnValue().Set(value)`. If the definer
        /// did not intercept the request, i.e., if the request should be handled as
        /// if no interceptor is present, do not not call `Set()`.
        ///
        /// \param property The name of the property for which the request was
        /// intercepted.
        /// \param desc The property descriptor which is used to define the
        /// property if the request is not intercepted.
        /// \param info Information about the intercepted request, such as
        /// isolate, receiver, return value, or whether running in `'use strict'` mode.
        /// See `PropertyCallbackInfo`.
        ///
        /// See also `ObjectTemplate::SetHandler`.
        pub type GenericNamedPropertyDefinerCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                desc: *const root::v8::PropertyDescriptor,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// Interceptor for getOwnPropertyDescriptor requests on an object.
        ///
        /// Use `info.GetReturnValue().Set()` to set the return value of the
        /// intercepted request. The return value must be an object that
        /// can be converted to a PropertyDescriptor, e.g., a `v8::value` returned from
        /// `v8::Object::getOwnPropertyDescriptor`.
        ///
        /// \param property The name of the property for which the request was
        /// intercepted.
        /// \info Information about the intercepted request, such as
        /// isolate, receiver, return value, or whether running in `'use strict'` mode.
        /// See `PropertyCallbackInfo`.
        ///
        /// \note If GetOwnPropertyDescriptor is intercepted, it will
        /// always return true, i.e., indicate that the property was found.
        ///
        /// See also `ObjectTemplate::SetHandler`.
        pub type GenericNamedPropertyDescriptorCallback = ::std::option::Option<
            unsafe extern "C" fn(
                property: root::v8::Local<root::v8::Name>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// See `v8::GenericNamedPropertyGetterCallback`.
        pub type IndexedPropertyGetterCallback = ::std::option::Option<
            unsafe extern "C" fn(index: u32, info: *const root::v8::PropertyCallbackInfo),
        >;
        /// See `v8::GenericNamedPropertySetterCallback`.
        pub type IndexedPropertySetterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                index: u32,
                value: root::v8::Local<root::v8::Value>,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// See `v8::GenericNamedPropertyQueryCallback`.
        pub type IndexedPropertyQueryCallback = ::std::option::Option<
            unsafe extern "C" fn(index: u32, info: *const root::v8::PropertyCallbackInfo),
        >;
        /// See `v8::GenericNamedPropertyDeleterCallback`.
        pub type IndexedPropertyDeleterCallback = ::std::option::Option<
            unsafe extern "C" fn(index: u32, info: *const root::v8::PropertyCallbackInfo),
        >;
        /// Returns an array containing the indices of the properties the indexed
        /// property getter intercepts.
        ///
        /// Note: The values in the array must be uint32_t.
        pub type IndexedPropertyEnumeratorCallback = ::std::option::Option<
            unsafe extern "C" fn(info: *const root::v8::PropertyCallbackInfo),
        >;
        /// See `v8::GenericNamedPropertyDefinerCallback`.
        pub type IndexedPropertyDefinerCallback = ::std::option::Option<
            unsafe extern "C" fn(
                index: u32,
                desc: *const root::v8::PropertyDescriptor,
                info: *const root::v8::PropertyCallbackInfo,
            ),
        >;
        /// See `v8::GenericNamedPropertyDescriptorCallback`.
        pub type IndexedPropertyDescriptorCallback = ::std::option::Option<
            unsafe extern "C" fn(index: u32, info: *const root::v8::PropertyCallbackInfo),
        >;
        pub const AccessType_ACCESS_GET: root::v8::AccessType = 0;
        pub const AccessType_ACCESS_SET: root::v8::AccessType = 1;
        pub const AccessType_ACCESS_HAS: root::v8::AccessType = 2;
        pub const AccessType_ACCESS_DELETE: root::v8::AccessType = 3;
        pub const AccessType_ACCESS_KEYS: root::v8::AccessType = 4;
        /// Access type specification.
        pub type AccessType = i32;
        /// Returns true if the given context should be allowed to access the given
        /// object.
        pub type AccessCheckCallback = ::std::option::Option<
            unsafe extern "C" fn(
                accessing_context: root::v8::Local<root::v8::Context>,
                accessed_object: root::v8::Local<root::v8::Object>,
                data: root::v8::Local<root::v8::Value>,
            ) -> bool,
        >;
        /// A FunctionTemplate is used to create functions at runtime. There
        /// can only be one function created from a FunctionTemplate in a
        /// context.  The lifetime of the created function is equal to the
        /// lifetime of the context.  So in case the embedder needs to create
        /// temporary functions that can be collected using Scripts is
        /// preferred.
        ///
        /// Any modification of a FunctionTemplate after first instantiation will trigger
        /// a crash.
        ///
        /// A FunctionTemplate can have properties, these properties are added to the
        /// function object when it is created.
        ///
        /// A FunctionTemplate has a corresponding instance template which is
        /// used to create object instances when the function is used as a
        /// constructor. Properties added to the instance template are added to
        /// each object instance.
        ///
        /// A FunctionTemplate can have a prototype template. The prototype template
        /// is used to create the prototype object of the function.
        ///
        /// The following example shows how to use a FunctionTemplate:
        ///
        /// \code
        /// v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate);
        /// t->Set(isolate, "func_property", v8::Number::New(isolate, 1));
        ///
        /// v8::Local<v8::Template> proto_t = t->PrototypeTemplate();
        /// proto_t->Set(isolate,
        /// "proto_method",
        /// v8::FunctionTemplate::New(isolate, InvokeCallback));
        /// proto_t->Set(isolate, "proto_const", v8::Number::New(isolate, 2));
        ///
        /// v8::Local<v8::ObjectTemplate> instance_t = t->InstanceTemplate();
        /// instance_t->SetAccessor(String::NewFromUtf8(isolate, "instance_accessor"),
        /// InstanceAccessorCallback);
        /// instance_t->SetHandler(
        /// NamedPropertyHandlerConfiguration(PropertyHandlerCallback));
        /// instance_t->Set(String::NewFromUtf8(isolate, "instance_property"),
        /// Number::New(isolate, 3));
        ///
        /// v8::Local<v8::Function> function = t->GetFunction();
        /// v8::Local<v8::Object> instance = function->NewInstance();
        /// \endcode
        ///
        /// Let's use "function" as the JS variable name of the function object
        /// and "instance" for the instance object created above.  The function
        /// and the instance will have the following properties:
        ///
        /// \code
        /// func_property in function == true;
        /// function.func_property == 1;
        ///
        /// function.prototype.proto_method() invokes 'InvokeCallback'
        /// function.prototype.proto_const == 2;
        ///
        /// instance instanceof function == true;
        /// instance.instance_accessor calls 'InstanceAccessorCallback'
        /// instance.instance_property == 3;
        /// \endcode
        ///
        /// A FunctionTemplate can inherit from another one by calling the
        /// FunctionTemplate::Inherit method.  The following graph illustrates
        /// the semantics of inheritance:
        ///
        /// \code
        /// FunctionTemplate Parent  -> Parent() . prototype -> { }
        /// ^                                                  ^
        /// | Inherit(Parent)                                  | .__proto__
        /// |                                                  |
        /// FunctionTemplate Child   -> Child()  . prototype -> { }
        /// \endcode
        ///
        /// A FunctionTemplate 'Child' inherits from 'Parent', the prototype
        /// object of the Child() function has __proto__ pointing to the
        /// Parent() function's prototype object. An instance of the Child
        /// function has all properties on Parent's instance templates.
        ///
        /// Let Parent be the FunctionTemplate initialized in the previous
        /// section and create a Child FunctionTemplate by:
        ///
        /// \code
        /// Local<FunctionTemplate> parent = t;
        /// Local<FunctionTemplate> child = FunctionTemplate::New();
        /// child->Inherit(parent);
        ///
        /// Local<Function> child_function = child->GetFunction();
        /// Local<Object> child_instance = child_function->NewInstance();
        /// \endcode
        ///
        /// The Child function and Child instance will have the following
        /// properties:
        ///
        /// \code
        /// child_func.prototype.__proto__ == function.prototype;
        /// child_instance.instance_accessor calls 'InstanceAccessorCallback'
        /// child_instance.instance_property == 3;
        /// \endcode
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct FunctionTemplate {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FunctionTemplate() {
            assert_eq!(
                ::std::mem::size_of::<FunctionTemplate>(),
                1usize,
                concat!("Size of: ", stringify!(FunctionTemplate))
            );
            assert_eq!(
                ::std::mem::align_of::<FunctionTemplate>(),
                1usize,
                concat!("Alignment of ", stringify!(FunctionTemplate))
            );
        }
        extern "C" {
            /// Creates a function template.
            #[link_name = "\u{1}?New@FunctionTemplate@v8@@SA?AV?$Local@VFunctionTemplate@v8@@@2@PEAVIsolate@2@P6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@V?$Local@VSignature@v8@@@2@HW4ConstructorBehavior@2@W4SideEffectType@2@@Z"]
            pub fn FunctionTemplate_New(
                isolate: *mut root::v8::Isolate,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                signature: root::v8::Local<root::v8::Signature>,
                length: ::std::os::raw::c_int,
                behavior: root::v8::ConstructorBehavior,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Local<root::v8::FunctionTemplate>;
        }
        extern "C" {
            /// Get a template included in the snapshot by index.
            #[link_name = "\u{1}?FromSnapshot@FunctionTemplate@v8@@SA?AV?$MaybeLocal@VFunctionTemplate@v8@@@2@PEAVIsolate@2@_K@Z"]
            pub fn FunctionTemplate_FromSnapshot(
                isolate: *mut root::v8::Isolate,
                index: usize,
            ) -> root::v8::MaybeLocal<root::v8::FunctionTemplate>;
        }
        extern "C" {
            /// Creates a function template backed/cached by a private property.
            #[link_name = "\u{1}?NewWithCache@FunctionTemplate@v8@@SA?AV?$Local@VFunctionTemplate@v8@@@2@PEAVIsolate@2@P6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VPrivate@v8@@@2@V?$Local@VValue@v8@@@2@V?$Local@VSignature@v8@@@2@HW4SideEffectType@2@@Z"]
            pub fn FunctionTemplate_NewWithCache(
                isolate: *mut root::v8::Isolate,
                callback: root::v8::FunctionCallback,
                cache_property: root::v8::Local<root::v8::Private>,
                data: root::v8::Local<root::v8::Value>,
                signature: root::v8::Local<root::v8::Signature>,
                length: ::std::os::raw::c_int,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Local<root::v8::FunctionTemplate>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetFunction@FunctionTemplate@v8@@QEAA?AV?$Local@VFunction@v8@@@2@XZ"]
            pub fn FunctionTemplate_GetFunction(
                this: *mut root::v8::FunctionTemplate,
            ) -> root::v8::Local<root::v8::Function>;
        }
        extern "C" {
            #[link_name = "\u{1}?GetFunction@FunctionTemplate@v8@@QEAA?AV?$MaybeLocal@VFunction@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn FunctionTemplate_GetFunction1(
                this: *mut root::v8::FunctionTemplate,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Function>;
        }
        extern "C" {
            /// Similar to Context::NewRemoteContext, this creates an instance that
            /// isn't backed by an actual object.
            ///
            /// The InstanceTemplate of this FunctionTemplate must have access checks with
            /// handlers installed.
            #[link_name = "\u{1}?NewRemoteInstance@FunctionTemplate@v8@@QEAA?AV?$MaybeLocal@VObject@v8@@@2@XZ"]
            pub fn FunctionTemplate_NewRemoteInstance(
                this: *mut root::v8::FunctionTemplate,
            ) -> root::v8::MaybeLocal<root::v8::Object>;
        }
        extern "C" {
            /// Set the call-handler callback for a FunctionTemplate.  This
            /// callback is called whenever the function created from this
            /// FunctionTemplate is called.
            #[link_name = "\u{1}?SetCallHandler@FunctionTemplate@v8@@QEAAXP6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@W4SideEffectType@2@@Z"]
            pub fn FunctionTemplate_SetCallHandler(
                this: *mut root::v8::FunctionTemplate,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                side_effect_type: root::v8::SideEffectType,
            );
        }
        extern "C" {
            /// Set the predefined length property for the FunctionTemplate.
            #[link_name = "\u{1}?SetLength@FunctionTemplate@v8@@QEAAXH@Z"]
            pub fn FunctionTemplate_SetLength(
                this: *mut root::v8::FunctionTemplate,
                length: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            /// Get the InstanceTemplate.
            #[link_name = "\u{1}?InstanceTemplate@FunctionTemplate@v8@@QEAA?AV?$Local@VObjectTemplate@v8@@@2@XZ"]
            pub fn FunctionTemplate_InstanceTemplate(
                this: *mut root::v8::FunctionTemplate,
            ) -> root::v8::Local<root::v8::ObjectTemplate>;
        }
        extern "C" {
            /// Causes the function template to inherit from a parent function template.
            /// This means the function's prototype.__proto__ is set to the parent
            /// function's prototype.
            #[link_name = "\u{1}?Inherit@FunctionTemplate@v8@@QEAAXV?$Local@VFunctionTemplate@v8@@@2@@Z"]
            pub fn FunctionTemplate_Inherit(
                this: *mut root::v8::FunctionTemplate,
                parent: root::v8::Local<root::v8::FunctionTemplate>,
            );
        }
        extern "C" {
            /// A PrototypeTemplate is the template used to create the prototype object
            /// of the function created by this template.
            #[link_name = "\u{1}?PrototypeTemplate@FunctionTemplate@v8@@QEAA?AV?$Local@VObjectTemplate@v8@@@2@XZ"]
            pub fn FunctionTemplate_PrototypeTemplate(
                this: *mut root::v8::FunctionTemplate,
            ) -> root::v8::Local<root::v8::ObjectTemplate>;
        }
        extern "C" {
            /// A PrototypeProviderTemplate is another function template whose prototype
            /// property is used for this template. This is mutually exclusive with setting
            /// a prototype template indirectly by calling PrototypeTemplate() or using
            /// Inherit().
            #[link_name = "\u{1}?SetPrototypeProviderTemplate@FunctionTemplate@v8@@QEAAXV?$Local@VFunctionTemplate@v8@@@2@@Z"]
            pub fn FunctionTemplate_SetPrototypeProviderTemplate(
                this: *mut root::v8::FunctionTemplate,
                prototype_provider: root::v8::Local<root::v8::FunctionTemplate>,
            );
        }
        extern "C" {
            /// Set the class name of the FunctionTemplate.  This is used for
            /// printing objects created with the function created from the
            /// FunctionTemplate as its constructor.
            #[link_name = "\u{1}?SetClassName@FunctionTemplate@v8@@QEAAXV?$Local@VString@v8@@@2@@Z"]
            pub fn FunctionTemplate_SetClassName(
                this: *mut root::v8::FunctionTemplate,
                name: root::v8::Local<root::v8::String>,
            );
        }
        extern "C" {
            /// When set to true, no access check will be performed on the receiver of a
            /// function call.  Currently defaults to true, but this is subject to change.
            #[link_name = "\u{1}?SetAcceptAnyReceiver@FunctionTemplate@v8@@QEAAX_N@Z"]
            pub fn FunctionTemplate_SetAcceptAnyReceiver(
                this: *mut root::v8::FunctionTemplate,
                value: bool,
            );
        }
        extern "C" {
            /// Determines whether the __proto__ accessor ignores instances of
            /// the function template.  If instances of the function template are
            /// ignored, __proto__ skips all instances and instead returns the
            /// next object in the prototype chain.
            ///
            /// Call with a value of true to make the __proto__ accessor ignore
            /// instances of the function template.  Call with a value of false
            /// to make the __proto__ accessor not ignore instances of the
            /// function template.  By default, instances of a function template
            /// are not ignored.
            #[link_name = "\u{1}?SetHiddenPrototype@FunctionTemplate@v8@@QEAAX_N@Z"]
            pub fn FunctionTemplate_SetHiddenPrototype(
                this: *mut root::v8::FunctionTemplate,
                value: bool,
            );
        }
        extern "C" {
            /// Sets the ReadOnly flag in the attributes of the 'prototype' property
            /// of functions created from this FunctionTemplate to true.
            #[link_name = "\u{1}?ReadOnlyPrototype@FunctionTemplate@v8@@QEAAXXZ"]
            pub fn FunctionTemplate_ReadOnlyPrototype(this: *mut root::v8::FunctionTemplate);
        }
        extern "C" {
            /// Removes the prototype property from functions created from this
            /// FunctionTemplate.
            #[link_name = "\u{1}?RemovePrototype@FunctionTemplate@v8@@QEAAXXZ"]
            pub fn FunctionTemplate_RemovePrototype(this: *mut root::v8::FunctionTemplate);
        }
        extern "C" {
            /// Returns true if the given object is an instance of this function
            /// template.
            #[link_name = "\u{1}?HasInstance@FunctionTemplate@v8@@QEAA_NV?$Local@VValue@v8@@@2@@Z"]
            pub fn FunctionTemplate_HasInstance(
                this: *mut root::v8::FunctionTemplate,
                object: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        impl FunctionTemplate {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                signature: root::v8::Local<root::v8::Signature>,
                length: ::std::os::raw::c_int,
                behavior: root::v8::ConstructorBehavior,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Local<root::v8::FunctionTemplate> {
                FunctionTemplate_New(
                    isolate,
                    callback,
                    data,
                    signature,
                    length,
                    behavior,
                    side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn FromSnapshot(
                isolate: *mut root::v8::Isolate,
                index: usize,
            ) -> root::v8::MaybeLocal<root::v8::FunctionTemplate> {
                FunctionTemplate_FromSnapshot(isolate, index)
            }
            #[inline]
            pub unsafe fn NewWithCache(
                isolate: *mut root::v8::Isolate,
                callback: root::v8::FunctionCallback,
                cache_property: root::v8::Local<root::v8::Private>,
                data: root::v8::Local<root::v8::Value>,
                signature: root::v8::Local<root::v8::Signature>,
                length: ::std::os::raw::c_int,
                side_effect_type: root::v8::SideEffectType,
            ) -> root::v8::Local<root::v8::FunctionTemplate> {
                FunctionTemplate_NewWithCache(
                    isolate,
                    callback,
                    cache_property,
                    data,
                    signature,
                    length,
                    side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn GetFunction(&mut self) -> root::v8::Local<root::v8::Function> {
                FunctionTemplate_GetFunction(self)
            }
            #[inline]
            pub unsafe fn GetFunction1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Function> {
                FunctionTemplate_GetFunction1(self, context)
            }
            #[inline]
            pub unsafe fn NewRemoteInstance(&mut self) -> root::v8::MaybeLocal<root::v8::Object> {
                FunctionTemplate_NewRemoteInstance(self)
            }
            #[inline]
            pub unsafe fn SetCallHandler(
                &mut self,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
                side_effect_type: root::v8::SideEffectType,
            ) {
                FunctionTemplate_SetCallHandler(self, callback, data, side_effect_type)
            }
            #[inline]
            pub unsafe fn SetLength(&mut self, length: ::std::os::raw::c_int) {
                FunctionTemplate_SetLength(self, length)
            }
            #[inline]
            pub unsafe fn InstanceTemplate(&mut self) -> root::v8::Local<root::v8::ObjectTemplate> {
                FunctionTemplate_InstanceTemplate(self)
            }
            #[inline]
            pub unsafe fn Inherit(&mut self, parent: root::v8::Local<root::v8::FunctionTemplate>) {
                FunctionTemplate_Inherit(self, parent)
            }
            #[inline]
            pub unsafe fn PrototypeTemplate(
                &mut self,
            ) -> root::v8::Local<root::v8::ObjectTemplate> {
                FunctionTemplate_PrototypeTemplate(self)
            }
            #[inline]
            pub unsafe fn SetPrototypeProviderTemplate(
                &mut self,
                prototype_provider: root::v8::Local<root::v8::FunctionTemplate>,
            ) {
                FunctionTemplate_SetPrototypeProviderTemplate(self, prototype_provider)
            }
            #[inline]
            pub unsafe fn SetClassName(&mut self, name: root::v8::Local<root::v8::String>) {
                FunctionTemplate_SetClassName(self, name)
            }
            #[inline]
            pub unsafe fn SetAcceptAnyReceiver(&mut self, value: bool) {
                FunctionTemplate_SetAcceptAnyReceiver(self, value)
            }
            #[inline]
            pub unsafe fn SetHiddenPrototype(&mut self, value: bool) {
                FunctionTemplate_SetHiddenPrototype(self, value)
            }
            #[inline]
            pub unsafe fn ReadOnlyPrototype(&mut self) {
                FunctionTemplate_ReadOnlyPrototype(self)
            }
            #[inline]
            pub unsafe fn RemovePrototype(&mut self) {
                FunctionTemplate_RemovePrototype(self)
            }
            #[inline]
            pub unsafe fn HasInstance(&mut self, object: root::v8::Local<root::v8::Value>) -> bool {
                FunctionTemplate_HasInstance(self, object)
            }
        }
        /// None.
        pub const PropertyHandlerFlags_kNone: root::v8::PropertyHandlerFlags = 0;
        /// See ALL_CAN_READ above.
        pub const PropertyHandlerFlags_kAllCanRead: root::v8::PropertyHandlerFlags = 1;
        /// Will not call into interceptor for properties on the receiver or prototype
        /// chain, i.e., only call into interceptor for properties that do not exist.
        /// Currently only valid for named interceptors.
        pub const PropertyHandlerFlags_kNonMasking: root::v8::PropertyHandlerFlags = 2;
        /// Will not call into interceptor for symbol lookup.  Only meaningful for
        /// named interceptors.
        pub const PropertyHandlerFlags_kOnlyInterceptStrings: root::v8::PropertyHandlerFlags = 4;
        /// The getter, query, enumerator callbacks do not produce side effects.
        pub const PropertyHandlerFlags_kHasNoSideEffect: root::v8::PropertyHandlerFlags = 8;
        /// Configuration flags for v8::NamedPropertyHandlerConfiguration or
        /// v8::IndexedPropertyHandlerConfiguration.
        pub type PropertyHandlerFlags = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct NamedPropertyHandlerConfiguration {
            pub getter: root::v8::GenericNamedPropertyGetterCallback,
            pub setter: root::v8::GenericNamedPropertySetterCallback,
            pub query: root::v8::GenericNamedPropertyQueryCallback,
            pub deleter: root::v8::GenericNamedPropertyDeleterCallback,
            pub enumerator: root::v8::GenericNamedPropertyEnumeratorCallback,
            pub definer: root::v8::GenericNamedPropertyDefinerCallback,
            pub descriptor: root::v8::GenericNamedPropertyDescriptorCallback,
            pub data: root::v8::Local<root::v8::Value>,
            pub flags: root::v8::PropertyHandlerFlags,
        }
        #[test]
        fn bindgen_test_layout_NamedPropertyHandlerConfiguration() {
            assert_eq!(
                ::std::mem::size_of::<NamedPropertyHandlerConfiguration>(),
                72usize,
                concat!("Size of: ", stringify!(NamedPropertyHandlerConfiguration))
            );
            assert_eq!(
                ::std::mem::align_of::<NamedPropertyHandlerConfiguration>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(NamedPropertyHandlerConfiguration)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).getter as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(getter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).setter as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(setter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).query as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(query)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).deleter
                        as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(deleter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).enumerator
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(enumerator)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).definer
                        as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(definer)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).descriptor
                        as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(descriptor)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).data as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NamedPropertyHandlerConfiguration>())).flags as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NamedPropertyHandlerConfiguration),
                    "::",
                    stringify!(flags)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct IndexedPropertyHandlerConfiguration {
            pub getter: root::v8::IndexedPropertyGetterCallback,
            pub setter: root::v8::IndexedPropertySetterCallback,
            pub query: root::v8::IndexedPropertyQueryCallback,
            pub deleter: root::v8::IndexedPropertyDeleterCallback,
            pub enumerator: root::v8::IndexedPropertyEnumeratorCallback,
            pub definer: root::v8::IndexedPropertyDefinerCallback,
            pub descriptor: root::v8::IndexedPropertyDescriptorCallback,
            pub data: root::v8::Local<root::v8::Value>,
            pub flags: root::v8::PropertyHandlerFlags,
        }
        #[test]
        fn bindgen_test_layout_IndexedPropertyHandlerConfiguration() {
            assert_eq!(
                ::std::mem::size_of::<IndexedPropertyHandlerConfiguration>(),
                72usize,
                concat!("Size of: ", stringify!(IndexedPropertyHandlerConfiguration))
            );
            assert_eq!(
                ::std::mem::align_of::<IndexedPropertyHandlerConfiguration>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(IndexedPropertyHandlerConfiguration)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).getter
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(getter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).setter
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(setter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).query
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(query)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).deleter
                        as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(deleter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).enumerator
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(enumerator)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).definer
                        as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(definer)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).descriptor
                        as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(descriptor)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).data as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<IndexedPropertyHandlerConfiguration>())).flags
                        as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IndexedPropertyHandlerConfiguration),
                    "::",
                    stringify!(flags)
                )
            );
        }
        /// An ObjectTemplate is used to create objects at runtime.
        ///
        /// Properties added to an ObjectTemplate are added to each object
        /// created from the ObjectTemplate.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ObjectTemplate {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_ObjectTemplate() {
            assert_eq!(
                ::std::mem::size_of::<ObjectTemplate>(),
                1usize,
                concat!("Size of: ", stringify!(ObjectTemplate))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectTemplate>(),
                1usize,
                concat!("Alignment of ", stringify!(ObjectTemplate))
            );
        }
        extern "C" {
            /// Creates an ObjectTemplate.
            #[link_name = "\u{1}?New@ObjectTemplate@v8@@SA?AV?$Local@VObjectTemplate@v8@@@2@PEAVIsolate@2@V?$Local@VFunctionTemplate@v8@@@2@@Z"]
            pub fn ObjectTemplate_New(
                isolate: *mut root::v8::Isolate,
                constructor: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::ObjectTemplate>;
        }
        extern "C" {
            /// Get a template included in the snapshot by index.
            #[link_name = "\u{1}?FromSnapshot@ObjectTemplate@v8@@SA?AV?$MaybeLocal@VObjectTemplate@v8@@@2@PEAVIsolate@2@_K@Z"]
            pub fn ObjectTemplate_FromSnapshot(
                isolate: *mut root::v8::Isolate,
                index: usize,
            ) -> root::v8::MaybeLocal<root::v8::ObjectTemplate>;
        }
        extern "C" {
            #[link_name = "\u{1}?NewInstance@ObjectTemplate@v8@@QEAA?AV?$Local@VObject@v8@@@2@XZ"]
            pub fn ObjectTemplate_NewInstance(
                this: *mut root::v8::ObjectTemplate,
            ) -> root::v8::Local<root::v8::Object>;
        }
        extern "C" {
            #[link_name = "\u{1}?NewInstance@ObjectTemplate@v8@@QEAA?AV?$MaybeLocal@VObject@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn ObjectTemplate_NewInstance1(
                this: *mut root::v8::ObjectTemplate,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Object>;
        }
        extern "C" {
            /// Sets an accessor on the object template.
            ///
            /// Whenever the property with the given name is accessed on objects
            /// created from this ObjectTemplate the getter and setter callbacks
            /// are called instead of getting and setting the property directly
            /// on the JavaScript object.
            ///
            /// \param name The name of the property for which an accessor is added.
            /// \param getter The callback to invoke when getting the property.
            /// \param setter The callback to invoke when setting the property.
            /// \param data A piece of data that will be passed to the getter and setter
            /// callbacks whenever they are invoked.
            /// \param settings Access control settings for the accessor. This is a bit
            /// field consisting of one of more of
            /// DEFAULT = 0, ALL_CAN_READ = 1, or ALL_CAN_WRITE = 2.
            /// The default is to not allow cross-context access.
            /// ALL_CAN_READ means that all cross-context reads are allowed.
            /// ALL_CAN_WRITE means that all cross-context writes are allowed.
            /// The combination ALL_CAN_READ | ALL_CAN_WRITE can be used to allow all
            /// cross-context access.
            /// \param attribute The attributes of the property for which an accessor
            /// is added.
            /// \param signature The signature describes valid receivers for the accessor
            /// and is used to perform implicit instance checks against them. If the
            /// receiver is incompatible (i.e. is not an instance of the constructor as
            /// defined by FunctionTemplate::HasInstance()), an implicit TypeError is
            /// thrown and no callback is invoked.
            #[link_name = "\u{1}?SetAccessor@ObjectTemplate@v8@@QEAAXV?$Local@VString@v8@@@2@P6AX0AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZP6AX0V?$Local@VValue@v8@@@2@AEBV?$PropertyCallbackInfo@X@2@@Z3W4AccessControl@2@W4PropertyAttribute@2@V?$Local@VAccessorSignature@v8@@@2@W4SideEffectType@2@@Z"]
            pub fn ObjectTemplate_SetAccessor(
                this: *mut root::v8::ObjectTemplate,
                name: root::v8::Local<root::v8::String>,
                getter: root::v8::AccessorGetterCallback,
                setter: root::v8::AccessorSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                settings: root::v8::AccessControl,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                getter_side_effect_type: root::v8::SideEffectType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetAccessor@ObjectTemplate@v8@@QEAAXV?$Local@VName@v8@@@2@P6AX0AEBV?$PropertyCallbackInfo@VValue@v8@@@2@@ZP6AX0V?$Local@VValue@v8@@@2@AEBV?$PropertyCallbackInfo@X@2@@Z3W4AccessControl@2@W4PropertyAttribute@2@V?$Local@VAccessorSignature@v8@@@2@W4SideEffectType@2@@Z"]
            pub fn ObjectTemplate_SetAccessor1(
                this: *mut root::v8::ObjectTemplate,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                settings: root::v8::AccessControl,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                getter_side_effect_type: root::v8::SideEffectType,
            );
        }
        extern "C" {
            /// Sets a named property handler on the object template.
            ///
            /// Whenever a property whose name is a string or a symbol is accessed on
            /// objects created from this object template, the provided callback is
            /// invoked instead of accessing the property directly on the JavaScript
            /// object.
            ///
            /// @param configuration The NamedPropertyHandlerConfiguration that defines the
            /// callbacks to invoke when accessing a property.
            #[link_name = "\u{1}?SetHandler@ObjectTemplate@v8@@QEAAXAEBUNamedPropertyHandlerConfiguration@2@@Z"]
            pub fn ObjectTemplate_SetHandler(
                this: *mut root::v8::ObjectTemplate,
                configuration: *const root::v8::NamedPropertyHandlerConfiguration,
            );
        }
        extern "C" {
            /// Sets an indexed property handler on the object template.
            ///
            /// Whenever an indexed property is accessed on objects created from
            /// this object template, the provided callback is invoked instead of
            /// accessing the property directly on the JavaScript object.
            ///
            /// @param configuration The IndexedPropertyHandlerConfiguration that defines
            /// the callbacks to invoke when accessing a property.
            #[link_name = "\u{1}?SetHandler@ObjectTemplate@v8@@QEAAXAEBUIndexedPropertyHandlerConfiguration@2@@Z"]
            pub fn ObjectTemplate_SetHandler1(
                this: *mut root::v8::ObjectTemplate,
                configuration: *const root::v8::IndexedPropertyHandlerConfiguration,
            );
        }
        extern "C" {
            /// Sets the callback to be used when calling instances created from
            /// this template as a function.  If no callback is set, instances
            /// behave like normal JavaScript objects that cannot be called as a
            /// function.
            #[link_name = "\u{1}?SetCallAsFunctionHandler@ObjectTemplate@v8@@QEAAXP6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@@Z"]
            pub fn ObjectTemplate_SetCallAsFunctionHandler(
                this: *mut root::v8::ObjectTemplate,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            /// Mark object instances of the template as undetectable.
            ///
            /// In many ways, undetectable objects behave as though they are not
            /// there.  They behave like 'undefined' in conditionals and when
            /// printed.  However, properties can be accessed and called as on
            /// normal objects.
            #[link_name = "\u{1}?MarkAsUndetectable@ObjectTemplate@v8@@QEAAXXZ"]
            pub fn ObjectTemplate_MarkAsUndetectable(this: *mut root::v8::ObjectTemplate);
        }
        extern "C" {
            /// Sets access check callback on the object template and enables access
            /// checks.
            ///
            /// When accessing properties on instances of this object template,
            /// the access check callback will be called to determine whether or
            /// not to allow cross-context access to the properties.
            #[link_name = "\u{1}?SetAccessCheckCallback@ObjectTemplate@v8@@QEAAXP6A_NV?$Local@VContext@v8@@@2@V?$Local@VObject@v8@@@2@V?$Local@VValue@v8@@@2@@Z2@Z"]
            pub fn ObjectTemplate_SetAccessCheckCallback(
                this: *mut root::v8::ObjectTemplate,
                callback: root::v8::AccessCheckCallback,
                data: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            /// Like SetAccessCheckCallback but invokes an interceptor on failed access
            /// checks instead of looking up all-can-read properties. You can only use
            /// either this method or SetAccessCheckCallback, but not both at the same
            /// time.
            #[link_name = "\u{1}?SetAccessCheckCallbackAndHandler@ObjectTemplate@v8@@QEAAXP6A_NV?$Local@VContext@v8@@@2@V?$Local@VObject@v8@@@2@V?$Local@VValue@v8@@@2@@ZAEBUNamedPropertyHandlerConfiguration@2@AEBUIndexedPropertyHandlerConfiguration@2@2@Z"]
            pub fn ObjectTemplate_SetAccessCheckCallbackAndHandler(
                this: *mut root::v8::ObjectTemplate,
                callback: root::v8::AccessCheckCallback,
                named_handler: *const root::v8::NamedPropertyHandlerConfiguration,
                indexed_handler: *const root::v8::IndexedPropertyHandlerConfiguration,
                data: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            /// Gets the number of internal fields for objects generated from
            /// this template.
            #[link_name = "\u{1}?InternalFieldCount@ObjectTemplate@v8@@QEAAHXZ"]
            pub fn ObjectTemplate_InternalFieldCount(
                this: *mut root::v8::ObjectTemplate,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Sets the number of internal fields for objects generated from
            /// this template.
            #[link_name = "\u{1}?SetInternalFieldCount@ObjectTemplate@v8@@QEAAXH@Z"]
            pub fn ObjectTemplate_SetInternalFieldCount(
                this: *mut root::v8::ObjectTemplate,
                value: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            /// Returns true if the object will be an immutable prototype exotic object.
            #[link_name = "\u{1}?IsImmutableProto@ObjectTemplate@v8@@QEAA_NXZ"]
            pub fn ObjectTemplate_IsImmutableProto(this: *mut root::v8::ObjectTemplate) -> bool;
        }
        extern "C" {
            /// Makes the ObjectTemplate for an immutable prototype exotic object, with an
            /// immutable __proto__.
            #[link_name = "\u{1}?SetImmutableProto@ObjectTemplate@v8@@QEAAXXZ"]
            pub fn ObjectTemplate_SetImmutableProto(this: *mut root::v8::ObjectTemplate);
        }
        impl ObjectTemplate {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                constructor: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::ObjectTemplate> {
                ObjectTemplate_New(isolate, constructor)
            }
            #[inline]
            pub unsafe fn FromSnapshot(
                isolate: *mut root::v8::Isolate,
                index: usize,
            ) -> root::v8::MaybeLocal<root::v8::ObjectTemplate> {
                ObjectTemplate_FromSnapshot(isolate, index)
            }
            #[inline]
            pub unsafe fn NewInstance(&mut self) -> root::v8::Local<root::v8::Object> {
                ObjectTemplate_NewInstance(self)
            }
            #[inline]
            pub unsafe fn NewInstance1(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Object> {
                ObjectTemplate_NewInstance1(self, context)
            }
            #[inline]
            pub unsafe fn SetAccessor(
                &mut self,
                name: root::v8::Local<root::v8::String>,
                getter: root::v8::AccessorGetterCallback,
                setter: root::v8::AccessorSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                settings: root::v8::AccessControl,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                getter_side_effect_type: root::v8::SideEffectType,
            ) {
                ObjectTemplate_SetAccessor(
                    self,
                    name,
                    getter,
                    setter,
                    data,
                    settings,
                    attribute,
                    signature,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn SetAccessor1(
                &mut self,
                name: root::v8::Local<root::v8::Name>,
                getter: root::v8::AccessorNameGetterCallback,
                setter: root::v8::AccessorNameSetterCallback,
                data: root::v8::Local<root::v8::Value>,
                settings: root::v8::AccessControl,
                attribute: root::v8::PropertyAttribute,
                signature: root::v8::Local<root::v8::AccessorSignature>,
                getter_side_effect_type: root::v8::SideEffectType,
            ) {
                ObjectTemplate_SetAccessor1(
                    self,
                    name,
                    getter,
                    setter,
                    data,
                    settings,
                    attribute,
                    signature,
                    getter_side_effect_type,
                )
            }
            #[inline]
            pub unsafe fn SetHandler(
                &mut self,
                configuration: *const root::v8::NamedPropertyHandlerConfiguration,
            ) {
                ObjectTemplate_SetHandler(self, configuration)
            }
            #[inline]
            pub unsafe fn SetHandler1(
                &mut self,
                configuration: *const root::v8::IndexedPropertyHandlerConfiguration,
            ) {
                ObjectTemplate_SetHandler1(self, configuration)
            }
            #[inline]
            pub unsafe fn SetCallAsFunctionHandler(
                &mut self,
                callback: root::v8::FunctionCallback,
                data: root::v8::Local<root::v8::Value>,
            ) {
                ObjectTemplate_SetCallAsFunctionHandler(self, callback, data)
            }
            #[inline]
            pub unsafe fn MarkAsUndetectable(&mut self) {
                ObjectTemplate_MarkAsUndetectable(self)
            }
            #[inline]
            pub unsafe fn SetAccessCheckCallback(
                &mut self,
                callback: root::v8::AccessCheckCallback,
                data: root::v8::Local<root::v8::Value>,
            ) {
                ObjectTemplate_SetAccessCheckCallback(self, callback, data)
            }
            #[inline]
            pub unsafe fn SetAccessCheckCallbackAndHandler(
                &mut self,
                callback: root::v8::AccessCheckCallback,
                named_handler: *const root::v8::NamedPropertyHandlerConfiguration,
                indexed_handler: *const root::v8::IndexedPropertyHandlerConfiguration,
                data: root::v8::Local<root::v8::Value>,
            ) {
                ObjectTemplate_SetAccessCheckCallbackAndHandler(
                    self,
                    callback,
                    named_handler,
                    indexed_handler,
                    data,
                )
            }
            #[inline]
            pub unsafe fn InternalFieldCount(&mut self) -> ::std::os::raw::c_int {
                ObjectTemplate_InternalFieldCount(self)
            }
            #[inline]
            pub unsafe fn SetInternalFieldCount(&mut self, value: ::std::os::raw::c_int) {
                ObjectTemplate_SetInternalFieldCount(self, value)
            }
            #[inline]
            pub unsafe fn IsImmutableProto(&mut self) -> bool {
                ObjectTemplate_IsImmutableProto(self)
            }
            #[inline]
            pub unsafe fn SetImmutableProto(&mut self) {
                ObjectTemplate_SetImmutableProto(self)
            }
        }
        /// A Signature specifies which receiver is valid for a function.
        ///
        /// A receiver matches a given signature if the receiver (or any of its
        /// hidden prototypes) was created from the signature's FunctionTemplate, or
        /// from a FunctionTemplate that inherits directly or indirectly from the
        /// signature's FunctionTemplate.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Signature {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Signature() {
            assert_eq!(
                ::std::mem::size_of::<Signature>(),
                1usize,
                concat!("Size of: ", stringify!(Signature))
            );
            assert_eq!(
                ::std::mem::align_of::<Signature>(),
                1usize,
                concat!("Alignment of ", stringify!(Signature))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@Signature@v8@@SA?AV?$Local@VSignature@v8@@@2@PEAVIsolate@2@V?$Local@VFunctionTemplate@v8@@@2@@Z"]
            pub fn Signature_New(
                isolate: *mut root::v8::Isolate,
                receiver: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::Signature>;
        }
        impl Signature {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                receiver: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::Signature> {
                Signature_New(isolate, receiver)
            }
        }
        /// An AccessorSignature specifies which receivers are valid parameters
        /// to an accessor callback.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct AccessorSignature {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AccessorSignature() {
            assert_eq!(
                ::std::mem::size_of::<AccessorSignature>(),
                1usize,
                concat!("Size of: ", stringify!(AccessorSignature))
            );
            assert_eq!(
                ::std::mem::align_of::<AccessorSignature>(),
                1usize,
                concat!("Alignment of ", stringify!(AccessorSignature))
            );
        }
        extern "C" {
            #[link_name = "\u{1}?New@AccessorSignature@v8@@SA?AV?$Local@VAccessorSignature@v8@@@2@PEAVIsolate@2@V?$Local@VFunctionTemplate@v8@@@2@@Z"]
            pub fn AccessorSignature_New(
                isolate: *mut root::v8::Isolate,
                receiver: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::AccessorSignature>;
        }
        impl AccessorSignature {
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                receiver: root::v8::Local<root::v8::FunctionTemplate>,
            ) -> root::v8::Local<root::v8::AccessorSignature> {
                AccessorSignature_New(isolate, receiver)
            }
        }
        #[repr(C)]
        pub struct Extension__bindgen_vtable(::std::os::raw::c_void);
        /// Ignore
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Extension {
            pub vtable_: *const Extension__bindgen_vtable,
            pub name_: *const ::std::os::raw::c_char,
            pub source_length_: usize,
            pub source_: *mut root::v8::String_ExternalOneByteStringResource,
            pub dep_count_: ::std::os::raw::c_int,
            pub deps_: *mut *const ::std::os::raw::c_char,
            pub auto_enable_: bool,
        }
        #[test]
        fn bindgen_test_layout_Extension() {
            assert_eq!(
                ::std::mem::size_of::<Extension>(),
                56usize,
                concat!("Size of: ", stringify!(Extension))
            );
            assert_eq!(
                ::std::mem::align_of::<Extension>(),
                8usize,
                concat!("Alignment of ", stringify!(Extension))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Extension>())).name_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Extension),
                    "::",
                    stringify!(name_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Extension>())).source_length_ as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Extension),
                    "::",
                    stringify!(source_length_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Extension>())).source_ as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Extension),
                    "::",
                    stringify!(source_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Extension>())).dep_count_ as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Extension),
                    "::",
                    stringify!(dep_count_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Extension>())).deps_ as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Extension),
                    "::",
                    stringify!(deps_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Extension>())).auto_enable_ as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Extension),
                    "::",
                    stringify!(auto_enable_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0Extension@v8@@QEAA@PEBD0HPEAPEBDH@Z"]
            pub fn Extension_Extension(
                this: *mut root::v8::Extension,
                name: *const ::std::os::raw::c_char,
                source: *const ::std::os::raw::c_char,
                dep_count: ::std::os::raw::c_int,
                deps: *mut *const ::std::os::raw::c_char,
                source_length: ::std::os::raw::c_int,
            );
        }
        impl Extension {
            #[inline]
            pub unsafe fn new(
                name: *const ::std::os::raw::c_char,
                source: *const ::std::os::raw::c_char,
                dep_count: ::std::os::raw::c_int,
                deps: *mut *const ::std::os::raw::c_char,
                source_length: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Extension_Extension(
                    &mut __bindgen_tmp,
                    name,
                    source,
                    dep_count,
                    deps,
                    source_length,
                );
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterExtension@v8@@YAXPEAVExtension@1@@Z"]
            pub fn RegisterExtension(extension: *mut root::v8::Extension);
        }
        /// A set of constraints that specifies the limits of the runtime's memory use.
        /// You must set the heap size before initializing the VM - the size cannot be
        /// adjusted after the VM is initialized.
        ///
        /// If you are using threads then you should hold the V8::Locker lock while
        /// setting the stack limit and you must set a non-default stack limit separately
        /// for each thread.
        ///
        /// The arguments for set_max_semi_space_size, set_max_old_space_size,
        /// set_max_executable_size, set_code_range_size specify limits in MB.
        ///
        /// The argument for set_max_semi_space_size_in_kb is in KB.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ResourceConstraints {
            pub max_semi_space_size_in_kb_: usize,
            pub max_old_space_size_: usize,
            pub max_executable_size_: usize,
            pub stack_limit_: *mut u32,
            pub code_range_size_: usize,
            pub max_zone_pool_size_: usize,
        }
        #[test]
        fn bindgen_test_layout_ResourceConstraints() {
            assert_eq!(
                ::std::mem::size_of::<ResourceConstraints>(),
                48usize,
                concat!("Size of: ", stringify!(ResourceConstraints))
            );
            assert_eq!(
                ::std::mem::align_of::<ResourceConstraints>(),
                8usize,
                concat!("Alignment of ", stringify!(ResourceConstraints))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResourceConstraints>())).max_semi_space_size_in_kb_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResourceConstraints),
                    "::",
                    stringify!(max_semi_space_size_in_kb_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResourceConstraints>())).max_old_space_size_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResourceConstraints),
                    "::",
                    stringify!(max_old_space_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResourceConstraints>())).max_executable_size_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResourceConstraints),
                    "::",
                    stringify!(max_executable_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResourceConstraints>())).stack_limit_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResourceConstraints),
                    "::",
                    stringify!(stack_limit_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResourceConstraints>())).code_range_size_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResourceConstraints),
                    "::",
                    stringify!(code_range_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ResourceConstraints>())).max_zone_pool_size_ as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResourceConstraints),
                    "::",
                    stringify!(max_zone_pool_size_)
                )
            );
        }
        extern "C" {
            /// Configures the constraints with reasonable default values based on the
            /// capabilities of the current device the VM is running on.
            ///
            /// \param physical_memory The total amount of physical memory on the current
            /// device, in bytes.
            /// \param virtual_memory_limit The amount of virtual memory on the current
            /// device, in bytes, or zero, if there is no limit.
            #[link_name = "\u{1}?ConfigureDefaults@ResourceConstraints@v8@@QEAAX_K0@Z"]
            pub fn ResourceConstraints_ConfigureDefaults(
                this: *mut root::v8::ResourceConstraints,
                physical_memory: u64,
                virtual_memory_limit: u64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0ResourceConstraints@v8@@QEAA@XZ"]
            pub fn ResourceConstraints_ResourceConstraints(
                this: *mut root::v8::ResourceConstraints,
            );
        }
        impl ResourceConstraints {
            #[inline]
            pub unsafe fn ConfigureDefaults(
                &mut self,
                physical_memory: u64,
                virtual_memory_limit: u64,
            ) {
                ResourceConstraints_ConfigureDefaults(self, physical_memory, virtual_memory_limit)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ResourceConstraints_ResourceConstraints(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        pub type FatalErrorCallback = ::std::option::Option<
            unsafe extern "C" fn(
                location: *const ::std::os::raw::c_char,
                message: *const ::std::os::raw::c_char,
            ),
        >;
        pub type OOMErrorCallback = ::std::option::Option<
            unsafe extern "C" fn(location: *const ::std::os::raw::c_char, is_heap_oom: bool),
        >;
        pub type DcheckErrorCallback = ::std::option::Option<
            unsafe extern "C" fn(
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
                message: *const ::std::os::raw::c_char,
            ),
        >;
        pub type MessageCallback = ::std::option::Option<
            unsafe extern "C" fn(
                message: root::v8::Local<root::v8::Message>,
                data: root::v8::Local<root::v8::Value>,
            ),
        >;
        pub type LogEventCallback = ::std::option::Option<
            unsafe extern "C" fn(name: *const ::std::os::raw::c_char, event: ::std::os::raw::c_int),
        >;
        extern "C" {
            #[link_name = "\u{1}?RangeError@Exception@v8@@SA?AV?$Local@VValue@v8@@@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Exception_RangeError(
                message: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?ReferenceError@Exception@v8@@SA?AV?$Local@VValue@v8@@@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Exception_ReferenceError(
                message: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?SyntaxError@Exception@v8@@SA?AV?$Local@VValue@v8@@@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Exception_SyntaxError(
                message: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?TypeError@Exception@v8@@SA?AV?$Local@VValue@v8@@@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Exception_TypeError(
                message: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            #[link_name = "\u{1}?Error@Exception@v8@@SA?AV?$Local@VValue@v8@@@2@V?$Local@VString@v8@@@2@@Z"]
            pub fn Exception_Error(
                message: root::v8::Local<root::v8::String>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Creates an error message for the given exception.
            /// Will try to reconstruct the original stack trace from the exception value,
            /// or capture the current stack trace if not available.
            #[link_name = "\u{1}?CreateMessage@Exception@v8@@SA?AV?$Local@VMessage@v8@@@2@PEAVIsolate@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Exception_CreateMessage(
                isolate: *mut root::v8::Isolate,
                exception: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::Message>;
        }
        extern "C" {
            /// Returns the original stack trace that was captured at the creation time
            /// of a given exception, or an empty handle if not available.
            #[link_name = "\u{1}?GetStackTrace@Exception@v8@@SA?AV?$Local@VStackTrace@v8@@@2@V?$Local@VValue@v8@@@2@@Z"]
            pub fn Exception_GetStackTrace(
                exception: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::StackTrace>;
        }
        pub type CounterLookupCallback = ::std::option::Option<
            unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_int,
        >;
        pub type CreateHistogramCallback = ::std::option::Option<
            unsafe extern "C" fn(
                name: *const ::std::os::raw::c_char,
                min: ::std::os::raw::c_int,
                max: ::std::os::raw::c_int,
                buckets: usize,
            ) -> *mut ::std::os::raw::c_void,
        >;
        pub type AddHistogramSampleCallback = ::std::option::Option<
            unsafe extern "C" fn(
                histogram: *mut ::std::os::raw::c_void,
                sample: ::std::os::raw::c_int,
            ),
        >;
        pub type BeforeCallEnteredCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::v8::Isolate)>;
        pub type CallCompletedCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::v8::Isolate)>;
        /// HostImportModuleDynamicallyCallback is called when we require the
        /// embedder to load a module. This is used as part of the dynamic
        /// import syntax.
        ///
        /// The referrer contains metadata about the script/module that calls
        /// import.
        ///
        /// The specifier is the name of the module that should be imported.
        ///
        /// The embedder must compile, instantiate, evaluate the Module, and
        /// obtain it's namespace object.
        ///
        /// The Promise returned from this function is forwarded to userland
        /// JavaScript. The embedder must resolve this promise with the module
        /// namespace object. In case of an exception, the embedder must reject
        /// this promise with the exception. If the promise creation itself
        /// fails (e.g. due to stack overflow), the embedder must propagate
        /// that exception by returning an empty MaybeLocal.
        pub type HostImportModuleDynamicallyCallback = ::std::option::Option<
            unsafe extern "C" fn(
                context: root::v8::Local<root::v8::Context>,
                referrer: root::v8::Local<root::v8::ScriptOrModule>,
                specifier: root::v8::Local<root::v8::String>,
            ) -> root::v8::MaybeLocal<root::v8::Promise>,
        >;
        /// HostInitializeImportMetaObjectCallback is called the first time import.meta
        /// is accessed for a module. Subsequent access will reuse the same value.
        ///
        /// The method combines two implementation-defined abstract operations into one:
        /// HostGetImportMetaProperties and HostFinalizeImportMeta.
        ///
        /// The embedder should use v8::Object::CreateDataProperty to add properties on
        /// the meta object.
        pub type HostInitializeImportMetaObjectCallback = ::std::option::Option<
            unsafe extern "C" fn(
                context: root::v8::Local<root::v8::Context>,
                module: root::v8::Local<root::v8::Module>,
                meta: root::v8::Local<root::v8::Object>,
            ),
        >;
        pub const PromiseHookType_kInit: root::v8::PromiseHookType = 0;
        pub const PromiseHookType_kResolve: root::v8::PromiseHookType = 1;
        pub const PromiseHookType_kBefore: root::v8::PromiseHookType = 2;
        pub const PromiseHookType_kAfter: root::v8::PromiseHookType = 3;
        /// PromiseHook with type kInit is called when a new promise is
        /// created. When a new promise is created as part of the chain in the
        /// case of Promise.then or in the intermediate promises created by
        /// Promise.{race, all}/AsyncFunctionAwait, we pass the parent promise
        /// otherwise we pass undefined.
        ///
        /// PromiseHook with type kResolve is called at the beginning of
        /// resolve or reject function defined by CreateResolvingFunctions.
        ///
        /// PromiseHook with type kBefore is called at the beginning of the
        /// PromiseReactionJob.
        ///
        /// PromiseHook with type kAfter is called right at the end of the
        /// PromiseReactionJob.
        pub type PromiseHookType = i32;
        pub type PromiseHook = ::std::option::Option<
            unsafe extern "C" fn(
                type_: root::v8::PromiseHookType,
                promise: root::v8::Local<root::v8::Promise>,
                parent: root::v8::Local<root::v8::Value>,
            ),
        >;
        pub const PromiseRejectEvent_kPromiseRejectWithNoHandler: root::v8::PromiseRejectEvent = 0;
        pub const PromiseRejectEvent_kPromiseHandlerAddedAfterReject: root::v8::PromiseRejectEvent =
            1;
        pub const PromiseRejectEvent_kPromiseRejectAfterResolved: root::v8::PromiseRejectEvent = 2;
        pub const PromiseRejectEvent_kPromiseResolveAfterResolved: root::v8::PromiseRejectEvent = 3;
        pub type PromiseRejectEvent = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct PromiseRejectMessage {
            pub promise_: root::v8::Local<root::v8::Promise>,
            pub event_: root::v8::PromiseRejectEvent,
            pub value_: root::v8::Local<root::v8::Value>,
            pub stack_trace_: root::v8::Local<root::v8::StackTrace>,
        }
        #[test]
        fn bindgen_test_layout_PromiseRejectMessage() {
            assert_eq!(
                ::std::mem::size_of::<PromiseRejectMessage>(),
                32usize,
                concat!("Size of: ", stringify!(PromiseRejectMessage))
            );
            assert_eq!(
                ::std::mem::align_of::<PromiseRejectMessage>(),
                8usize,
                concat!("Alignment of ", stringify!(PromiseRejectMessage))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PromiseRejectMessage>())).promise_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PromiseRejectMessage),
                    "::",
                    stringify!(promise_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PromiseRejectMessage>())).event_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PromiseRejectMessage),
                    "::",
                    stringify!(event_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PromiseRejectMessage>())).value_ as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PromiseRejectMessage),
                    "::",
                    stringify!(value_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PromiseRejectMessage>())).stack_trace_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PromiseRejectMessage),
                    "::",
                    stringify!(stack_trace_)
                )
            );
        }
        pub type PromiseRejectCallback =
            ::std::option::Option<unsafe extern "C" fn(message: root::v8::PromiseRejectMessage)>;
        pub type MicrotasksCompletedCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::v8::Isolate)>;
        pub type MicrotaskCallback =
            ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
        pub const MicrotasksPolicy_kExplicit: root::v8::MicrotasksPolicy = 0;
        pub const MicrotasksPolicy_kScoped: root::v8::MicrotasksPolicy = 1;
        pub const MicrotasksPolicy_kAuto: root::v8::MicrotasksPolicy = 2;
        /// Policy for running microtasks:
        /// - explicit: microtasks are invoked with Isolate::RunMicrotasks() method;
        /// - scoped: microtasks invocation is controlled by MicrotasksScope objects;
        /// - auto: microtasks are invoked when the script call depth decrements
        /// to zero.
        pub type MicrotasksPolicy = i32;
        /// This scope is used to control microtasks when kScopeMicrotasksInvocation
        /// is used on Isolate. In this mode every non-primitive call to V8 should be
        /// done inside some MicrotasksScope.
        /// Microtasks are executed when topmost MicrotasksScope marked as kRunMicrotasks
        /// exits.
        /// kDoNotRunMicrotasks should be used to annotate calls not intended to trigger
        /// microtasks.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct MicrotasksScope {
            pub isolate_: *mut root::v8::internal::Isolate,
            pub run_: bool,
        }
        pub const MicrotasksScope_Type_kRunMicrotasks: root::v8::MicrotasksScope_Type = 0;
        pub const MicrotasksScope_Type_kDoNotRunMicrotasks: root::v8::MicrotasksScope_Type = 1;
        pub type MicrotasksScope_Type = i32;
        #[test]
        fn bindgen_test_layout_MicrotasksScope() {
            assert_eq!(
                ::std::mem::size_of::<MicrotasksScope>(),
                16usize,
                concat!("Size of: ", stringify!(MicrotasksScope))
            );
            assert_eq!(
                ::std::mem::align_of::<MicrotasksScope>(),
                8usize,
                concat!("Alignment of ", stringify!(MicrotasksScope))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<MicrotasksScope>())).isolate_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MicrotasksScope),
                    "::",
                    stringify!(isolate_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MicrotasksScope>())).run_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MicrotasksScope),
                    "::",
                    stringify!(run_)
                )
            );
        }
        extern "C" {
            /// Runs microtasks if no kRunMicrotasks scope is currently active.
            #[link_name = "\u{1}?PerformCheckpoint@MicrotasksScope@v8@@SAXPEAVIsolate@2@@Z"]
            pub fn MicrotasksScope_PerformCheckpoint(isolate: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Returns current depth of nested kRunMicrotasks scopes.
            #[link_name = "\u{1}?GetCurrentDepth@MicrotasksScope@v8@@SAHPEAVIsolate@2@@Z"]
            pub fn MicrotasksScope_GetCurrentDepth(
                isolate: *mut root::v8::Isolate,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Returns true while microtasks are being executed.
            #[link_name = "\u{1}?IsRunningMicrotasks@MicrotasksScope@v8@@SA_NPEAVIsolate@2@@Z"]
            pub fn MicrotasksScope_IsRunningMicrotasks(isolate: *mut root::v8::Isolate) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0MicrotasksScope@v8@@QEAA@PEAVIsolate@1@W4Type@01@@Z"]
            pub fn MicrotasksScope_MicrotasksScope(
                this: *mut root::v8::MicrotasksScope,
                isolate: *mut root::v8::Isolate,
                type_: root::v8::MicrotasksScope_Type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DMicrotasksScope@v8@@QEAAXXZ"]
            pub fn MicrotasksScope_MicrotasksScope_destructor(this: *mut root::v8::MicrotasksScope);
        }
        impl MicrotasksScope {
            #[inline]
            pub unsafe fn PerformCheckpoint(isolate: *mut root::v8::Isolate) {
                MicrotasksScope_PerformCheckpoint(isolate)
            }
            #[inline]
            pub unsafe fn GetCurrentDepth(
                isolate: *mut root::v8::Isolate,
            ) -> ::std::os::raw::c_int {
                MicrotasksScope_GetCurrentDepth(isolate)
            }
            #[inline]
            pub unsafe fn IsRunningMicrotasks(isolate: *mut root::v8::Isolate) -> bool {
                MicrotasksScope_IsRunningMicrotasks(isolate)
            }
            #[inline]
            pub unsafe fn new(
                isolate: *mut root::v8::Isolate,
                type_: root::v8::MicrotasksScope_Type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                MicrotasksScope_MicrotasksScope(&mut __bindgen_tmp, isolate, type_);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                MicrotasksScope_MicrotasksScope_destructor(self)
            }
        }
        pub type FailedAccessCheckCallback = ::std::option::Option<
            unsafe extern "C" fn(
                target: root::v8::Local<root::v8::Object>,
                type_: root::v8::AccessType,
                data: root::v8::Local<root::v8::Value>,
            ),
        >;
        /// Callback to check if code generation from strings is allowed. See
        /// Context::AllowCodeGenerationFromStrings.
        pub type AllowCodeGenerationFromStringsCallback = ::std::option::Option<
            unsafe extern "C" fn(
                context: root::v8::Local<root::v8::Context>,
                source: root::v8::Local<root::v8::String>,
            ) -> bool,
        >;
        pub type ExtensionCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::v8::FunctionCallbackInfo) -> bool,
        >;
        pub type AllowWasmCodeGenerationCallback = ::std::option::Option<
            unsafe extern "C" fn(
                context: root::v8::Local<root::v8::Context>,
                source: root::v8::Local<root::v8::String>,
            ) -> bool,
        >;
        pub type ApiImplementationCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::v8::FunctionCallbackInfo),
        >;
        pub type WasmStreamingCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::v8::FunctionCallbackInfo),
        >;
        pub type WasmThreadsEnabledCallback = ::std::option::Option<
            unsafe extern "C" fn(context: root::v8::Local<root::v8::Context>) -> bool,
        >;
        pub const GCType_kGCTypeScavenge: root::v8::GCType = 1;
        pub const GCType_kGCTypeMarkSweepCompact: root::v8::GCType = 2;
        pub const GCType_kGCTypeIncrementalMarking: root::v8::GCType = 4;
        pub const GCType_kGCTypeProcessWeakCallbacks: root::v8::GCType = 8;
        pub const GCType_kGCTypeAll: root::v8::GCType = 15;
        /// Applications can register callback functions which will be called before and
        /// after certain garbage collection operations.  Allocations are not allowed in
        /// the callback functions, you therefore cannot manipulate objects (set or
        /// delete properties for example) since it is possible such operations will
        /// result in the allocation of objects.
        pub type GCType = i32;
        pub const GCCallbackFlags_kNoGCCallbackFlags: root::v8::GCCallbackFlags = 0;
        pub const GCCallbackFlags_kGCCallbackFlagConstructRetainedObjectInfos:
            root::v8::GCCallbackFlags = 2;
        pub const GCCallbackFlags_kGCCallbackFlagForced: root::v8::GCCallbackFlags = 4;
        pub const GCCallbackFlags_kGCCallbackFlagSynchronousPhantomCallbackProcessing:
            root::v8::GCCallbackFlags = 8;
        pub const GCCallbackFlags_kGCCallbackFlagCollectAllAvailableGarbage:
            root::v8::GCCallbackFlags = 16;
        pub const GCCallbackFlags_kGCCallbackFlagCollectAllExternalMemory:
            root::v8::GCCallbackFlags = 32;
        pub const GCCallbackFlags_kGCCallbackScheduleIdleGarbageCollection:
            root::v8::GCCallbackFlags = 64;
        /// GCCallbackFlags is used to notify additional information about the GC
        /// callback.
        /// - kGCCallbackFlagConstructRetainedObjectInfos: The GC callback is for
        /// constructing retained object infos.
        /// - kGCCallbackFlagForced: The GC callback is for a forced GC for testing.
        /// - kGCCallbackFlagSynchronousPhantomCallbackProcessing: The GC callback
        /// is called synchronously without getting posted to an idle task.
        /// - kGCCallbackFlagCollectAllAvailableGarbage: The GC callback is called
        /// in a phase where V8 is trying to collect all available garbage
        /// (e.g., handling a low memory notification).
        /// - kGCCallbackScheduleIdleGarbageCollection: The GC callback is called to
        /// trigger an idle garbage collection.
        pub type GCCallbackFlags = i32;
        pub type InterruptCallback = ::std::option::Option<
            unsafe extern "C" fn(
                isolate: *mut root::v8::Isolate,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        /// This callback is invoked when the heap size is close to the heap limit and
        /// V8 is likely to abort with out-of-memory error.
        /// The callback can extend the heap limit by returning a value that is greater
        /// than the current_heap_limit. The initial heap limit is the limit that was
        /// set after heap setup.
        pub type NearHeapLimitCallback = ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                current_heap_limit: usize,
                initial_heap_limit: usize,
            ) -> usize,
        >;
        /// Collection of V8 heap information.
        ///
        /// Instances of this class can be passed to v8::V8::HeapStatistics to
        /// get heap statistics from V8.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct HeapStatistics {
            pub total_heap_size_: usize,
            pub total_heap_size_executable_: usize,
            pub total_physical_size_: usize,
            pub total_available_size_: usize,
            pub used_heap_size_: usize,
            pub heap_size_limit_: usize,
            pub malloced_memory_: usize,
            pub external_memory_: usize,
            pub peak_malloced_memory_: usize,
            pub does_zap_garbage_: bool,
            pub number_of_native_contexts_: usize,
            pub number_of_detached_contexts_: usize,
        }
        #[test]
        fn bindgen_test_layout_HeapStatistics() {
            assert_eq!(
                ::std::mem::size_of::<HeapStatistics>(),
                96usize,
                concat!("Size of: ", stringify!(HeapStatistics))
            );
            assert_eq!(
                ::std::mem::align_of::<HeapStatistics>(),
                8usize,
                concat!("Alignment of ", stringify!(HeapStatistics))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).total_heap_size_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(total_heap_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).total_heap_size_executable_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(total_heap_size_executable_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).total_physical_size_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(total_physical_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).total_available_size_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(total_available_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).used_heap_size_ as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(used_heap_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).heap_size_limit_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(heap_size_limit_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).malloced_memory_ as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(malloced_memory_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).external_memory_ as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(external_memory_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).peak_malloced_memory_ as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(peak_malloced_memory_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).does_zap_garbage_ as *const _
                        as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(does_zap_garbage_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).number_of_native_contexts_
                        as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(number_of_native_contexts_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapStatistics>())).number_of_detached_contexts_
                        as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapStatistics),
                    "::",
                    stringify!(number_of_detached_contexts_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0HeapStatistics@v8@@QEAA@XZ"]
            pub fn HeapStatistics_HeapStatistics(this: *mut root::v8::HeapStatistics);
        }
        impl HeapStatistics {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                HeapStatistics_HeapStatistics(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct HeapSpaceStatistics {
            pub space_name_: *const ::std::os::raw::c_char,
            pub space_size_: usize,
            pub space_used_size_: usize,
            pub space_available_size_: usize,
            pub physical_space_size_: usize,
        }
        #[test]
        fn bindgen_test_layout_HeapSpaceStatistics() {
            assert_eq!(
                ::std::mem::size_of::<HeapSpaceStatistics>(),
                40usize,
                concat!("Size of: ", stringify!(HeapSpaceStatistics))
            );
            assert_eq!(
                ::std::mem::align_of::<HeapSpaceStatistics>(),
                8usize,
                concat!("Alignment of ", stringify!(HeapSpaceStatistics))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapSpaceStatistics>())).space_name_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapSpaceStatistics),
                    "::",
                    stringify!(space_name_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapSpaceStatistics>())).space_size_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapSpaceStatistics),
                    "::",
                    stringify!(space_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapSpaceStatistics>())).space_used_size_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapSpaceStatistics),
                    "::",
                    stringify!(space_used_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapSpaceStatistics>())).space_available_size_
                        as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapSpaceStatistics),
                    "::",
                    stringify!(space_available_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapSpaceStatistics>())).physical_space_size_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapSpaceStatistics),
                    "::",
                    stringify!(physical_space_size_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0HeapSpaceStatistics@v8@@QEAA@XZ"]
            pub fn HeapSpaceStatistics_HeapSpaceStatistics(
                this: *mut root::v8::HeapSpaceStatistics,
            );
        }
        impl HeapSpaceStatistics {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                HeapSpaceStatistics_HeapSpaceStatistics(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct HeapObjectStatistics {
            pub object_type_: *const ::std::os::raw::c_char,
            pub object_sub_type_: *const ::std::os::raw::c_char,
            pub object_count_: usize,
            pub object_size_: usize,
        }
        #[test]
        fn bindgen_test_layout_HeapObjectStatistics() {
            assert_eq!(
                ::std::mem::size_of::<HeapObjectStatistics>(),
                32usize,
                concat!("Size of: ", stringify!(HeapObjectStatistics))
            );
            assert_eq!(
                ::std::mem::align_of::<HeapObjectStatistics>(),
                8usize,
                concat!("Alignment of ", stringify!(HeapObjectStatistics))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapObjectStatistics>())).object_type_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapObjectStatistics),
                    "::",
                    stringify!(object_type_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapObjectStatistics>())).object_sub_type_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapObjectStatistics),
                    "::",
                    stringify!(object_sub_type_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapObjectStatistics>())).object_count_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapObjectStatistics),
                    "::",
                    stringify!(object_count_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapObjectStatistics>())).object_size_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapObjectStatistics),
                    "::",
                    stringify!(object_size_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0HeapObjectStatistics@v8@@QEAA@XZ"]
            pub fn HeapObjectStatistics_HeapObjectStatistics(
                this: *mut root::v8::HeapObjectStatistics,
            );
        }
        impl HeapObjectStatistics {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                HeapObjectStatistics_HeapObjectStatistics(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct HeapCodeStatistics {
            pub code_and_metadata_size_: usize,
            pub bytecode_and_metadata_size_: usize,
            pub external_script_source_size_: usize,
        }
        #[test]
        fn bindgen_test_layout_HeapCodeStatistics() {
            assert_eq!(
                ::std::mem::size_of::<HeapCodeStatistics>(),
                24usize,
                concat!("Size of: ", stringify!(HeapCodeStatistics))
            );
            assert_eq!(
                ::std::mem::align_of::<HeapCodeStatistics>(),
                8usize,
                concat!("Alignment of ", stringify!(HeapCodeStatistics))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapCodeStatistics>())).code_and_metadata_size_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapCodeStatistics),
                    "::",
                    stringify!(code_and_metadata_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapCodeStatistics>())).bytecode_and_metadata_size_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapCodeStatistics),
                    "::",
                    stringify!(bytecode_and_metadata_size_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HeapCodeStatistics>())).external_script_source_size_
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HeapCodeStatistics),
                    "::",
                    stringify!(external_script_source_size_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0HeapCodeStatistics@v8@@QEAA@XZ"]
            pub fn HeapCodeStatistics_HeapCodeStatistics(this: *mut root::v8::HeapCodeStatistics);
        }
        impl HeapCodeStatistics {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                HeapCodeStatistics_HeapCodeStatistics(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        /// FunctionEntryHook is the type of the profile entry hook called at entry to
        /// any generated function when function-level profiling is enabled.
        ///
        /// \param function the address of the function that's being entered.
        /// \param return_addr_location points to a location on stack where the machine
        /// return address resides. This can be used to identify the caller of
        /// \p function, and/or modified to divert execution when \p function exits.
        ///
        /// \note the entry hook must not cause garbage collection.
        pub type FunctionEntryHook = ::std::option::Option<
            unsafe extern "C" fn(function: usize, return_addr_location: usize),
        >;
        /// A JIT code event is issued each time code is added, moved or removed.
        ///
        /// \note removal events are not currently issued.
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct JitCodeEvent {
            pub type_: root::v8::JitCodeEvent_EventType,
            pub code_type: root::v8::JitCodeEvent_CodeType,
            pub code_start: *mut ::std::os::raw::c_void,
            pub code_len: usize,
            pub script: root::v8::Local<root::v8::UnboundScript>,
            pub user_data: *mut ::std::os::raw::c_void,
            pub __bindgen_anon_1: root::v8::JitCodeEvent__bindgen_ty_1,
            pub isolate: *mut root::v8::Isolate,
        }
        pub const JitCodeEvent_EventType_CODE_ADDED: root::v8::JitCodeEvent_EventType = 0;
        pub const JitCodeEvent_EventType_CODE_MOVED: root::v8::JitCodeEvent_EventType = 1;
        pub const JitCodeEvent_EventType_CODE_REMOVED: root::v8::JitCodeEvent_EventType = 2;
        pub const JitCodeEvent_EventType_CODE_ADD_LINE_POS_INFO: root::v8::JitCodeEvent_EventType =
            3;
        pub const JitCodeEvent_EventType_CODE_START_LINE_INFO_RECORDING:
            root::v8::JitCodeEvent_EventType = 4;
        pub const JitCodeEvent_EventType_CODE_END_LINE_INFO_RECORDING:
            root::v8::JitCodeEvent_EventType = 5;
        pub type JitCodeEvent_EventType = i32;
        pub const JitCodeEvent_PositionType_POSITION: root::v8::JitCodeEvent_PositionType = 0;
        pub const JitCodeEvent_PositionType_STATEMENT_POSITION:
            root::v8::JitCodeEvent_PositionType = 1;
        pub type JitCodeEvent_PositionType = i32;
        pub const JitCodeEvent_CodeType_BYTE_CODE: root::v8::JitCodeEvent_CodeType = 0;
        pub const JitCodeEvent_CodeType_JIT_CODE: root::v8::JitCodeEvent_CodeType = 1;
        pub type JitCodeEvent_CodeType = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct JitCodeEvent_name_t {
            pub str: *const ::std::os::raw::c_char,
            pub len: usize,
        }
        #[test]
        fn bindgen_test_layout_JitCodeEvent_name_t() {
            assert_eq!(
                ::std::mem::size_of::<JitCodeEvent_name_t>(),
                16usize,
                concat!("Size of: ", stringify!(JitCodeEvent_name_t))
            );
            assert_eq!(
                ::std::mem::align_of::<JitCodeEvent_name_t>(),
                8usize,
                concat!("Alignment of ", stringify!(JitCodeEvent_name_t))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent_name_t>())).str as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent_name_t),
                    "::",
                    stringify!(str)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent_name_t>())).len as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent_name_t),
                    "::",
                    stringify!(len)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct JitCodeEvent_line_info_t {
            pub offset: usize,
            pub pos: usize,
            pub position_type: root::v8::JitCodeEvent_PositionType,
        }
        #[test]
        fn bindgen_test_layout_JitCodeEvent_line_info_t() {
            assert_eq!(
                ::std::mem::size_of::<JitCodeEvent_line_info_t>(),
                24usize,
                concat!("Size of: ", stringify!(JitCodeEvent_line_info_t))
            );
            assert_eq!(
                ::std::mem::align_of::<JitCodeEvent_line_info_t>(),
                8usize,
                concat!("Alignment of ", stringify!(JitCodeEvent_line_info_t))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<JitCodeEvent_line_info_t>())).offset as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent_line_info_t),
                    "::",
                    stringify!(offset)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<JitCodeEvent_line_info_t>())).pos as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent_line_info_t),
                    "::",
                    stringify!(pos)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<JitCodeEvent_line_info_t>())).position_type as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent_line_info_t),
                    "::",
                    stringify!(position_type)
                )
            );
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union JitCodeEvent__bindgen_ty_1 {
            pub name: root::v8::JitCodeEvent_name_t,
            pub line_info: root::v8::JitCodeEvent_line_info_t,
            pub new_code_start: *mut ::std::os::raw::c_void,
            _bindgen_union_align: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_JitCodeEvent__bindgen_ty_1() {
            assert_eq!(
                ::std::mem::size_of::<JitCodeEvent__bindgen_ty_1>(),
                24usize,
                concat!("Size of: ", stringify!(JitCodeEvent__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<JitCodeEvent__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(JitCodeEvent__bindgen_ty_1))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<JitCodeEvent__bindgen_ty_1>())).name as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent__bindgen_ty_1),
                    "::",
                    stringify!(name)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<JitCodeEvent__bindgen_ty_1>())).line_info as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent__bindgen_ty_1),
                    "::",
                    stringify!(line_info)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<JitCodeEvent__bindgen_ty_1>())).new_code_start
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent__bindgen_ty_1),
                    "::",
                    stringify!(new_code_start)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_JitCodeEvent() {
            assert_eq!(
                ::std::mem::size_of::<JitCodeEvent>(),
                72usize,
                concat!("Size of: ", stringify!(JitCodeEvent))
            );
            assert_eq!(
                ::std::mem::align_of::<JitCodeEvent>(),
                8usize,
                concat!("Alignment of ", stringify!(JitCodeEvent))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent>())).type_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent),
                    "::",
                    stringify!(type_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent>())).code_type as *const _ as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent),
                    "::",
                    stringify!(code_type)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent>())).code_start as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent),
                    "::",
                    stringify!(code_start)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent>())).code_len as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent),
                    "::",
                    stringify!(code_len)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent>())).script as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent),
                    "::",
                    stringify!(script)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent>())).user_data as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent),
                    "::",
                    stringify!(user_data)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<JitCodeEvent>())).isolate as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JitCodeEvent),
                    "::",
                    stringify!(isolate)
                )
            );
        }
        pub const RAILMode_PERFORMANCE_RESPONSE: root::v8::RAILMode = 0;
        pub const RAILMode_PERFORMANCE_ANIMATION: root::v8::RAILMode = 1;
        pub const RAILMode_PERFORMANCE_IDLE: root::v8::RAILMode = 2;
        pub const RAILMode_PERFORMANCE_LOAD: root::v8::RAILMode = 3;
        /// Option flags passed to the SetRAILMode function.
        /// See documentation https://developers.google.com/web/tools/chrome-devtools/
        /// profile/evaluate-performance/rail
        pub type RAILMode = i32;
        pub const JitCodeEventOptions_kJitCodeEventDefault: root::v8::JitCodeEventOptions = 0;
        pub const JitCodeEventOptions_kJitCodeEventEnumExisting: root::v8::JitCodeEventOptions = 1;
        /// Option flags passed to the SetJitCodeEventHandler function.
        pub type JitCodeEventOptions = i32;
        /// Callback function passed to SetJitCodeEventHandler.
        ///
        /// \param event code add, move or removal event.
        pub type JitCodeEventHandler =
            ::std::option::Option<unsafe extern "C" fn(event: *const root::v8::JitCodeEvent)>;
        #[repr(C)]
        pub struct ExternalResourceVisitor__bindgen_vtable(::std::os::raw::c_void);
        /// Interface for iterating through all external resources in the heap.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ExternalResourceVisitor {
            pub vtable_: *const ExternalResourceVisitor__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ExternalResourceVisitor() {
            assert_eq!(
                ::std::mem::size_of::<ExternalResourceVisitor>(),
                8usize,
                concat!("Size of: ", stringify!(ExternalResourceVisitor))
            );
            assert_eq!(
                ::std::mem::align_of::<ExternalResourceVisitor>(),
                8usize,
                concat!("Alignment of ", stringify!(ExternalResourceVisitor))
            );
        }
        #[repr(C)]
        pub struct PersistentHandleVisitor__bindgen_vtable(::std::os::raw::c_void);
        /// Interface for iterating through all the persistent handles in the heap.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct PersistentHandleVisitor {
            pub vtable_: *const PersistentHandleVisitor__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_PersistentHandleVisitor() {
            assert_eq!(
                ::std::mem::size_of::<PersistentHandleVisitor>(),
                8usize,
                concat!("Size of: ", stringify!(PersistentHandleVisitor))
            );
            assert_eq!(
                ::std::mem::align_of::<PersistentHandleVisitor>(),
                8usize,
                concat!("Alignment of ", stringify!(PersistentHandleVisitor))
            );
        }
        pub const MemoryPressureLevel_kNone: root::v8::MemoryPressureLevel = 0;
        pub const MemoryPressureLevel_kModerate: root::v8::MemoryPressureLevel = 1;
        pub const MemoryPressureLevel_kCritical: root::v8::MemoryPressureLevel = 2;
        /// Memory pressure level for the MemoryPressureNotification.
        /// kNone hints V8 that there is no memory pressure.
        /// kModerate hints V8 to speed up incremental garbage collection at the cost of
        /// of higher latency due to garbage collection pauses.
        /// kCritical hints V8 to free memory as soon as possible. Garbage collection
        /// pauses at this level will be large.
        pub type MemoryPressureLevel = i32;
        #[repr(C)]
        pub struct EmbedderHeapTracer__bindgen_vtable(::std::os::raw::c_void);
        /// Interface for tracing through the embedder heap. During a V8 garbage
        /// collection, V8 collects hidden fields of all potential wrappers, and at the
        /// end of its marking phase iterates the collection and asks the embedder to
        /// trace through its heap and use reporter to report each JavaScript object
        /// reachable from any of the given wrappers.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct EmbedderHeapTracer {
            pub vtable_: *const EmbedderHeapTracer__bindgen_vtable,
            pub isolate_: *mut root::v8::Isolate,
        }
        pub const EmbedderHeapTracer_EmbedderStackState_kUnknown:
            root::v8::EmbedderHeapTracer_EmbedderStackState = 0;
        pub const EmbedderHeapTracer_EmbedderStackState_kNonEmpty:
            root::v8::EmbedderHeapTracer_EmbedderStackState = 1;
        pub const EmbedderHeapTracer_EmbedderStackState_kEmpty:
            root::v8::EmbedderHeapTracer_EmbedderStackState = 2;
        pub type EmbedderHeapTracer_EmbedderStackState = i32;
        pub const EmbedderHeapTracer_ForceCompletionAction_FORCE_COMPLETION:
            root::v8::EmbedderHeapTracer_ForceCompletionAction = 0;
        pub const EmbedderHeapTracer_ForceCompletionAction_DO_NOT_FORCE_COMPLETION:
            root::v8::EmbedderHeapTracer_ForceCompletionAction = 1;
        pub type EmbedderHeapTracer_ForceCompletionAction = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct EmbedderHeapTracer_AdvanceTracingActions {
            pub force_completion: root::v8::EmbedderHeapTracer_ForceCompletionAction,
        }
        #[test]
        fn bindgen_test_layout_EmbedderHeapTracer_AdvanceTracingActions() {
            assert_eq!(
                ::std::mem::size_of::<EmbedderHeapTracer_AdvanceTracingActions>(),
                4usize,
                concat!(
                    "Size of: ",
                    stringify!(EmbedderHeapTracer_AdvanceTracingActions)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<EmbedderHeapTracer_AdvanceTracingActions>(),
                4usize,
                concat!(
                    "Alignment of ",
                    stringify!(EmbedderHeapTracer_AdvanceTracingActions)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<EmbedderHeapTracer_AdvanceTracingActions>()))
                        .force_completion as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EmbedderHeapTracer_AdvanceTracingActions),
                    "::",
                    stringify!(force_completion)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_EmbedderHeapTracer() {
            assert_eq!(
                ::std::mem::size_of::<EmbedderHeapTracer>(),
                16usize,
                concat!("Size of: ", stringify!(EmbedderHeapTracer))
            );
            assert_eq!(
                ::std::mem::align_of::<EmbedderHeapTracer>(),
                8usize,
                concat!("Alignment of ", stringify!(EmbedderHeapTracer))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<EmbedderHeapTracer>())).isolate_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EmbedderHeapTracer),
                    "::",
                    stringify!(isolate_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}?FinalizeTracing@EmbedderHeapTracer@v8@@QEAAXXZ"]
            pub fn EmbedderHeapTracer_FinalizeTracing(this: *mut root::v8::EmbedderHeapTracer);
        }
        extern "C" {
            #[link_name = "\u{1}?GarbageCollectionForTesting@EmbedderHeapTracer@v8@@QEAAXW4EmbedderStackState@12@@Z"]
            pub fn EmbedderHeapTracer_GarbageCollectionForTesting(
                this: *mut root::v8::EmbedderHeapTracer,
                stack_state: root::v8::EmbedderHeapTracer_EmbedderStackState,
            );
        }
        impl EmbedderHeapTracer {
            #[inline]
            pub unsafe fn FinalizeTracing(&mut self) {
                EmbedderHeapTracer_FinalizeTracing(self)
            }
            #[inline]
            pub unsafe fn GarbageCollectionForTesting(
                &mut self,
                stack_state: root::v8::EmbedderHeapTracer_EmbedderStackState,
            ) {
                EmbedderHeapTracer_GarbageCollectionForTesting(self, stack_state)
            }
        }
        extern "C" {
            /// Called to advance tracing in the embedder.
            ///
            /// The embedder is expected to trace its heap starting from wrappers reported
            /// by RegisterV8References method, and report back all reachable wrappers.
            /// Furthermore, the embedder is expected to stop tracing by the given
            /// deadline. A deadline of infinity means that tracing should be finished.
            ///
            /// Returns |true| if tracing is done, and false otherwise.
            ///
            /// Note: Only one of the AdvanceTracing methods needs to be overriden by the
            /// embedder.
            #[link_name = "\u{1}?AdvanceTracing@EmbedderHeapTracer@v8@@UEAA_NN@Z"]
            pub fn EmbedderHeapTracer_AdvanceTracing(
                this: *mut ::std::os::raw::c_void,
                deadline_in_ms: f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?IsTracingDone@EmbedderHeapTracer@v8@@UEAA_NXZ"]
            pub fn EmbedderHeapTracer_IsTracingDone(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?EnterFinalPause@EmbedderHeapTracer@v8@@UEAAXW4EmbedderStackState@12@@Z"]
            pub fn EmbedderHeapTracer_EnterFinalPause(
                this: *mut ::std::os::raw::c_void,
                stack_state: root::v8::EmbedderHeapTracer_EmbedderStackState,
            );
        }
        /// Callback and supporting data used in SnapshotCreator to implement embedder
        /// logic to serialize internal fields.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct SerializeInternalFieldsCallback {
            pub callback: root::v8::SerializeInternalFieldsCallback_CallbackFunction,
            pub data: *mut ::std::os::raw::c_void,
        }
        pub type SerializeInternalFieldsCallback_CallbackFunction = ::std::option::Option<
            unsafe extern "C" fn(
                holder: root::v8::Local<root::v8::Object>,
                index: ::std::os::raw::c_int,
                data: *mut ::std::os::raw::c_void,
            ) -> root::v8::StartupData,
        >;
        #[test]
        fn bindgen_test_layout_SerializeInternalFieldsCallback() {
            assert_eq!(
                ::std::mem::size_of::<SerializeInternalFieldsCallback>(),
                16usize,
                concat!("Size of: ", stringify!(SerializeInternalFieldsCallback))
            );
            assert_eq!(
                ::std::mem::align_of::<SerializeInternalFieldsCallback>(),
                8usize,
                concat!("Alignment of ", stringify!(SerializeInternalFieldsCallback))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SerializeInternalFieldsCallback>())).callback as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SerializeInternalFieldsCallback),
                    "::",
                    stringify!(callback)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SerializeInternalFieldsCallback>())).data as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SerializeInternalFieldsCallback),
                    "::",
                    stringify!(data)
                )
            );
        }
        /// Callback and supporting data used to implement embedder logic to deserialize
        /// internal fields.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct DeserializeInternalFieldsCallback {
            pub callback: ::std::option::Option<
                unsafe extern "C" fn(
                    holder: root::v8::Local<root::v8::Object>,
                    index: ::std::os::raw::c_int,
                    payload: root::v8::StartupData,
                    data: *mut ::std::os::raw::c_void,
                ),
            >,
            pub data: *mut ::std::os::raw::c_void,
        }
        pub type DeserializeInternalFieldsCallback_CallbackFunction = ::std::option::Option<
            unsafe extern "C" fn(
                holder: root::v8::Local<root::v8::Object>,
                index: ::std::os::raw::c_int,
                payload: root::v8::StartupData,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        #[test]
        fn bindgen_test_layout_DeserializeInternalFieldsCallback() {
            assert_eq!(
                ::std::mem::size_of::<DeserializeInternalFieldsCallback>(),
                16usize,
                concat!("Size of: ", stringify!(DeserializeInternalFieldsCallback))
            );
            assert_eq!(
                ::std::mem::align_of::<DeserializeInternalFieldsCallback>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(DeserializeInternalFieldsCallback)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<DeserializeInternalFieldsCallback>())).callback
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DeserializeInternalFieldsCallback),
                    "::",
                    stringify!(callback)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<DeserializeInternalFieldsCallback>())).data as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DeserializeInternalFieldsCallback),
                    "::",
                    stringify!(data)
                )
            );
        }
        /// Isolate represents an isolated instance of the V8 engine.  V8 isolates have
        /// completely separate states.  Objects from one isolate must not be used in
        /// other isolates.  The embedder can create multiple isolates and use them in
        /// parallel in multiple threads.  An isolate can be entered by at most one
        /// thread at any given time.  The Locker/Unlocker API must be used to
        /// synchronize.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Isolate {
            pub _address: u8,
        }
        /// Initial configuration parameters for a new Isolate.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Isolate_CreateParams {
            /// The optional entry_hook allows the host application to provide the
            /// address of a function that's invoked on entry to every V8-generated
            /// function.  Note that entry_hook is invoked at the very start of each
            /// generated function.
            /// An entry_hook can only be provided in no-snapshot builds; in snapshot
            /// builds it must be nullptr.
            pub entry_hook: root::v8::FunctionEntryHook,
            /// Allows the host application to provide the address of a function that is
            /// notified each time code is added, moved or removed.
            pub code_event_handler: root::v8::JitCodeEventHandler,
            /// ResourceConstraints to use for the new Isolate.
            pub constraints: root::v8::ResourceConstraints,
            /// Explicitly specify a startup snapshot blob. The embedder owns the blob.
            pub snapshot_blob: *mut root::v8::StartupData,
            /// Enables the host application to provide a mechanism for recording
            /// statistics counters.
            pub counter_lookup_callback: root::v8::CounterLookupCallback,
            /// Enables the host application to provide a mechanism for recording
            /// histograms. The CreateHistogram function returns a
            /// histogram which will later be passed to the AddHistogramSample
            /// function.
            pub create_histogram_callback: root::v8::CreateHistogramCallback,
            pub add_histogram_sample_callback: root::v8::AddHistogramSampleCallback,
            /// The ArrayBuffer::Allocator to use for allocating and freeing the backing
            /// store of ArrayBuffers.
            pub array_buffer_allocator: *mut root::v8::ArrayBuffer_Allocator,
            /// Specifies an optional nullptr-terminated array of raw addresses in the
            /// embedder that V8 can match against during serialization and use for
            /// deserialization. This array and its content must stay valid for the
            /// entire lifetime of the isolate.
            pub external_references: *const isize,
            /// Whether calling Atomics.wait (a function that may block) is allowed in
            /// this isolate. This can also be configured via SetAllowAtomicsWait.
            pub allow_atomics_wait: bool,
            /// Termination is postponed when there is no active SafeForTerminationScope.
            pub only_terminate_in_safe_scope: bool,
        }
        #[test]
        fn bindgen_test_layout_Isolate_CreateParams() {
            assert_eq!(
                ::std::mem::size_of::<Isolate_CreateParams>(),
                120usize,
                concat!("Size of: ", stringify!(Isolate_CreateParams))
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate_CreateParams>(),
                8usize,
                concat!("Alignment of ", stringify!(Isolate_CreateParams))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).entry_hook as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(entry_hook)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).code_event_handler as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(code_event_handler)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).constraints as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(constraints)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).snapshot_blob as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(snapshot_blob)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).counter_lookup_callback
                        as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(counter_lookup_callback)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).create_histogram_callback
                        as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(create_histogram_callback)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).add_histogram_sample_callback
                        as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(add_histogram_sample_callback)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).array_buffer_allocator
                        as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(array_buffer_allocator)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).external_references as *const _
                        as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(external_references)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).allow_atomics_wait as *const _
                        as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(allow_atomics_wait)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_CreateParams>())).only_terminate_in_safe_scope
                        as *const _ as usize
                },
                113usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_CreateParams),
                    "::",
                    stringify!(only_terminate_in_safe_scope)
                )
            );
        }
        /// Stack-allocated class which sets the isolate for all operations
        /// executed within a local scope.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Isolate_Scope {
            pub isolate_: *mut root::v8::Isolate,
        }
        #[test]
        fn bindgen_test_layout_Isolate_Scope() {
            assert_eq!(
                ::std::mem::size_of::<Isolate_Scope>(),
                8usize,
                concat!("Size of: ", stringify!(Isolate_Scope))
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate_Scope>(),
                8usize,
                concat!("Alignment of ", stringify!(Isolate_Scope))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Isolate_Scope>())).isolate_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_Scope),
                    "::",
                    stringify!(isolate_)
                )
            );
        }
        /// Assert that no Javascript code is invoked.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Isolate_DisallowJavascriptExecutionScope {
            pub on_failure_: bool,
            pub internal_: *mut ::std::os::raw::c_void,
        }
        pub const Isolate_DisallowJavascriptExecutionScope_OnFailure_CRASH_ON_FAILURE:
            root::v8::Isolate_DisallowJavascriptExecutionScope_OnFailure = 0;
        pub const Isolate_DisallowJavascriptExecutionScope_OnFailure_THROW_ON_FAILURE:
            root::v8::Isolate_DisallowJavascriptExecutionScope_OnFailure = 1;
        pub type Isolate_DisallowJavascriptExecutionScope_OnFailure = i32;
        #[test]
        fn bindgen_test_layout_Isolate_DisallowJavascriptExecutionScope() {
            assert_eq!(
                ::std::mem::size_of::<Isolate_DisallowJavascriptExecutionScope>(),
                16usize,
                concat!(
                    "Size of: ",
                    stringify!(Isolate_DisallowJavascriptExecutionScope)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate_DisallowJavascriptExecutionScope>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(Isolate_DisallowJavascriptExecutionScope)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_DisallowJavascriptExecutionScope>())).on_failure_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_DisallowJavascriptExecutionScope),
                    "::",
                    stringify!(on_failure_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_DisallowJavascriptExecutionScope>())).internal_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_DisallowJavascriptExecutionScope),
                    "::",
                    stringify!(internal_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0DisallowJavascriptExecutionScope@Isolate@v8@@QEAA@PEAV12@W4OnFailure@012@@Z"]
            pub fn Isolate_DisallowJavascriptExecutionScope_DisallowJavascriptExecutionScope(
                this: *mut root::v8::Isolate_DisallowJavascriptExecutionScope,
                isolate: *mut root::v8::Isolate,
                on_failure: root::v8::Isolate_DisallowJavascriptExecutionScope_OnFailure,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DDisallowJavascriptExecutionScope@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_DisallowJavascriptExecutionScope_DisallowJavascriptExecutionScope_destructor(
                this: *mut root::v8::Isolate_DisallowJavascriptExecutionScope,
            );
        }
        impl Isolate_DisallowJavascriptExecutionScope {
            #[inline]
            pub unsafe fn new(
                isolate: *mut root::v8::Isolate,
                on_failure: root::v8::Isolate_DisallowJavascriptExecutionScope_OnFailure,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Isolate_DisallowJavascriptExecutionScope_DisallowJavascriptExecutionScope(
                    &mut __bindgen_tmp,
                    isolate,
                    on_failure,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Isolate_DisallowJavascriptExecutionScope_DisallowJavascriptExecutionScope_destructor(
                    self,
                )
            }
        }
        /// Introduce exception to DisallowJavascriptExecutionScope.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Isolate_AllowJavascriptExecutionScope {
            pub internal_throws_: *mut ::std::os::raw::c_void,
            pub internal_assert_: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_Isolate_AllowJavascriptExecutionScope() {
            assert_eq!(
                ::std::mem::size_of::<Isolate_AllowJavascriptExecutionScope>(),
                16usize,
                concat!(
                    "Size of: ",
                    stringify!(Isolate_AllowJavascriptExecutionScope)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate_AllowJavascriptExecutionScope>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(Isolate_AllowJavascriptExecutionScope)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_AllowJavascriptExecutionScope>()))
                        .internal_throws_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_AllowJavascriptExecutionScope),
                    "::",
                    stringify!(internal_throws_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_AllowJavascriptExecutionScope>()))
                        .internal_assert_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_AllowJavascriptExecutionScope),
                    "::",
                    stringify!(internal_assert_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0AllowJavascriptExecutionScope@Isolate@v8@@QEAA@PEAV12@@Z"]
            pub fn Isolate_AllowJavascriptExecutionScope_AllowJavascriptExecutionScope(
                this: *mut root::v8::Isolate_AllowJavascriptExecutionScope,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DAllowJavascriptExecutionScope@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_AllowJavascriptExecutionScope_AllowJavascriptExecutionScope_destructor(
                this: *mut root::v8::Isolate_AllowJavascriptExecutionScope,
            );
        }
        impl Isolate_AllowJavascriptExecutionScope {
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Isolate_AllowJavascriptExecutionScope_AllowJavascriptExecutionScope(
                    &mut __bindgen_tmp,
                    isolate,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Isolate_AllowJavascriptExecutionScope_AllowJavascriptExecutionScope_destructor(self)
            }
        }
        /// Do not run microtasks while this scope is active, even if microtasks are
        /// automatically executed otherwise.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Isolate_SuppressMicrotaskExecutionScope {
            pub isolate_: *mut root::v8::internal::Isolate,
        }
        #[test]
        fn bindgen_test_layout_Isolate_SuppressMicrotaskExecutionScope() {
            assert_eq!(
                ::std::mem::size_of::<Isolate_SuppressMicrotaskExecutionScope>(),
                8usize,
                concat!(
                    "Size of: ",
                    stringify!(Isolate_SuppressMicrotaskExecutionScope)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate_SuppressMicrotaskExecutionScope>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(Isolate_SuppressMicrotaskExecutionScope)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_SuppressMicrotaskExecutionScope>())).isolate_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_SuppressMicrotaskExecutionScope),
                    "::",
                    stringify!(isolate_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0SuppressMicrotaskExecutionScope@Isolate@v8@@QEAA@PEAV12@@Z"]
            pub fn Isolate_SuppressMicrotaskExecutionScope_SuppressMicrotaskExecutionScope(
                this: *mut root::v8::Isolate_SuppressMicrotaskExecutionScope,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DSuppressMicrotaskExecutionScope@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_SuppressMicrotaskExecutionScope_SuppressMicrotaskExecutionScope_destructor(
                this: *mut root::v8::Isolate_SuppressMicrotaskExecutionScope,
            );
        }
        impl Isolate_SuppressMicrotaskExecutionScope {
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Isolate_SuppressMicrotaskExecutionScope_SuppressMicrotaskExecutionScope(
                    &mut __bindgen_tmp,
                    isolate,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Isolate_SuppressMicrotaskExecutionScope_SuppressMicrotaskExecutionScope_destructor(
                    self,
                )
            }
        }
        /// This scope allows terminations inside direct V8 API calls and forbid them
        /// inside any recursice API calls without explicit SafeForTerminationScope.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Isolate_SafeForTerminationScope {
            pub isolate_: *mut root::v8::internal::Isolate,
            pub prev_value_: bool,
        }
        #[test]
        fn bindgen_test_layout_Isolate_SafeForTerminationScope() {
            assert_eq!(
                ::std::mem::size_of::<Isolate_SafeForTerminationScope>(),
                16usize,
                concat!("Size of: ", stringify!(Isolate_SafeForTerminationScope))
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate_SafeForTerminationScope>(),
                8usize,
                concat!("Alignment of ", stringify!(Isolate_SafeForTerminationScope))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_SafeForTerminationScope>())).isolate_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_SafeForTerminationScope),
                    "::",
                    stringify!(isolate_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Isolate_SafeForTerminationScope>())).prev_value_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Isolate_SafeForTerminationScope),
                    "::",
                    stringify!(prev_value_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0SafeForTerminationScope@Isolate@v8@@QEAA@PEAV12@@Z"]
            pub fn Isolate_SafeForTerminationScope_SafeForTerminationScope(
                this: *mut root::v8::Isolate_SafeForTerminationScope,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DSafeForTerminationScope@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_SafeForTerminationScope_SafeForTerminationScope_destructor(
                this: *mut root::v8::Isolate_SafeForTerminationScope,
            );
        }
        impl Isolate_SafeForTerminationScope {
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Isolate_SafeForTerminationScope_SafeForTerminationScope(
                    &mut __bindgen_tmp,
                    isolate,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Isolate_SafeForTerminationScope_SafeForTerminationScope_destructor(self)
            }
        }
        pub const Isolate_GarbageCollectionType_kFullGarbageCollection:
            root::v8::Isolate_GarbageCollectionType = 0;
        pub const Isolate_GarbageCollectionType_kMinorGarbageCollection:
            root::v8::Isolate_GarbageCollectionType = 1;
        /// Types of garbage collections that can be requested via
        /// RequestGarbageCollectionForTesting.
        pub type Isolate_GarbageCollectionType = i32;
        pub const Isolate_UseCounterFeature_kUseAsm: root::v8::Isolate_UseCounterFeature = 0;
        pub const Isolate_UseCounterFeature_kBreakIterator: root::v8::Isolate_UseCounterFeature = 1;
        pub const Isolate_UseCounterFeature_kLegacyConst: root::v8::Isolate_UseCounterFeature = 2;
        pub const Isolate_UseCounterFeature_kMarkDequeOverflow:
            root::v8::Isolate_UseCounterFeature = 3;
        pub const Isolate_UseCounterFeature_kStoreBufferOverflow:
            root::v8::Isolate_UseCounterFeature = 4;
        pub const Isolate_UseCounterFeature_kSlotsBufferOverflow:
            root::v8::Isolate_UseCounterFeature = 5;
        pub const Isolate_UseCounterFeature_kObjectObserve: root::v8::Isolate_UseCounterFeature = 6;
        pub const Isolate_UseCounterFeature_kForcedGC: root::v8::Isolate_UseCounterFeature = 7;
        pub const Isolate_UseCounterFeature_kSloppyMode: root::v8::Isolate_UseCounterFeature = 8;
        pub const Isolate_UseCounterFeature_kStrictMode: root::v8::Isolate_UseCounterFeature = 9;
        pub const Isolate_UseCounterFeature_kStrongMode: root::v8::Isolate_UseCounterFeature = 10;
        pub const Isolate_UseCounterFeature_kRegExpPrototypeStickyGetter:
            root::v8::Isolate_UseCounterFeature = 11;
        pub const Isolate_UseCounterFeature_kRegExpPrototypeToString:
            root::v8::Isolate_UseCounterFeature = 12;
        pub const Isolate_UseCounterFeature_kRegExpPrototypeUnicodeGetter:
            root::v8::Isolate_UseCounterFeature = 13;
        pub const Isolate_UseCounterFeature_kIntlV8Parse: root::v8::Isolate_UseCounterFeature = 14;
        pub const Isolate_UseCounterFeature_kIntlPattern: root::v8::Isolate_UseCounterFeature = 15;
        pub const Isolate_UseCounterFeature_kIntlResolved: root::v8::Isolate_UseCounterFeature = 16;
        pub const Isolate_UseCounterFeature_kPromiseChain: root::v8::Isolate_UseCounterFeature = 17;
        pub const Isolate_UseCounterFeature_kPromiseAccept: root::v8::Isolate_UseCounterFeature =
            18;
        pub const Isolate_UseCounterFeature_kPromiseDefer: root::v8::Isolate_UseCounterFeature = 19;
        pub const Isolate_UseCounterFeature_kHtmlCommentInExternalScript:
            root::v8::Isolate_UseCounterFeature = 20;
        pub const Isolate_UseCounterFeature_kHtmlComment: root::v8::Isolate_UseCounterFeature = 21;
        pub const Isolate_UseCounterFeature_kSloppyModeBlockScopedFunctionRedefinition:
            root::v8::Isolate_UseCounterFeature = 22;
        pub const Isolate_UseCounterFeature_kForInInitializer: root::v8::Isolate_UseCounterFeature =
            23;
        pub const Isolate_UseCounterFeature_kArrayProtectorDirtied:
            root::v8::Isolate_UseCounterFeature = 24;
        pub const Isolate_UseCounterFeature_kArraySpeciesModified:
            root::v8::Isolate_UseCounterFeature = 25;
        pub const Isolate_UseCounterFeature_kArrayPrototypeConstructorModified:
            root::v8::Isolate_UseCounterFeature = 26;
        pub const Isolate_UseCounterFeature_kArrayInstanceProtoModified:
            root::v8::Isolate_UseCounterFeature = 27;
        pub const Isolate_UseCounterFeature_kArrayInstanceConstructorModified:
            root::v8::Isolate_UseCounterFeature = 28;
        pub const Isolate_UseCounterFeature_kLegacyFunctionDeclaration:
            root::v8::Isolate_UseCounterFeature = 29;
        pub const Isolate_UseCounterFeature_kRegExpPrototypeSourceGetter:
            root::v8::Isolate_UseCounterFeature = 30;
        pub const Isolate_UseCounterFeature_kRegExpPrototypeOldFlagGetter:
            root::v8::Isolate_UseCounterFeature = 31;
        pub const Isolate_UseCounterFeature_kDecimalWithLeadingZeroInStrictMode:
            root::v8::Isolate_UseCounterFeature = 32;
        pub const Isolate_UseCounterFeature_kLegacyDateParser: root::v8::Isolate_UseCounterFeature =
            33;
        pub const Isolate_UseCounterFeature_kDefineGetterOrSetterWouldThrow:
            root::v8::Isolate_UseCounterFeature = 34;
        pub const Isolate_UseCounterFeature_kFunctionConstructorReturnedUndefined:
            root::v8::Isolate_UseCounterFeature = 35;
        pub const Isolate_UseCounterFeature_kAssigmentExpressionLHSIsCallInSloppy:
            root::v8::Isolate_UseCounterFeature = 36;
        pub const Isolate_UseCounterFeature_kAssigmentExpressionLHSIsCallInStrict:
            root::v8::Isolate_UseCounterFeature = 37;
        pub const Isolate_UseCounterFeature_kPromiseConstructorReturnedUndefined:
            root::v8::Isolate_UseCounterFeature = 38;
        pub const Isolate_UseCounterFeature_kConstructorNonUndefinedPrimitiveReturn:
            root::v8::Isolate_UseCounterFeature = 39;
        pub const Isolate_UseCounterFeature_kLabeledExpressionStatement:
            root::v8::Isolate_UseCounterFeature = 40;
        pub const Isolate_UseCounterFeature_kLineOrParagraphSeparatorAsLineTerminator:
            root::v8::Isolate_UseCounterFeature = 41;
        pub const Isolate_UseCounterFeature_kIndexAccessor: root::v8::Isolate_UseCounterFeature =
            42;
        pub const Isolate_UseCounterFeature_kErrorCaptureStackTrace:
            root::v8::Isolate_UseCounterFeature = 43;
        pub const Isolate_UseCounterFeature_kErrorPrepareStackTrace:
            root::v8::Isolate_UseCounterFeature = 44;
        pub const Isolate_UseCounterFeature_kErrorStackTraceLimit:
            root::v8::Isolate_UseCounterFeature = 45;
        pub const Isolate_UseCounterFeature_kWebAssemblyInstantiation:
            root::v8::Isolate_UseCounterFeature = 46;
        pub const Isolate_UseCounterFeature_kDeoptimizerDisableSpeculation:
            root::v8::Isolate_UseCounterFeature = 47;
        pub const Isolate_UseCounterFeature_kArrayPrototypeSortJSArrayModifiedPrototype:
            root::v8::Isolate_UseCounterFeature = 48;
        pub const Isolate_UseCounterFeature_kFunctionTokenOffsetTooLongForToString:
            root::v8::Isolate_UseCounterFeature = 49;
        pub const Isolate_UseCounterFeature_kWasmSharedMemory: root::v8::Isolate_UseCounterFeature =
            50;
        pub const Isolate_UseCounterFeature_kWasmThreadOpcodes:
            root::v8::Isolate_UseCounterFeature = 51;
        pub const Isolate_UseCounterFeature_kUseCounterFeatureCount:
            root::v8::Isolate_UseCounterFeature = 52;
        /// Features reported via the SetUseCounterCallback callback. Do not change
        /// assigned numbers of existing items; add new features to the end of this
        /// list.
        pub type Isolate_UseCounterFeature = i32;
        pub const Isolate_MessageErrorLevel_kMessageLog: root::v8::Isolate_MessageErrorLevel = 1;
        pub const Isolate_MessageErrorLevel_kMessageDebug: root::v8::Isolate_MessageErrorLevel = 2;
        pub const Isolate_MessageErrorLevel_kMessageInfo: root::v8::Isolate_MessageErrorLevel = 4;
        pub const Isolate_MessageErrorLevel_kMessageError: root::v8::Isolate_MessageErrorLevel = 8;
        pub const Isolate_MessageErrorLevel_kMessageWarning: root::v8::Isolate_MessageErrorLevel =
            16;
        pub const Isolate_MessageErrorLevel_kMessageAll: root::v8::Isolate_MessageErrorLevel = 31;
        pub type Isolate_MessageErrorLevel = i32;
        pub type Isolate_UseCounterCallback = ::std::option::Option<
            unsafe extern "C" fn(
                isolate: *mut root::v8::Isolate,
                feature: root::v8::Isolate_UseCounterFeature,
            ),
        >;
        /// Custom callback used by embedders to help V8 determine if it should abort
        /// when it throws and no internal handler is predicted to catch the
        /// exception. If --abort-on-uncaught-exception is used on the command line,
        /// then V8 will abort if either:
        /// - no custom callback is set.
        /// - the custom callback set returns true.
        /// Otherwise, the custom callback will not be called and V8 will not abort.
        pub type Isolate_AbortOnUncaughtExceptionCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::v8::Isolate) -> bool>;
        pub type Isolate_GCCallback = ::std::option::Option<
            unsafe extern "C" fn(
                isolate: *mut root::v8::Isolate,
                type_: root::v8::GCType,
                flags: root::v8::GCCallbackFlags,
            ),
        >;
        pub type Isolate_GCCallbackWithData = ::std::option::Option<
            unsafe extern "C" fn(
                isolate: *mut root::v8::Isolate,
                type_: root::v8::GCType,
                flags: root::v8::GCCallbackFlags,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        /// Indicates that this call is happening before waiting.
        pub const Isolate_AtomicsWaitEvent_kStartWait: root::v8::Isolate_AtomicsWaitEvent = 0;
        /// `Atomics.wait()` finished because of an `Atomics.wake()` call.
        pub const Isolate_AtomicsWaitEvent_kWokenUp: root::v8::Isolate_AtomicsWaitEvent = 1;
        /// `Atomics.wait()` finished because it timed out.
        pub const Isolate_AtomicsWaitEvent_kTimedOut: root::v8::Isolate_AtomicsWaitEvent = 2;
        /// `Atomics.wait()` was interrupted through |TerminateExecution()|.
        pub const Isolate_AtomicsWaitEvent_kTerminatedExecution:
            root::v8::Isolate_AtomicsWaitEvent = 3;
        /// `Atomics.wait()` was stopped through |AtomicsWaitWakeHandle|.
        pub const Isolate_AtomicsWaitEvent_kAPIStopped: root::v8::Isolate_AtomicsWaitEvent = 4;
        /// `Atomics.wait()` did not wait, as the initial condition was not met.
        pub const Isolate_AtomicsWaitEvent_kNotEqual: root::v8::Isolate_AtomicsWaitEvent = 5;
        /// Use for |AtomicsWaitCallback| to indicate the type of event it receives.
        pub type Isolate_AtomicsWaitEvent = i32;
        /// Passed to |AtomicsWaitCallback| as a means of stopping an ongoing
        /// `Atomics.wait` call.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Isolate_AtomicsWaitWakeHandle {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Isolate_AtomicsWaitWakeHandle() {
            assert_eq!(
                ::std::mem::size_of::<Isolate_AtomicsWaitWakeHandle>(),
                1usize,
                concat!("Size of: ", stringify!(Isolate_AtomicsWaitWakeHandle))
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate_AtomicsWaitWakeHandle>(),
                1usize,
                concat!("Alignment of ", stringify!(Isolate_AtomicsWaitWakeHandle))
            );
        }
        extern "C" {
            /// Stop this `Atomics.wait()` call and call the |AtomicsWaitCallback|
            /// with |kAPIStopped|.
            ///
            /// This function may be called from another thread. The caller has to ensure
            /// through proper synchronization that it is not called after
            /// the finishing |AtomicsWaitCallback|.
            ///
            /// Note that the ECMAScript specification does not plan for the possibility
            /// of wakeups that are neither coming from a timeout or an `Atomics.wake()`
            /// call, so this may invalidate assumptions made by existing code.
            /// The embedder may accordingly wish to schedule an exception in the
            /// finishing |AtomicsWaitCallback|.
            #[link_name = "\u{1}?Wake@AtomicsWaitWakeHandle@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_AtomicsWaitWakeHandle_Wake(
                this: *mut root::v8::Isolate_AtomicsWaitWakeHandle,
            );
        }
        impl Isolate_AtomicsWaitWakeHandle {
            #[inline]
            pub unsafe fn Wake(&mut self) {
                Isolate_AtomicsWaitWakeHandle_Wake(self)
            }
        }
        /// Embedder callback for `Atomics.wait()` that can be added through
        /// |SetAtomicsWaitCallback|.
        ///
        /// This will be called just before starting to wait with the |event| value
        /// |kStartWait| and after finishing waiting with one of the other
        /// values of |AtomicsWaitEvent| inside of an `Atomics.wait()` call.
        ///
        /// |array_buffer| will refer to the underlying SharedArrayBuffer,
        /// |offset_in_bytes| to the location of the waited-on memory address inside
        /// the SharedArrayBuffer.
        ///
        /// |value| and |timeout_in_ms| will be the values passed to
        /// the `Atomics.wait()` call. If no timeout was used, |timeout_in_ms|
        /// will be `INFINITY`.
        ///
        /// In the |kStartWait| callback, |stop_handle| will be an object that
        /// is only valid until the corresponding finishing callback and that
        /// can be used to stop the wait process while it is happening.
        ///
        /// This callback may schedule exceptions, *unless* |event| is equal to
        /// |kTerminatedExecution|.
        pub type Isolate_AtomicsWaitCallback = ::std::option::Option<
            unsafe extern "C" fn(
                event: root::v8::Isolate_AtomicsWaitEvent,
                array_buffer: root::v8::Local<root::v8::SharedArrayBuffer>,
                offset_in_bytes: usize,
                value: i32,
                timeout_in_ms: f64,
                stop_handle: *mut root::v8::Isolate_AtomicsWaitWakeHandle,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        pub type Isolate_GetExternallyAllocatedMemoryInBytesCallback =
            ::std::option::Option<unsafe extern "C" fn() -> usize>;
        #[test]
        fn bindgen_test_layout_Isolate() {
            assert_eq!(
                ::std::mem::size_of::<Isolate>(),
                1usize,
                concat!("Size of: ", stringify!(Isolate))
            );
            assert_eq!(
                ::std::mem::align_of::<Isolate>(),
                1usize,
                concat!("Alignment of ", stringify!(Isolate))
            );
        }
        extern "C" {
            /// Allocates a new isolate but does not initialize it. Does not change the
            /// currently entered isolate.
            ///
            /// Only Isolate::GetData() and Isolate::SetData(), which access the
            /// embedder-controlled parts of the isolate, are allowed to be called on the
            /// uninitialized isolate. To initialize the isolate, call
            /// Isolate::Initialize().
            ///
            /// When an isolate is no longer used its resources should be freed
            /// by calling Dispose().  Using the delete operator is not allowed.
            ///
            /// V8::Initialize() must have run prior to this.
            #[link_name = "\u{1}?Allocate@Isolate@v8@@SAPEAV12@XZ"]
            pub fn Isolate_Allocate() -> *mut root::v8::Isolate;
        }
        extern "C" {
            /// Initialize an Isolate previously allocated by Isolate::Allocate().
            #[link_name = "\u{1}?Initialize@Isolate@v8@@SAXPEAV12@AEBUCreateParams@12@@Z"]
            pub fn Isolate_Initialize(
                isolate: *mut root::v8::Isolate,
                params: *const root::v8::Isolate_CreateParams,
            );
        }
        extern "C" {
            /// Creates a new isolate.  Does not change the currently entered
            /// isolate.
            ///
            /// When an isolate is no longer used its resources should be freed
            /// by calling Dispose().  Using the delete operator is not allowed.
            ///
            /// V8::Initialize() must have run prior to this.
            #[link_name = "\u{1}?New@Isolate@v8@@SAPEAV12@AEBUCreateParams@12@@Z"]
            pub fn Isolate_New(
                params: *const root::v8::Isolate_CreateParams,
            ) -> *mut root::v8::Isolate;
        }
        extern "C" {
            /// Returns the entered isolate for the current thread or NULL in
            /// case there is no current isolate.
            ///
            /// This method must not be invoked before V8::Initialize() was invoked.
            #[link_name = "\u{1}?GetCurrent@Isolate@v8@@SAPEAV12@XZ"]
            pub fn Isolate_GetCurrent() -> *mut root::v8::Isolate;
        }
        extern "C" {
            #[link_name = "\u{1}?SetAbortOnUncaughtExceptionCallback@Isolate@v8@@QEAAXP6A_NPEAV12@@Z@Z"]
            pub fn Isolate_SetAbortOnUncaughtExceptionCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_AbortOnUncaughtExceptionCallback,
            );
        }
        extern "C" {
            /// This specifies the callback called by the upcoming dynamic
            /// import() language feature to load modules.
            #[link_name = "\u{1}?SetHostImportModuleDynamicallyCallback@Isolate@v8@@QEAAXP6A?AV?$MaybeLocal@VPromise@v8@@@2@V?$Local@VContext@v8@@@2@V?$Local@VScriptOrModule@v8@@@2@V?$Local@VString@v8@@@2@@Z@Z"]
            pub fn Isolate_SetHostImportModuleDynamicallyCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::HostImportModuleDynamicallyCallback,
            );
        }
        extern "C" {
            /// This specifies the callback called by the upcoming importa.meta
            /// language feature to retrieve host-defined meta data for a module.
            #[link_name = "\u{1}?SetHostInitializeImportMetaObjectCallback@Isolate@v8@@QEAAXP6AXV?$Local@VContext@v8@@@2@V?$Local@VModule@v8@@@2@V?$Local@VObject@v8@@@2@@Z@Z"]
            pub fn Isolate_SetHostInitializeImportMetaObjectCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::HostInitializeImportMetaObjectCallback,
            );
        }
        extern "C" {
            /// Optional notification that the system is running low on memory.
            /// V8 uses these notifications to guide heuristics.
            /// It is allowed to call this function from another thread while
            /// the isolate is executing long running JavaScript code.
            #[link_name = "\u{1}?MemoryPressureNotification@Isolate@v8@@QEAAXW4MemoryPressureLevel@2@@Z"]
            pub fn Isolate_MemoryPressureNotification(
                this: *mut root::v8::Isolate,
                level: root::v8::MemoryPressureLevel,
            );
        }
        extern "C" {
            /// Sets this isolate as the entered one for the current thread.
            /// Saves the previously entered one (if any), so that it can be
            /// restored when exiting.  Re-entering an isolate is allowed.
            #[link_name = "\u{1}?Enter@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_Enter(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Exits this isolate by restoring the previously entered one in the
            /// current thread.  The isolate may still stay the same, if it was
            /// entered more than once.
            ///
            /// Requires: this == Isolate::GetCurrent().
            #[link_name = "\u{1}?Exit@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_Exit(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Disposes the isolate.  The isolate must not be entered by any
            /// thread to be disposable.
            #[link_name = "\u{1}?Dispose@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_Dispose(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Dumps activated low-level V8 internal stats. This can be used instead
            /// of performing a full isolate disposal.
            #[link_name = "\u{1}?DumpAndResetStats@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_DumpAndResetStats(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Discards all V8 thread-specific data for the Isolate. Should be used
            /// if a thread is terminating and it has used an Isolate that will outlive
            /// the thread -- all thread-specific data for an Isolate is discarded when
            /// an Isolate is disposed so this call is pointless if an Isolate is about
            /// to be Disposed.
            #[link_name = "\u{1}?DiscardThreadSpecificMetadata@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_DiscardThreadSpecificMetadata(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Get statistics about the heap memory usage.
            #[link_name = "\u{1}?GetHeapStatistics@Isolate@v8@@QEAAXPEAVHeapStatistics@2@@Z"]
            pub fn Isolate_GetHeapStatistics(
                this: *mut root::v8::Isolate,
                heap_statistics: *mut root::v8::HeapStatistics,
            );
        }
        extern "C" {
            /// Returns the number of spaces in the heap.
            #[link_name = "\u{1}?NumberOfHeapSpaces@Isolate@v8@@QEAA_KXZ"]
            pub fn Isolate_NumberOfHeapSpaces(this: *mut root::v8::Isolate) -> usize;
        }
        extern "C" {
            /// Get the memory usage of a space in the heap.
            ///
            /// \param space_statistics The HeapSpaceStatistics object to fill in
            /// statistics.
            /// \param index The index of the space to get statistics from, which ranges
            /// from 0 to NumberOfHeapSpaces() - 1.
            /// \returns true on success.
            #[link_name = "\u{1}?GetHeapSpaceStatistics@Isolate@v8@@QEAA_NPEAVHeapSpaceStatistics@2@_K@Z"]
            pub fn Isolate_GetHeapSpaceStatistics(
                this: *mut root::v8::Isolate,
                space_statistics: *mut root::v8::HeapSpaceStatistics,
                index: usize,
            ) -> bool;
        }
        extern "C" {
            /// Returns the number of types of objects tracked in the heap at GC.
            #[link_name = "\u{1}?NumberOfTrackedHeapObjectTypes@Isolate@v8@@QEAA_KXZ"]
            pub fn Isolate_NumberOfTrackedHeapObjectTypes(this: *mut root::v8::Isolate) -> usize;
        }
        extern "C" {
            /// Get statistics about objects in the heap.
            ///
            /// \param object_statistics The HeapObjectStatistics object to fill in
            /// statistics of objects of given type, which were live in the previous GC.
            /// \param type_index The index of the type of object to fill details about,
            /// which ranges from 0 to NumberOfTrackedHeapObjectTypes() - 1.
            /// \returns true on success.
            #[link_name = "\u{1}?GetHeapObjectStatisticsAtLastGC@Isolate@v8@@QEAA_NPEAVHeapObjectStatistics@2@_K@Z"]
            pub fn Isolate_GetHeapObjectStatisticsAtLastGC(
                this: *mut root::v8::Isolate,
                object_statistics: *mut root::v8::HeapObjectStatistics,
                type_index: usize,
            ) -> bool;
        }
        extern "C" {
            /// Get statistics about code and its metadata in the heap.
            ///
            /// \param object_statistics The HeapCodeStatistics object to fill in
            /// statistics of code, bytecode and their metadata.
            /// \returns true on success.
            #[link_name = "\u{1}?GetHeapCodeAndMetadataStatistics@Isolate@v8@@QEAA_NPEAVHeapCodeStatistics@2@@Z"]
            pub fn Isolate_GetHeapCodeAndMetadataStatistics(
                this: *mut root::v8::Isolate,
                object_statistics: *mut root::v8::HeapCodeStatistics,
            ) -> bool;
        }
        extern "C" {
            /// Get a call stack sample from the isolate.
            /// \param state Execution state.
            /// \param frames Caller allocated buffer to store stack frames.
            /// \param frames_limit Maximum number of frames to capture. The buffer must
            /// be large enough to hold the number of frames.
            /// \param sample_info The sample info is filled up by the function
            /// provides number of actual captured stack frames and
            /// the current VM state.
            /// \note GetStackSample should only be called when the JS thread is paused or
            /// interrupted. Otherwise the behavior is undefined.
            #[link_name = "\u{1}?GetStackSample@Isolate@v8@@QEAAXAEBURegisterState@2@PEAPEAX_KPEAUSampleInfo@2@@Z"]
            pub fn Isolate_GetStackSample(
                this: *mut root::v8::Isolate,
                state: *const root::v8::RegisterState,
                frames: *mut *mut ::std::os::raw::c_void,
                frames_limit: usize,
                sample_info: *mut root::v8::SampleInfo,
            );
        }
        extern "C" {
            /// Returns the number of phantom handles without callbacks that were reset
            /// by the garbage collector since the last call to this function.
            #[link_name = "\u{1}?NumberOfPhantomHandleResetsSinceLastCall@Isolate@v8@@QEAA_KXZ"]
            pub fn Isolate_NumberOfPhantomHandleResetsSinceLastCall(
                this: *mut root::v8::Isolate,
            ) -> usize;
        }
        extern "C" {
            /// Returns heap profiler for this isolate. Will return NULL until the isolate
            /// is initialized.
            #[link_name = "\u{1}?GetHeapProfiler@Isolate@v8@@QEAAPEAVHeapProfiler@2@XZ"]
            pub fn Isolate_GetHeapProfiler(
                this: *mut root::v8::Isolate,
            ) -> *mut root::v8::HeapProfiler;
        }
        extern "C" {
            /// Tells the VM whether the embedder is idle or not.
            #[link_name = "\u{1}?SetIdle@Isolate@v8@@QEAAX_N@Z"]
            pub fn Isolate_SetIdle(this: *mut root::v8::Isolate, is_idle: bool);
        }
        extern "C" {
            /// Returns true if this isolate has a current context.
            #[link_name = "\u{1}?InContext@Isolate@v8@@QEAA_NXZ"]
            pub fn Isolate_InContext(this: *mut root::v8::Isolate) -> bool;
        }
        extern "C" {
            /// Returns the context of the currently running JavaScript, or the context
            /// on the top of the stack if no JavaScript is running.
            #[link_name = "\u{1}?GetCurrentContext@Isolate@v8@@QEAA?AV?$Local@VContext@v8@@@2@XZ"]
            pub fn Isolate_GetCurrentContext(
                this: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Context>;
        }
        extern "C" {
            /// Returns the last context entered through V8's C++ API.
            #[link_name = "\u{1}?GetEnteredContext@Isolate@v8@@QEAA?AV?$Local@VContext@v8@@@2@XZ"]
            pub fn Isolate_GetEnteredContext(
                this: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Context>;
        }
        extern "C" {
            /// Returns either the last context entered through V8's C++ API, or the
            /// context of the currently running microtask while processing microtasks.
            /// If a context is entered while executing a microtask, that context is
            /// returned.
            #[link_name = "\u{1}?GetEnteredOrMicrotaskContext@Isolate@v8@@QEAA?AV?$Local@VContext@v8@@@2@XZ"]
            pub fn Isolate_GetEnteredOrMicrotaskContext(
                this: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Context>;
        }
        extern "C" {
            /// Returns the Context that corresponds to the Incumbent realm in HTML spec.
            /// https://html.spec.whatwg.org/multipage/webappapis.html#incumbent
            #[link_name = "\u{1}?GetIncumbentContext@Isolate@v8@@QEAA?AV?$Local@VContext@v8@@@2@XZ"]
            pub fn Isolate_GetIncumbentContext(
                this: *mut root::v8::Isolate,
            ) -> root::v8::Local<root::v8::Context>;
        }
        extern "C" {
            /// Schedules an exception to be thrown when returning to JavaScript.  When an
            /// exception has been scheduled it is illegal to invoke any JavaScript
            /// operation; the caller must return immediately and only after the exception
            /// has been handled does it become legal to invoke JavaScript operations.
            #[link_name = "\u{1}?ThrowException@Isolate@v8@@QEAA?AV?$Local@VValue@v8@@@2@V32@@Z"]
            pub fn Isolate_ThrowException(
                this: *mut root::v8::Isolate,
                exception: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Enables the host application to receive a notification before a
            /// garbage collection. Allocations are allowed in the callback function,
            /// but the callback is not re-entrant: if the allocation inside it will
            /// trigger the garbage collection, the callback won't be called again.
            /// It is possible to specify the GCType filter for your callback. But it is
            /// not possible to register the same callback function two times with
            /// different GCType filters.
            #[link_name = "\u{1}?AddGCPrologueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@PEAX@Z31@Z"]
            pub fn Isolate_AddGCPrologueCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
                gc_type_filter: root::v8::GCType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?AddGCPrologueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@@Z1@Z"]
            pub fn Isolate_AddGCPrologueCallback1(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GCCallback,
                gc_type_filter: root::v8::GCType,
            );
        }
        extern "C" {
            /// This function removes callback which was installed by
            /// AddGCPrologueCallback function.
            #[link_name = "\u{1}?RemoveGCPrologueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@PEAX@Z3@Z"]
            pub fn Isolate_RemoveGCPrologueCallback(
                this: *mut root::v8::Isolate,
                arg1: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RemoveGCPrologueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@@Z@Z"]
            pub fn Isolate_RemoveGCPrologueCallback1(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GCCallback,
            );
        }
        extern "C" {
            /// Sets the embedder heap tracer for the isolate.
            #[link_name = "\u{1}?SetEmbedderHeapTracer@Isolate@v8@@QEAAXPEAVEmbedderHeapTracer@2@@Z"]
            pub fn Isolate_SetEmbedderHeapTracer(
                this: *mut root::v8::Isolate,
                tracer: *mut root::v8::EmbedderHeapTracer,
            );
        }
        extern "C" {
            /// Set a new |AtomicsWaitCallback|. This overrides an earlier
            /// |AtomicsWaitCallback|, if there was any. If |callback| is nullptr,
            /// this unsets the callback. |data| will be passed to the callback
            /// as its last parameter.
            #[link_name = "\u{1}?SetAtomicsWaitCallback@Isolate@v8@@QEAAXP6AXW4AtomicsWaitEvent@12@V?$Local@VSharedArrayBuffer@v8@@@2@_KHNPEAVAtomicsWaitWakeHandle@12@PEAX@Z4@Z"]
            pub fn Isolate_SetAtomicsWaitCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_AtomicsWaitCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            /// Enables the host application to receive a notification after a
            /// garbage collection. Allocations are allowed in the callback function,
            /// but the callback is not re-entrant: if the allocation inside it will
            /// trigger the garbage collection, the callback won't be called again.
            /// It is possible to specify the GCType filter for your callback. But it is
            /// not possible to register the same callback function two times with
            /// different GCType filters.
            #[link_name = "\u{1}?AddGCEpilogueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@PEAX@Z31@Z"]
            pub fn Isolate_AddGCEpilogueCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
                gc_type_filter: root::v8::GCType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?AddGCEpilogueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@@Z1@Z"]
            pub fn Isolate_AddGCEpilogueCallback1(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GCCallback,
                gc_type_filter: root::v8::GCType,
            );
        }
        extern "C" {
            /// This function removes callback which was installed by
            /// AddGCEpilogueCallback function.
            #[link_name = "\u{1}?RemoveGCEpilogueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@PEAX@Z3@Z"]
            pub fn Isolate_RemoveGCEpilogueCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RemoveGCEpilogueCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4GCType@2@W4GCCallbackFlags@2@@Z@Z"]
            pub fn Isolate_RemoveGCEpilogueCallback1(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GCCallback,
            );
        }
        extern "C" {
            /// Set the callback that tells V8 how much memory is currently allocated
            /// externally of the V8 heap. Ideally this memory is somehow connected to V8
            /// objects and may get freed-up when the corresponding V8 objects get
            /// collected by a V8 garbage collection.
            #[link_name = "\u{1}?SetGetExternallyAllocatedMemoryInBytesCallback@Isolate@v8@@QEAAXP6A_KXZ@Z"]
            pub fn Isolate_SetGetExternallyAllocatedMemoryInBytesCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_GetExternallyAllocatedMemoryInBytesCallback,
            );
        }
        extern "C" {
            /// Forcefully terminate the current thread of JavaScript execution
            /// in the given isolate.
            ///
            /// This method can be used by any thread even if that thread has not
            /// acquired the V8 lock with a Locker object.
            #[link_name = "\u{1}?TerminateExecution@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_TerminateExecution(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Is V8 terminating JavaScript execution.
            ///
            /// Returns true if JavaScript execution is currently terminating
            /// because of a call to TerminateExecution.  In that case there are
            /// still JavaScript frames on the stack and the termination
            /// exception is still active.
            #[link_name = "\u{1}?IsExecutionTerminating@Isolate@v8@@QEAA_NXZ"]
            pub fn Isolate_IsExecutionTerminating(this: *mut root::v8::Isolate) -> bool;
        }
        extern "C" {
            /// Resume execution capability in the given isolate, whose execution
            /// was previously forcefully terminated using TerminateExecution().
            ///
            /// When execution is forcefully terminated using TerminateExecution(),
            /// the isolate can not resume execution until all JavaScript frames
            /// have propagated the uncatchable exception which is generated.  This
            /// method allows the program embedding the engine to handle the
            /// termination event and resume execution capability, even if
            /// JavaScript frames remain on the stack.
            ///
            /// This method can be used by any thread even if that thread has not
            /// acquired the V8 lock with a Locker object.
            #[link_name = "\u{1}?CancelTerminateExecution@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_CancelTerminateExecution(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Request V8 to interrupt long running JavaScript code and invoke
            /// the given |callback| passing the given |data| to it. After |callback|
            /// returns control will be returned to the JavaScript code.
            /// There may be a number of interrupt requests in flight.
            /// Can be called from another thread without acquiring a |Locker|.
            /// Registered |callback| must not reenter interrupted Isolate.
            #[link_name = "\u{1}?RequestInterrupt@Isolate@v8@@QEAAXP6AXPEAV12@PEAX@Z1@Z"]
            pub fn Isolate_RequestInterrupt(
                this: *mut root::v8::Isolate,
                callback: root::v8::InterruptCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            /// Request garbage collection in this Isolate. It is only valid to call this
            /// function if --expose_gc was specified.
            ///
            /// This should only be used for testing purposes and not to enforce a garbage
            /// collection schedule. It has strong negative impact on the garbage
            /// collection performance. Use IdleNotificationDeadline() or
            /// LowMemoryNotification() instead to influence the garbage collection
            /// schedule.
            #[link_name = "\u{1}?RequestGarbageCollectionForTesting@Isolate@v8@@QEAAXW4GarbageCollectionType@12@@Z"]
            pub fn Isolate_RequestGarbageCollectionForTesting(
                this: *mut root::v8::Isolate,
                type_: root::v8::Isolate_GarbageCollectionType,
            );
        }
        extern "C" {
            /// Set the callback to invoke for logging event.
            #[link_name = "\u{1}?SetEventLogger@Isolate@v8@@QEAAXP6AXPEBDH@Z@Z"]
            pub fn Isolate_SetEventLogger(
                this: *mut root::v8::Isolate,
                that: root::v8::LogEventCallback,
            );
        }
        extern "C" {
            /// Adds a callback to notify the host application right before a script
            /// is about to run. If a script re-enters the runtime during executing, the
            /// BeforeCallEnteredCallback is invoked for each re-entrance.
            /// Executing scripts inside the callback will re-trigger the callback.
            #[link_name = "\u{1}?AddBeforeCallEnteredCallback@Isolate@v8@@QEAAXP6AXPEAV12@@Z@Z"]
            pub fn Isolate_AddBeforeCallEnteredCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::BeforeCallEnteredCallback,
            );
        }
        extern "C" {
            /// Removes callback that was installed by AddBeforeCallEnteredCallback.
            #[link_name = "\u{1}?RemoveBeforeCallEnteredCallback@Isolate@v8@@QEAAXP6AXPEAV12@@Z@Z"]
            pub fn Isolate_RemoveBeforeCallEnteredCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::BeforeCallEnteredCallback,
            );
        }
        extern "C" {
            /// Adds a callback to notify the host application when a script finished
            /// running.  If a script re-enters the runtime during executing, the
            /// CallCompletedCallback is only invoked when the outer-most script
            /// execution ends.  Executing scripts inside the callback do not trigger
            /// further callbacks.
            #[link_name = "\u{1}?AddCallCompletedCallback@Isolate@v8@@QEAAXP6AXPEAV12@@Z@Z"]
            pub fn Isolate_AddCallCompletedCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::CallCompletedCallback,
            );
        }
        extern "C" {
            /// Removes callback that was installed by AddCallCompletedCallback.
            #[link_name = "\u{1}?RemoveCallCompletedCallback@Isolate@v8@@QEAAXP6AXPEAV12@@Z@Z"]
            pub fn Isolate_RemoveCallCompletedCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::CallCompletedCallback,
            );
        }
        extern "C" {
            /// Set the PromiseHook callback for various promise lifecycle
            /// events.
            #[link_name = "\u{1}?SetPromiseHook@Isolate@v8@@QEAAXP6AXW4PromiseHookType@2@V?$Local@VPromise@v8@@@2@V?$Local@VValue@v8@@@2@@Z@Z"]
            pub fn Isolate_SetPromiseHook(
                this: *mut root::v8::Isolate,
                hook: root::v8::PromiseHook,
            );
        }
        extern "C" {
            /// Set callback to notify about promise reject with no handler, or
            /// revocation of such a previous notification once the handler is added.
            #[link_name = "\u{1}?SetPromiseRejectCallback@Isolate@v8@@QEAAXP6AXVPromiseRejectMessage@2@@Z@Z"]
            pub fn Isolate_SetPromiseRejectCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::PromiseRejectCallback,
            );
        }
        extern "C" {
            /// Runs the Microtask Work Queue until empty
            /// Any exceptions thrown by microtask callbacks are swallowed.
            #[link_name = "\u{1}?RunMicrotasks@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_RunMicrotasks(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Enqueues the callback to the Microtask Work Queue
            #[link_name = "\u{1}?EnqueueMicrotask@Isolate@v8@@QEAAXV?$Local@VFunction@v8@@@2@@Z"]
            pub fn Isolate_EnqueueMicrotask(
                this: *mut root::v8::Isolate,
                microtask: root::v8::Local<root::v8::Function>,
            );
        }
        extern "C" {
            /// Enqueues the callback to the Microtask Work Queue
            #[link_name = "\u{1}?EnqueueMicrotask@Isolate@v8@@QEAAXP6AXPEAX@Z0@Z"]
            pub fn Isolate_EnqueueMicrotask1(
                this: *mut root::v8::Isolate,
                callback: root::v8::MicrotaskCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            /// Controls how Microtasks are invoked. See MicrotasksPolicy for details.
            #[link_name = "\u{1}?SetMicrotasksPolicy@Isolate@v8@@QEAAXW4MicrotasksPolicy@2@@Z"]
            pub fn Isolate_SetMicrotasksPolicy(
                this: *mut root::v8::Isolate,
                policy: root::v8::MicrotasksPolicy,
            );
        }
        extern "C" {
            /// Returns the policy controlling how Microtasks are invoked.
            #[link_name = "\u{1}?GetMicrotasksPolicy@Isolate@v8@@QEBA?AW4MicrotasksPolicy@2@XZ"]
            pub fn Isolate_GetMicrotasksPolicy(
                this: *const root::v8::Isolate,
            ) -> root::v8::MicrotasksPolicy;
        }
        extern "C" {
            /// Adds a callback to notify the host application after
            /// microtasks were run. The callback is triggered by explicit RunMicrotasks
            /// call or automatic microtasks execution (see SetAutorunMicrotasks).
            ///
            /// Callback will trigger even if microtasks were attempted to run,
            /// but the microtasks queue was empty and no single microtask was actually
            /// executed.
            ///
            /// Executing scriptsinside the callback will not re-trigger microtasks and
            /// the callback.
            #[link_name = "\u{1}?AddMicrotasksCompletedCallback@Isolate@v8@@QEAAXP6AXPEAV12@@Z@Z"]
            pub fn Isolate_AddMicrotasksCompletedCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::MicrotasksCompletedCallback,
            );
        }
        extern "C" {
            /// Removes callback that was installed by AddMicrotasksCompletedCallback.
            #[link_name = "\u{1}?RemoveMicrotasksCompletedCallback@Isolate@v8@@QEAAXP6AXPEAV12@@Z@Z"]
            pub fn Isolate_RemoveMicrotasksCompletedCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::MicrotasksCompletedCallback,
            );
        }
        extern "C" {
            /// Sets a callback for counting the number of times a feature of V8 is used.
            #[link_name = "\u{1}?SetUseCounterCallback@Isolate@v8@@QEAAXP6AXPEAV12@W4UseCounterFeature@12@@Z@Z"]
            pub fn Isolate_SetUseCounterCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::Isolate_UseCounterCallback,
            );
        }
        extern "C" {
            /// Enables the host application to provide a mechanism for recording
            /// statistics counters.
            #[link_name = "\u{1}?SetCounterFunction@Isolate@v8@@QEAAXP6APEAHPEBD@Z@Z"]
            pub fn Isolate_SetCounterFunction(
                this: *mut root::v8::Isolate,
                arg1: root::v8::CounterLookupCallback,
            );
        }
        extern "C" {
            /// Enables the host application to provide a mechanism for recording
            /// histograms. The CreateHistogram function returns a
            /// histogram which will later be passed to the AddHistogramSample
            /// function.
            #[link_name = "\u{1}?SetCreateHistogramFunction@Isolate@v8@@QEAAXP6APEAXPEBDHH_K@Z@Z"]
            pub fn Isolate_SetCreateHistogramFunction(
                this: *mut root::v8::Isolate,
                arg1: root::v8::CreateHistogramCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetAddHistogramSampleFunction@Isolate@v8@@QEAAXP6AXPEAXH@Z@Z"]
            pub fn Isolate_SetAddHistogramSampleFunction(
                this: *mut root::v8::Isolate,
                arg1: root::v8::AddHistogramSampleCallback,
            );
        }
        extern "C" {
            /// Optional notification that the embedder is idle.
            /// V8 uses the notification to perform garbage collection.
            /// This call can be used repeatedly if the embedder remains idle.
            /// Returns true if the embedder should stop calling IdleNotificationDeadline
            /// until real work has been done.  This indicates that V8 has done
            /// as much cleanup as it will be able to do.
            ///
            /// The deadline_in_seconds argument specifies the deadline V8 has to finish
            /// garbage collection work. deadline_in_seconds is compared with
            /// MonotonicallyIncreasingTime() and should be based on the same timebase as
            /// that function. There is no guarantee that the actual work will be done
            /// within the time limit.
            #[link_name = "\u{1}?IdleNotificationDeadline@Isolate@v8@@QEAA_NN@Z"]
            pub fn Isolate_IdleNotificationDeadline(
                this: *mut root::v8::Isolate,
                deadline_in_seconds: f64,
            ) -> bool;
        }
        extern "C" {
            /// Optional notification that the system is running low on memory.
            /// V8 uses these notifications to attempt to free memory.
            #[link_name = "\u{1}?LowMemoryNotification@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_LowMemoryNotification(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Optional notification that a context has been disposed. V8 uses
            /// these notifications to guide the GC heuristic. Returns the number
            /// of context disposals - including this one - since the last time
            /// V8 had a chance to clean up.
            ///
            /// The optional parameter |dependant_context| specifies whether the disposed
            /// context was depending on state from other contexts or not.
            #[link_name = "\u{1}?ContextDisposedNotification@Isolate@v8@@QEAAH_N@Z"]
            pub fn Isolate_ContextDisposedNotification(
                this: *mut root::v8::Isolate,
                dependant_context: bool,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            /// Optional notification that the isolate switched to the foreground.
            /// V8 uses these notifications to guide heuristics.
            #[link_name = "\u{1}?IsolateInForegroundNotification@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_IsolateInForegroundNotification(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Optional notification that the isolate switched to the background.
            /// V8 uses these notifications to guide heuristics.
            #[link_name = "\u{1}?IsolateInBackgroundNotification@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_IsolateInBackgroundNotification(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Optional notification which will enable the memory savings mode.
            /// V8 uses this notification to guide heuristics which may result in a
            /// smaller memory footprint at the cost of reduced runtime performance.
            #[link_name = "\u{1}?EnableMemorySavingsMode@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_EnableMemorySavingsMode(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Optional notification which will disable the memory savings mode.
            #[link_name = "\u{1}?DisableMemorySavingsMode@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_DisableMemorySavingsMode(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Optional notification to tell V8 the current performance requirements
            /// of the embedder based on RAIL.
            /// V8 uses these notifications to guide heuristics.
            /// This is an unfinished experimental feature. Semantics and implementation
            /// may change frequently.
            #[link_name = "\u{1}?SetRAILMode@Isolate@v8@@QEAAXW4RAILMode@2@@Z"]
            pub fn Isolate_SetRAILMode(this: *mut root::v8::Isolate, rail_mode: root::v8::RAILMode);
        }
        extern "C" {
            /// Optional notification to tell V8 the current isolate is used for debugging
            /// and requires higher heap limit.
            #[link_name = "\u{1}?IncreaseHeapLimitForDebugging@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_IncreaseHeapLimitForDebugging(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Restores the original heap limit after IncreaseHeapLimitForDebugging().
            #[link_name = "\u{1}?RestoreOriginalHeapLimit@Isolate@v8@@QEAAXXZ"]
            pub fn Isolate_RestoreOriginalHeapLimit(this: *mut root::v8::Isolate);
        }
        extern "C" {
            /// Returns true if the heap limit was increased for debugging and the
            /// original heap limit was not restored yet.
            #[link_name = "\u{1}?IsHeapLimitIncreasedForDebugging@Isolate@v8@@QEAA_NXZ"]
            pub fn Isolate_IsHeapLimitIncreasedForDebugging(this: *mut root::v8::Isolate) -> bool;
        }
        extern "C" {
            /// Allows the host application to provide the address of a function that is
            /// notified each time code is added, moved or removed.
            ///
            /// \param options options for the JIT code event handler.
            /// \param event_handler the JIT code event handler, which will be invoked
            /// each time code is added, moved or removed.
            /// \note \p event_handler won't get notified of existent code.
            /// \note since code removal notifications are not currently issued, the
            /// \p event_handler may get notifications of code that overlaps earlier
            /// code notifications. This happens when code areas are reused, and the
            /// earlier overlapping code areas should therefore be discarded.
            /// \note the events passed to \p event_handler and the strings they point to
            /// are not guaranteed to live past each call. The \p event_handler must
            /// copy strings and other parameters it needs to keep around.
            /// \note the set of events declared in JitCodeEvent::EventType is expected to
            /// grow over time, and the JitCodeEvent structure is expected to accrue
            /// new members. The \p event_handler function must ignore event codes
            /// it does not recognize to maintain future compatibility.
            /// \note Use Isolate::CreateParams to get events for code executed during
            /// Isolate setup.
            #[link_name = "\u{1}?SetJitCodeEventHandler@Isolate@v8@@QEAAXW4JitCodeEventOptions@2@P6AXPEBUJitCodeEvent@2@@Z@Z"]
            pub fn Isolate_SetJitCodeEventHandler(
                this: *mut root::v8::Isolate,
                options: root::v8::JitCodeEventOptions,
                event_handler: root::v8::JitCodeEventHandler,
            );
        }
        extern "C" {
            /// Modifies the stack limit for this Isolate.
            ///
            /// \param stack_limit An address beyond which the Vm's stack may not grow.
            ///
            /// \note  If you are using threads then you should hold the V8::Locker lock
            /// while setting the stack limit and you must set a non-default stack
            /// limit separately for each thread.
            #[link_name = "\u{1}?SetStackLimit@Isolate@v8@@QEAAX_K@Z"]
            pub fn Isolate_SetStackLimit(this: *mut root::v8::Isolate, stack_limit: usize);
        }
        extern "C" {
            /// Returns a memory range that can potentially contain jitted code. Code for
            /// V8's 'builtins' will not be in this range if embedded builtins is enabled.
            /// Instead, see GetBuiltinsCodeRange.
            ///
            /// On Win64, embedders are advised to install function table callbacks for
            /// these ranges, as default SEH won't be able to unwind through jitted code.
            ///
            /// The first page of the code range is reserved for the embedder and is
            /// committed, writable, and executable.
            ///
            /// Might be empty on other platforms.
            ///
            /// https://code.google.com/p/v8/issues/detail?id=3598
            #[link_name = "\u{1}?GetCodeRange@Isolate@v8@@QEAAXPEAPEAXPEA_K@Z"]
            pub fn Isolate_GetCodeRange(
                this: *mut root::v8::Isolate,
                start: *mut *mut ::std::os::raw::c_void,
                length_in_bytes: *mut usize,
            );
        }
        extern "C" {
            /// Returns a memory range containing the code for V8's builtin functions
            /// which are shared across isolates.
            ///
            /// If embedded builtins are disabled, then the memory range will be a null
            /// pointer with 0 length.
            #[link_name = "\u{1}?GetBuiltinsCodeRange@Isolate@v8@@QEAA?AUMemoryRange@2@XZ"]
            pub fn Isolate_GetBuiltinsCodeRange(
                this: *mut root::v8::Isolate,
            ) -> root::v8::MemoryRange;
        }
        extern "C" {
            /// Set the callback to invoke in case of fatal errors.
            #[link_name = "\u{1}?SetFatalErrorHandler@Isolate@v8@@QEAAXP6AXPEBD0@Z@Z"]
            pub fn Isolate_SetFatalErrorHandler(
                this: *mut root::v8::Isolate,
                that: root::v8::FatalErrorCallback,
            );
        }
        extern "C" {
            /// Set the callback to invoke in case of OOM errors.
            #[link_name = "\u{1}?SetOOMErrorHandler@Isolate@v8@@QEAAXP6AXPEBD_N@Z@Z"]
            pub fn Isolate_SetOOMErrorHandler(
                this: *mut root::v8::Isolate,
                that: root::v8::OOMErrorCallback,
            );
        }
        extern "C" {
            /// Add a callback to invoke in case the heap size is close to the heap limit.
            /// If multiple callbacks are added, only the most recently added callback is
            /// invoked.
            #[link_name = "\u{1}?AddNearHeapLimitCallback@Isolate@v8@@QEAAXP6A_KPEAX_K1@Z0@Z"]
            pub fn Isolate_AddNearHeapLimitCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::NearHeapLimitCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            /// Remove the given callback and restore the heap limit to the
            /// given limit. If the given limit is zero, then it is ignored.
            /// If the current heap size is greater than the given limit,
            /// then the heap limit is restored to the minimal limit that
            /// is possible for the current heap size.
            #[link_name = "\u{1}?RemoveNearHeapLimitCallback@Isolate@v8@@QEAAXP6A_KPEAX_K1@Z1@Z"]
            pub fn Isolate_RemoveNearHeapLimitCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::NearHeapLimitCallback,
                heap_limit: usize,
            );
        }
        extern "C" {
            /// Set the callback to invoke to check if code generation from
            /// strings should be allowed.
            #[link_name = "\u{1}?SetAllowCodeGenerationFromStringsCallback@Isolate@v8@@QEAAXP6A_NV?$Local@VContext@v8@@@2@V?$Local@VString@v8@@@2@@Z@Z"]
            pub fn Isolate_SetAllowCodeGenerationFromStringsCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::AllowCodeGenerationFromStringsCallback,
            );
        }
        extern "C" {
            /// Set the callback to invoke to check if wasm code generation should
            /// be allowed.
            #[link_name = "\u{1}?SetAllowWasmCodeGenerationCallback@Isolate@v8@@QEAAXP6A_NV?$Local@VContext@v8@@@2@V?$Local@VString@v8@@@2@@Z@Z"]
            pub fn Isolate_SetAllowWasmCodeGenerationCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::AllowWasmCodeGenerationCallback,
            );
        }
        extern "C" {
            /// Embedder over{ride|load} injection points for wasm APIs. The expectation
            /// is that the embedder sets them at most once.
            #[link_name = "\u{1}?SetWasmModuleCallback@Isolate@v8@@QEAAXP6A_NAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@Z@Z"]
            pub fn Isolate_SetWasmModuleCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::ExtensionCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetWasmInstanceCallback@Isolate@v8@@QEAAXP6A_NAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@Z@Z"]
            pub fn Isolate_SetWasmInstanceCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::ExtensionCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetWasmCompileStreamingCallback@Isolate@v8@@QEAAXP6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@Z@Z"]
            pub fn Isolate_SetWasmCompileStreamingCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::ApiImplementationCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetWasmStreamingCallback@Isolate@v8@@QEAAXP6AXAEBV?$FunctionCallbackInfo@VValue@v8@@@2@@Z@Z"]
            pub fn Isolate_SetWasmStreamingCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::WasmStreamingCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetWasmThreadsEnabledCallback@Isolate@v8@@QEAAXP6A_NV?$Local@VContext@v8@@@2@@Z@Z"]
            pub fn Isolate_SetWasmThreadsEnabledCallback(
                this: *mut root::v8::Isolate,
                callback: root::v8::WasmThreadsEnabledCallback,
            );
        }
        extern "C" {
            /// Check if V8 is dead and therefore unusable.  This is the case after
            /// fatal errors such as out-of-memory situations.
            #[link_name = "\u{1}?IsDead@Isolate@v8@@QEAA_NXZ"]
            pub fn Isolate_IsDead(this: *mut root::v8::Isolate) -> bool;
        }
        extern "C" {
            /// Adds a message listener (errors only).
            ///
            /// The same message listener can be added more than once and in that
            /// case it will be called more than once for each message.
            ///
            /// If data is specified, it will be passed to the callback when it is called.
            /// Otherwise, the exception object will be passed to the callback instead.
            #[link_name = "\u{1}?AddMessageListener@Isolate@v8@@QEAA_NP6AXV?$Local@VMessage@v8@@@2@V?$Local@VValue@v8@@@2@@Z1@Z"]
            pub fn Isolate_AddMessageListener(
                this: *mut root::v8::Isolate,
                that: root::v8::MessageCallback,
                data: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            /// Adds a message listener.
            ///
            /// The same message listener can be added more than once and in that
            /// case it will be called more than once for each message.
            ///
            /// If data is specified, it will be passed to the callback when it is called.
            /// Otherwise, the exception object will be passed to the callback instead.
            ///
            /// A listener can listen for particular error levels by providing a mask.
            #[link_name = "\u{1}?AddMessageListenerWithErrorLevel@Isolate@v8@@QEAA_NP6AXV?$Local@VMessage@v8@@@2@V?$Local@VValue@v8@@@2@@ZH1@Z"]
            pub fn Isolate_AddMessageListenerWithErrorLevel(
                this: *mut root::v8::Isolate,
                that: root::v8::MessageCallback,
                message_levels: ::std::os::raw::c_int,
                data: root::v8::Local<root::v8::Value>,
            ) -> bool;
        }
        extern "C" {
            /// Remove all message listeners from the specified callback function.
            #[link_name = "\u{1}?RemoveMessageListeners@Isolate@v8@@QEAAXP6AXV?$Local@VMessage@v8@@@2@V?$Local@VValue@v8@@@2@@Z@Z"]
            pub fn Isolate_RemoveMessageListeners(
                this: *mut root::v8::Isolate,
                that: root::v8::MessageCallback,
            );
        }
        extern "C" {
            /// Callback function for reporting failed access checks.
            #[link_name = "\u{1}?SetFailedAccessCheckCallbackFunction@Isolate@v8@@QEAAXP6AXV?$Local@VObject@v8@@@2@W4AccessType@2@V?$Local@VValue@v8@@@2@@Z@Z"]
            pub fn Isolate_SetFailedAccessCheckCallbackFunction(
                this: *mut root::v8::Isolate,
                arg1: root::v8::FailedAccessCheckCallback,
            );
        }
        extern "C" {
            /// Tells V8 to capture current stack trace when uncaught exception occurs
            /// and report it to the message listeners. The option is off by default.
            #[link_name = "\u{1}?SetCaptureStackTraceForUncaughtExceptions@Isolate@v8@@QEAAX_NHW4StackTraceOptions@StackTrace@2@@Z"]
            pub fn Isolate_SetCaptureStackTraceForUncaughtExceptions(
                this: *mut root::v8::Isolate,
                capture: bool,
                frame_limit: ::std::os::raw::c_int,
                options: root::v8::StackTrace_StackTraceOptions,
            );
        }
        extern "C" {
            /// Iterates through all external resources referenced from current isolate
            /// heap.  GC is not invoked prior to iterating, therefore there is no
            /// guarantee that visited objects are still alive.
            #[link_name = "\u{1}?VisitExternalResources@Isolate@v8@@QEAAXPEAVExternalResourceVisitor@2@@Z"]
            pub fn Isolate_VisitExternalResources(
                this: *mut root::v8::Isolate,
                visitor: *mut root::v8::ExternalResourceVisitor,
            );
        }
        extern "C" {
            /// Iterates through all the persistent handles in the current isolate's heap
            /// that have class_ids.
            #[link_name = "\u{1}?VisitHandlesWithClassIds@Isolate@v8@@QEAAXPEAVPersistentHandleVisitor@2@@Z"]
            pub fn Isolate_VisitHandlesWithClassIds(
                this: *mut root::v8::Isolate,
                visitor: *mut root::v8::PersistentHandleVisitor,
            );
        }
        extern "C" {
            /// Iterates through all the persistent handles in the current isolate's heap
            /// that have class_ids and are candidates to be marked as partially dependent
            /// handles. This will visit handles to young objects created since the last
            /// garbage collection but is free to visit an arbitrary superset of these
            /// objects.
            #[link_name = "\u{1}?VisitHandlesForPartialDependence@Isolate@v8@@QEAAXPEAVPersistentHandleVisitor@2@@Z"]
            pub fn Isolate_VisitHandlesForPartialDependence(
                this: *mut root::v8::Isolate,
                visitor: *mut root::v8::PersistentHandleVisitor,
            );
        }
        extern "C" {
            /// Iterates through all the persistent handles in the current isolate's heap
            /// that have class_ids and are weak to be marked as inactive if there is no
            /// pending activity for the handle.
            #[link_name = "\u{1}?VisitWeakHandles@Isolate@v8@@QEAAXPEAVPersistentHandleVisitor@2@@Z"]
            pub fn Isolate_VisitWeakHandles(
                this: *mut root::v8::Isolate,
                visitor: *mut root::v8::PersistentHandleVisitor,
            );
        }
        extern "C" {
            /// Check if this isolate is in use.
            /// True if at least one thread Enter'ed this isolate.
            #[link_name = "\u{1}?IsInUse@Isolate@v8@@QEAA_NXZ"]
            pub fn Isolate_IsInUse(this: *mut root::v8::Isolate) -> bool;
        }
        extern "C" {
            /// Set whether calling Atomics.wait (a function that may block) is allowed in
            /// this isolate. This can also be configured via
            /// CreateParams::allow_atomics_wait.
            #[link_name = "\u{1}?SetAllowAtomicsWait@Isolate@v8@@QEAAX_N@Z"]
            pub fn Isolate_SetAllowAtomicsWait(this: *mut root::v8::Isolate, allow: bool);
        }
        impl Isolate {
            #[inline]
            pub unsafe fn Allocate() -> *mut root::v8::Isolate {
                Isolate_Allocate()
            }
            #[inline]
            pub unsafe fn Initialize(
                isolate: *mut root::v8::Isolate,
                params: *const root::v8::Isolate_CreateParams,
            ) {
                Isolate_Initialize(isolate, params)
            }
            #[inline]
            pub unsafe fn New(
                params: *const root::v8::Isolate_CreateParams,
            ) -> *mut root::v8::Isolate {
                Isolate_New(params)
            }
            #[inline]
            pub unsafe fn GetCurrent() -> *mut root::v8::Isolate {
                Isolate_GetCurrent()
            }
            #[inline]
            pub unsafe fn SetAbortOnUncaughtExceptionCallback(
                &mut self,
                callback: root::v8::Isolate_AbortOnUncaughtExceptionCallback,
            ) {
                Isolate_SetAbortOnUncaughtExceptionCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetHostImportModuleDynamicallyCallback(
                &mut self,
                callback: root::v8::HostImportModuleDynamicallyCallback,
            ) {
                Isolate_SetHostImportModuleDynamicallyCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetHostInitializeImportMetaObjectCallback(
                &mut self,
                callback: root::v8::HostInitializeImportMetaObjectCallback,
            ) {
                Isolate_SetHostInitializeImportMetaObjectCallback(self, callback)
            }
            #[inline]
            pub unsafe fn MemoryPressureNotification(
                &mut self,
                level: root::v8::MemoryPressureLevel,
            ) {
                Isolate_MemoryPressureNotification(self, level)
            }
            #[inline]
            pub unsafe fn Enter(&mut self) {
                Isolate_Enter(self)
            }
            #[inline]
            pub unsafe fn Exit(&mut self) {
                Isolate_Exit(self)
            }
            #[inline]
            pub unsafe fn Dispose(&mut self) {
                Isolate_Dispose(self)
            }
            #[inline]
            pub unsafe fn DumpAndResetStats(&mut self) {
                Isolate_DumpAndResetStats(self)
            }
            #[inline]
            pub unsafe fn DiscardThreadSpecificMetadata(&mut self) {
                Isolate_DiscardThreadSpecificMetadata(self)
            }
            #[inline]
            pub unsafe fn GetHeapStatistics(
                &mut self,
                heap_statistics: *mut root::v8::HeapStatistics,
            ) {
                Isolate_GetHeapStatistics(self, heap_statistics)
            }
            #[inline]
            pub unsafe fn NumberOfHeapSpaces(&mut self) -> usize {
                Isolate_NumberOfHeapSpaces(self)
            }
            #[inline]
            pub unsafe fn GetHeapSpaceStatistics(
                &mut self,
                space_statistics: *mut root::v8::HeapSpaceStatistics,
                index: usize,
            ) -> bool {
                Isolate_GetHeapSpaceStatistics(self, space_statistics, index)
            }
            #[inline]
            pub unsafe fn NumberOfTrackedHeapObjectTypes(&mut self) -> usize {
                Isolate_NumberOfTrackedHeapObjectTypes(self)
            }
            #[inline]
            pub unsafe fn GetHeapObjectStatisticsAtLastGC(
                &mut self,
                object_statistics: *mut root::v8::HeapObjectStatistics,
                type_index: usize,
            ) -> bool {
                Isolate_GetHeapObjectStatisticsAtLastGC(self, object_statistics, type_index)
            }
            #[inline]
            pub unsafe fn GetHeapCodeAndMetadataStatistics(
                &mut self,
                object_statistics: *mut root::v8::HeapCodeStatistics,
            ) -> bool {
                Isolate_GetHeapCodeAndMetadataStatistics(self, object_statistics)
            }
            #[inline]
            pub unsafe fn GetStackSample(
                &mut self,
                state: *const root::v8::RegisterState,
                frames: *mut *mut ::std::os::raw::c_void,
                frames_limit: usize,
                sample_info: *mut root::v8::SampleInfo,
            ) {
                Isolate_GetStackSample(self, state, frames, frames_limit, sample_info)
            }
            #[inline]
            pub unsafe fn NumberOfPhantomHandleResetsSinceLastCall(&mut self) -> usize {
                Isolate_NumberOfPhantomHandleResetsSinceLastCall(self)
            }
            #[inline]
            pub unsafe fn GetHeapProfiler(&mut self) -> *mut root::v8::HeapProfiler {
                Isolate_GetHeapProfiler(self)
            }
            #[inline]
            pub unsafe fn SetIdle(&mut self, is_idle: bool) {
                Isolate_SetIdle(self, is_idle)
            }
            #[inline]
            pub unsafe fn InContext(&mut self) -> bool {
                Isolate_InContext(self)
            }
            #[inline]
            pub unsafe fn GetCurrentContext(&mut self) -> root::v8::Local<root::v8::Context> {
                Isolate_GetCurrentContext(self)
            }
            #[inline]
            pub unsafe fn GetEnteredContext(&mut self) -> root::v8::Local<root::v8::Context> {
                Isolate_GetEnteredContext(self)
            }
            #[inline]
            pub unsafe fn GetEnteredOrMicrotaskContext(
                &mut self,
            ) -> root::v8::Local<root::v8::Context> {
                Isolate_GetEnteredOrMicrotaskContext(self)
            }
            #[inline]
            pub unsafe fn GetIncumbentContext(&mut self) -> root::v8::Local<root::v8::Context> {
                Isolate_GetIncumbentContext(self)
            }
            #[inline]
            pub unsafe fn ThrowException(
                &mut self,
                exception: root::v8::Local<root::v8::Value>,
            ) -> root::v8::Local<root::v8::Value> {
                Isolate_ThrowException(self, exception)
            }
            #[inline]
            pub unsafe fn AddGCPrologueCallback(
                &mut self,
                callback: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
                gc_type_filter: root::v8::GCType,
            ) {
                Isolate_AddGCPrologueCallback(self, callback, data, gc_type_filter)
            }
            #[inline]
            pub unsafe fn AddGCPrologueCallback1(
                &mut self,
                callback: root::v8::Isolate_GCCallback,
                gc_type_filter: root::v8::GCType,
            ) {
                Isolate_AddGCPrologueCallback1(self, callback, gc_type_filter)
            }
            #[inline]
            pub unsafe fn RemoveGCPrologueCallback(
                &mut self,
                arg1: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
            ) {
                Isolate_RemoveGCPrologueCallback(self, arg1, data)
            }
            #[inline]
            pub unsafe fn RemoveGCPrologueCallback1(
                &mut self,
                callback: root::v8::Isolate_GCCallback,
            ) {
                Isolate_RemoveGCPrologueCallback1(self, callback)
            }
            #[inline]
            pub unsafe fn SetEmbedderHeapTracer(
                &mut self,
                tracer: *mut root::v8::EmbedderHeapTracer,
            ) {
                Isolate_SetEmbedderHeapTracer(self, tracer)
            }
            #[inline]
            pub unsafe fn SetAtomicsWaitCallback(
                &mut self,
                callback: root::v8::Isolate_AtomicsWaitCallback,
                data: *mut ::std::os::raw::c_void,
            ) {
                Isolate_SetAtomicsWaitCallback(self, callback, data)
            }
            #[inline]
            pub unsafe fn AddGCEpilogueCallback(
                &mut self,
                callback: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
                gc_type_filter: root::v8::GCType,
            ) {
                Isolate_AddGCEpilogueCallback(self, callback, data, gc_type_filter)
            }
            #[inline]
            pub unsafe fn AddGCEpilogueCallback1(
                &mut self,
                callback: root::v8::Isolate_GCCallback,
                gc_type_filter: root::v8::GCType,
            ) {
                Isolate_AddGCEpilogueCallback1(self, callback, gc_type_filter)
            }
            #[inline]
            pub unsafe fn RemoveGCEpilogueCallback(
                &mut self,
                callback: root::v8::Isolate_GCCallbackWithData,
                data: *mut ::std::os::raw::c_void,
            ) {
                Isolate_RemoveGCEpilogueCallback(self, callback, data)
            }
            #[inline]
            pub unsafe fn RemoveGCEpilogueCallback1(
                &mut self,
                callback: root::v8::Isolate_GCCallback,
            ) {
                Isolate_RemoveGCEpilogueCallback1(self, callback)
            }
            #[inline]
            pub unsafe fn SetGetExternallyAllocatedMemoryInBytesCallback(
                &mut self,
                callback: root::v8::Isolate_GetExternallyAllocatedMemoryInBytesCallback,
            ) {
                Isolate_SetGetExternallyAllocatedMemoryInBytesCallback(self, callback)
            }
            #[inline]
            pub unsafe fn TerminateExecution(&mut self) {
                Isolate_TerminateExecution(self)
            }
            #[inline]
            pub unsafe fn IsExecutionTerminating(&mut self) -> bool {
                Isolate_IsExecutionTerminating(self)
            }
            #[inline]
            pub unsafe fn CancelTerminateExecution(&mut self) {
                Isolate_CancelTerminateExecution(self)
            }
            #[inline]
            pub unsafe fn RequestInterrupt(
                &mut self,
                callback: root::v8::InterruptCallback,
                data: *mut ::std::os::raw::c_void,
            ) {
                Isolate_RequestInterrupt(self, callback, data)
            }
            #[inline]
            pub unsafe fn RequestGarbageCollectionForTesting(
                &mut self,
                type_: root::v8::Isolate_GarbageCollectionType,
            ) {
                Isolate_RequestGarbageCollectionForTesting(self, type_)
            }
            #[inline]
            pub unsafe fn SetEventLogger(&mut self, that: root::v8::LogEventCallback) {
                Isolate_SetEventLogger(self, that)
            }
            #[inline]
            pub unsafe fn AddBeforeCallEnteredCallback(
                &mut self,
                callback: root::v8::BeforeCallEnteredCallback,
            ) {
                Isolate_AddBeforeCallEnteredCallback(self, callback)
            }
            #[inline]
            pub unsafe fn RemoveBeforeCallEnteredCallback(
                &mut self,
                callback: root::v8::BeforeCallEnteredCallback,
            ) {
                Isolate_RemoveBeforeCallEnteredCallback(self, callback)
            }
            #[inline]
            pub unsafe fn AddCallCompletedCallback(
                &mut self,
                callback: root::v8::CallCompletedCallback,
            ) {
                Isolate_AddCallCompletedCallback(self, callback)
            }
            #[inline]
            pub unsafe fn RemoveCallCompletedCallback(
                &mut self,
                callback: root::v8::CallCompletedCallback,
            ) {
                Isolate_RemoveCallCompletedCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetPromiseHook(&mut self, hook: root::v8::PromiseHook) {
                Isolate_SetPromiseHook(self, hook)
            }
            #[inline]
            pub unsafe fn SetPromiseRejectCallback(
                &mut self,
                callback: root::v8::PromiseRejectCallback,
            ) {
                Isolate_SetPromiseRejectCallback(self, callback)
            }
            #[inline]
            pub unsafe fn RunMicrotasks(&mut self) {
                Isolate_RunMicrotasks(self)
            }
            #[inline]
            pub unsafe fn EnqueueMicrotask(
                &mut self,
                microtask: root::v8::Local<root::v8::Function>,
            ) {
                Isolate_EnqueueMicrotask(self, microtask)
            }
            #[inline]
            pub unsafe fn EnqueueMicrotask1(
                &mut self,
                callback: root::v8::MicrotaskCallback,
                data: *mut ::std::os::raw::c_void,
            ) {
                Isolate_EnqueueMicrotask1(self, callback, data)
            }
            #[inline]
            pub unsafe fn SetMicrotasksPolicy(&mut self, policy: root::v8::MicrotasksPolicy) {
                Isolate_SetMicrotasksPolicy(self, policy)
            }
            #[inline]
            pub unsafe fn GetMicrotasksPolicy(&self) -> root::v8::MicrotasksPolicy {
                Isolate_GetMicrotasksPolicy(self)
            }
            #[inline]
            pub unsafe fn AddMicrotasksCompletedCallback(
                &mut self,
                callback: root::v8::MicrotasksCompletedCallback,
            ) {
                Isolate_AddMicrotasksCompletedCallback(self, callback)
            }
            #[inline]
            pub unsafe fn RemoveMicrotasksCompletedCallback(
                &mut self,
                callback: root::v8::MicrotasksCompletedCallback,
            ) {
                Isolate_RemoveMicrotasksCompletedCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetUseCounterCallback(
                &mut self,
                callback: root::v8::Isolate_UseCounterCallback,
            ) {
                Isolate_SetUseCounterCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetCounterFunction(&mut self, arg1: root::v8::CounterLookupCallback) {
                Isolate_SetCounterFunction(self, arg1)
            }
            #[inline]
            pub unsafe fn SetCreateHistogramFunction(
                &mut self,
                arg1: root::v8::CreateHistogramCallback,
            ) {
                Isolate_SetCreateHistogramFunction(self, arg1)
            }
            #[inline]
            pub unsafe fn SetAddHistogramSampleFunction(
                &mut self,
                arg1: root::v8::AddHistogramSampleCallback,
            ) {
                Isolate_SetAddHistogramSampleFunction(self, arg1)
            }
            #[inline]
            pub unsafe fn IdleNotificationDeadline(&mut self, deadline_in_seconds: f64) -> bool {
                Isolate_IdleNotificationDeadline(self, deadline_in_seconds)
            }
            #[inline]
            pub unsafe fn LowMemoryNotification(&mut self) {
                Isolate_LowMemoryNotification(self)
            }
            #[inline]
            pub unsafe fn ContextDisposedNotification(
                &mut self,
                dependant_context: bool,
            ) -> ::std::os::raw::c_int {
                Isolate_ContextDisposedNotification(self, dependant_context)
            }
            #[inline]
            pub unsafe fn IsolateInForegroundNotification(&mut self) {
                Isolate_IsolateInForegroundNotification(self)
            }
            #[inline]
            pub unsafe fn IsolateInBackgroundNotification(&mut self) {
                Isolate_IsolateInBackgroundNotification(self)
            }
            #[inline]
            pub unsafe fn EnableMemorySavingsMode(&mut self) {
                Isolate_EnableMemorySavingsMode(self)
            }
            #[inline]
            pub unsafe fn DisableMemorySavingsMode(&mut self) {
                Isolate_DisableMemorySavingsMode(self)
            }
            #[inline]
            pub unsafe fn SetRAILMode(&mut self, rail_mode: root::v8::RAILMode) {
                Isolate_SetRAILMode(self, rail_mode)
            }
            #[inline]
            pub unsafe fn IncreaseHeapLimitForDebugging(&mut self) {
                Isolate_IncreaseHeapLimitForDebugging(self)
            }
            #[inline]
            pub unsafe fn RestoreOriginalHeapLimit(&mut self) {
                Isolate_RestoreOriginalHeapLimit(self)
            }
            #[inline]
            pub unsafe fn IsHeapLimitIncreasedForDebugging(&mut self) -> bool {
                Isolate_IsHeapLimitIncreasedForDebugging(self)
            }
            #[inline]
            pub unsafe fn SetJitCodeEventHandler(
                &mut self,
                options: root::v8::JitCodeEventOptions,
                event_handler: root::v8::JitCodeEventHandler,
            ) {
                Isolate_SetJitCodeEventHandler(self, options, event_handler)
            }
            #[inline]
            pub unsafe fn SetStackLimit(&mut self, stack_limit: usize) {
                Isolate_SetStackLimit(self, stack_limit)
            }
            #[inline]
            pub unsafe fn GetCodeRange(
                &mut self,
                start: *mut *mut ::std::os::raw::c_void,
                length_in_bytes: *mut usize,
            ) {
                Isolate_GetCodeRange(self, start, length_in_bytes)
            }
            #[inline]
            pub unsafe fn GetBuiltinsCodeRange(&mut self) -> root::v8::MemoryRange {
                Isolate_GetBuiltinsCodeRange(self)
            }
            #[inline]
            pub unsafe fn SetFatalErrorHandler(&mut self, that: root::v8::FatalErrorCallback) {
                Isolate_SetFatalErrorHandler(self, that)
            }
            #[inline]
            pub unsafe fn SetOOMErrorHandler(&mut self, that: root::v8::OOMErrorCallback) {
                Isolate_SetOOMErrorHandler(self, that)
            }
            #[inline]
            pub unsafe fn AddNearHeapLimitCallback(
                &mut self,
                callback: root::v8::NearHeapLimitCallback,
                data: *mut ::std::os::raw::c_void,
            ) {
                Isolate_AddNearHeapLimitCallback(self, callback, data)
            }
            #[inline]
            pub unsafe fn RemoveNearHeapLimitCallback(
                &mut self,
                callback: root::v8::NearHeapLimitCallback,
                heap_limit: usize,
            ) {
                Isolate_RemoveNearHeapLimitCallback(self, callback, heap_limit)
            }
            #[inline]
            pub unsafe fn SetAllowCodeGenerationFromStringsCallback(
                &mut self,
                callback: root::v8::AllowCodeGenerationFromStringsCallback,
            ) {
                Isolate_SetAllowCodeGenerationFromStringsCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetAllowWasmCodeGenerationCallback(
                &mut self,
                callback: root::v8::AllowWasmCodeGenerationCallback,
            ) {
                Isolate_SetAllowWasmCodeGenerationCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetWasmModuleCallback(&mut self, callback: root::v8::ExtensionCallback) {
                Isolate_SetWasmModuleCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetWasmInstanceCallback(
                &mut self,
                callback: root::v8::ExtensionCallback,
            ) {
                Isolate_SetWasmInstanceCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetWasmCompileStreamingCallback(
                &mut self,
                callback: root::v8::ApiImplementationCallback,
            ) {
                Isolate_SetWasmCompileStreamingCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetWasmStreamingCallback(
                &mut self,
                callback: root::v8::WasmStreamingCallback,
            ) {
                Isolate_SetWasmStreamingCallback(self, callback)
            }
            #[inline]
            pub unsafe fn SetWasmThreadsEnabledCallback(
                &mut self,
                callback: root::v8::WasmThreadsEnabledCallback,
            ) {
                Isolate_SetWasmThreadsEnabledCallback(self, callback)
            }
            #[inline]
            pub unsafe fn IsDead(&mut self) -> bool {
                Isolate_IsDead(self)
            }
            #[inline]
            pub unsafe fn AddMessageListener(
                &mut self,
                that: root::v8::MessageCallback,
                data: root::v8::Local<root::v8::Value>,
            ) -> bool {
                Isolate_AddMessageListener(self, that, data)
            }
            #[inline]
            pub unsafe fn AddMessageListenerWithErrorLevel(
                &mut self,
                that: root::v8::MessageCallback,
                message_levels: ::std::os::raw::c_int,
                data: root::v8::Local<root::v8::Value>,
            ) -> bool {
                Isolate_AddMessageListenerWithErrorLevel(self, that, message_levels, data)
            }
            #[inline]
            pub unsafe fn RemoveMessageListeners(&mut self, that: root::v8::MessageCallback) {
                Isolate_RemoveMessageListeners(self, that)
            }
            #[inline]
            pub unsafe fn SetFailedAccessCheckCallbackFunction(
                &mut self,
                arg1: root::v8::FailedAccessCheckCallback,
            ) {
                Isolate_SetFailedAccessCheckCallbackFunction(self, arg1)
            }
            #[inline]
            pub unsafe fn SetCaptureStackTraceForUncaughtExceptions(
                &mut self,
                capture: bool,
                frame_limit: ::std::os::raw::c_int,
                options: root::v8::StackTrace_StackTraceOptions,
            ) {
                Isolate_SetCaptureStackTraceForUncaughtExceptions(
                    self,
                    capture,
                    frame_limit,
                    options,
                )
            }
            #[inline]
            pub unsafe fn VisitExternalResources(
                &mut self,
                visitor: *mut root::v8::ExternalResourceVisitor,
            ) {
                Isolate_VisitExternalResources(self, visitor)
            }
            #[inline]
            pub unsafe fn VisitHandlesWithClassIds(
                &mut self,
                visitor: *mut root::v8::PersistentHandleVisitor,
            ) {
                Isolate_VisitHandlesWithClassIds(self, visitor)
            }
            #[inline]
            pub unsafe fn VisitHandlesForPartialDependence(
                &mut self,
                visitor: *mut root::v8::PersistentHandleVisitor,
            ) {
                Isolate_VisitHandlesForPartialDependence(self, visitor)
            }
            #[inline]
            pub unsafe fn VisitWeakHandles(
                &mut self,
                visitor: *mut root::v8::PersistentHandleVisitor,
            ) {
                Isolate_VisitWeakHandles(self, visitor)
            }
            #[inline]
            pub unsafe fn IsInUse(&mut self) -> bool {
                Isolate_IsInUse(self)
            }
            #[inline]
            pub unsafe fn SetAllowAtomicsWait(&mut self, allow: bool) {
                Isolate_SetAllowAtomicsWait(self, allow)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct StartupData {
            pub data: *const ::std::os::raw::c_char,
            pub raw_size: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_StartupData() {
            assert_eq!(
                ::std::mem::size_of::<StartupData>(),
                16usize,
                concat!("Size of: ", stringify!(StartupData))
            );
            assert_eq!(
                ::std::mem::align_of::<StartupData>(),
                8usize,
                concat!("Alignment of ", stringify!(StartupData))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<StartupData>())).data as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StartupData),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<StartupData>())).raw_size as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StartupData),
                    "::",
                    stringify!(raw_size)
                )
            );
        }
        /// EntropySource is used as a callback function when v8 needs a source
        /// of entropy.
        pub type EntropySource = ::std::option::Option<
            unsafe extern "C" fn(buffer: *mut ::std::os::raw::c_uchar, length: usize) -> bool,
        >;
        /// ReturnAddressLocationResolver is used as a callback function when v8 is
        /// resolving the location of a return address on the stack. Profilers that
        /// change the return address on the stack can use this to resolve the stack
        /// location to wherever the profiler stashed the original return address.
        ///
        /// \param return_addr_location A location on stack where a machine
        /// return address resides.
        /// \returns Either return_addr_location, or else a pointer to the profiler's
        /// copy of the original return address.
        ///
        /// \note The resolver function must not cause garbage collection.
        pub type ReturnAddressLocationResolver =
            ::std::option::Option<unsafe extern "C" fn(return_addr_location: usize) -> usize>;
        extern "C" {
            /// Hand startup data to V8, in case the embedder has chosen to build
            /// V8 with external startup data.
            ///
            /// Note:
            /// - By default the startup data is linked into the V8 library, in which
            /// case this function is not meaningful.
            /// - If this needs to be called, it needs to be called before V8
            /// tries to make use of its built-ins.
            /// - To avoid unnecessary copies of data, V8 will point directly into the
            /// given data blob, so pretty please keep it around until V8 exit.
            /// - Compression of the startup blob might be useful, but needs to
            /// handled entirely on the embedders' side.
            /// - The call will abort if the data is invalid.
            #[link_name = "\u{1}?SetNativesDataBlob@V8@v8@@SAXPEAVStartupData@2@@Z"]
            pub fn V8_SetNativesDataBlob(startup_blob: *mut root::v8::StartupData);
        }
        extern "C" {
            #[link_name = "\u{1}?SetSnapshotDataBlob@V8@v8@@SAXPEAVStartupData@2@@Z"]
            pub fn V8_SetSnapshotDataBlob(startup_blob: *mut root::v8::StartupData);
        }
        extern "C" {
            /// Set the callback to invoke in case of Dcheck failures.
            #[link_name = "\u{1}?SetDcheckErrorHandler@V8@v8@@SAXP6AXPEBDH0@Z@Z"]
            pub fn V8_SetDcheckErrorHandler(that: root::v8::DcheckErrorCallback);
        }
        extern "C" {
            /// Sets V8 flags from a string.
            #[link_name = "\u{1}?SetFlagsFromString@V8@v8@@SAXPEBDH@Z"]
            pub fn V8_SetFlagsFromString(
                str: *const ::std::os::raw::c_char,
                length: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            /// Sets V8 flags from the command line.
            #[link_name = "\u{1}?SetFlagsFromCommandLine@V8@v8@@SAXPEAHPEAPEAD_N@Z"]
            pub fn V8_SetFlagsFromCommandLine(
                argc: *mut ::std::os::raw::c_int,
                argv: *mut *mut ::std::os::raw::c_char,
                remove_flags: bool,
            );
        }
        extern "C" {
            /// Get the version string.
            #[link_name = "\u{1}?GetVersion@V8@v8@@SAPEBDXZ"]
            pub fn V8_GetVersion() -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            /// Initializes V8. This function needs to be called before the first Isolate
            /// is created. It always returns true.
            #[link_name = "\u{1}?Initialize@V8@v8@@SA_NXZ"]
            pub fn V8_Initialize() -> bool;
        }
        extern "C" {
            /// Allows the host application to provide a callback which can be used
            /// as a source of entropy for random number generators.
            #[link_name = "\u{1}?SetEntropySource@V8@v8@@SAXP6A_NPEAE_K@Z@Z"]
            pub fn V8_SetEntropySource(source: root::v8::EntropySource);
        }
        extern "C" {
            /// Allows the host application to provide a callback that allows v8 to
            /// cooperate with a profiler that rewrites return addresses on stack.
            #[link_name = "\u{1}?SetReturnAddressLocationResolver@V8@v8@@SAXP6A_K_K@Z@Z"]
            pub fn V8_SetReturnAddressLocationResolver(
                return_address_resolver: root::v8::ReturnAddressLocationResolver,
            );
        }
        extern "C" {
            /// Releases any resources used by v8 and stops any utility threads
            /// that may be running.  Note that disposing v8 is permanent, it
            /// cannot be reinitialized.
            ///
            /// It should generally not be necessary to dispose v8 before exiting
            /// a process, this should happen automatically.  It is only necessary
            /// to use if the process needs the resources taken up by v8.
            #[link_name = "\u{1}?Dispose@V8@v8@@SA_NXZ"]
            pub fn V8_Dispose() -> bool;
        }
        extern "C" {
            /// Initialize the ICU library bundled with V8. The embedder should only
            /// invoke this method when using the bundled ICU. Returns true on success.
            ///
            /// If V8 was compiled with the ICU data in an external file, the location
            /// of the data file has to be provided.
            #[link_name = "\u{1}?InitializeICU@V8@v8@@SA_NPEBD@Z"]
            pub fn V8_InitializeICU(icu_data_file: *const ::std::os::raw::c_char) -> bool;
        }
        extern "C" {
            /// Initialize the ICU library bundled with V8. The embedder should only
            /// invoke this method when using the bundled ICU. If V8 was compiled with
            /// the ICU data in an external file and when the default location of that
            /// file should be used, a path to the executable must be provided.
            /// Returns true on success.
            ///
            /// The default is a file called icudtl.dat side-by-side with the executable.
            ///
            /// Optionally, the location of the data file can be provided to override the
            /// default.
            #[link_name = "\u{1}?InitializeICUDefaultLocation@V8@v8@@SA_NPEBD0@Z"]
            pub fn V8_InitializeICUDefaultLocation(
                exec_path: *const ::std::os::raw::c_char,
                icu_data_file: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            /// Initialize the external startup data. The embedder only needs to
            /// invoke this method when external startup data was enabled in a build.
            ///
            /// If V8 was compiled with the startup data in an external file, then
            /// V8 needs to be given those external files during startup. There are
            /// three ways to do this:
            /// - InitializeExternalStartupData(const char*)
            /// This will look in the given directory for files "natives_blob.bin"
            /// and "snapshot_blob.bin" - which is what the default build calls them.
            /// - InitializeExternalStartupData(const char*, const char*)
            /// As above, but will directly use the two given file names.
            /// - Call SetNativesDataBlob, SetNativesDataBlob.
            /// This will read the blobs from the given data structures and will
            /// not perform any file IO.
            #[link_name = "\u{1}?InitializeExternalStartupData@V8@v8@@SAXPEBD@Z"]
            pub fn V8_InitializeExternalStartupData(directory_path: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}?InitializeExternalStartupData@V8@v8@@SAXPEBD0@Z"]
            pub fn V8_InitializeExternalStartupData1(
                natives_blob: *const ::std::os::raw::c_char,
                snapshot_blob: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            /// Sets the v8::Platform to use. This should be invoked before V8 is
            /// initialized.
            #[link_name = "\u{1}?InitializePlatform@V8@v8@@SAXPEAVPlatform@2@@Z"]
            pub fn V8_InitializePlatform(platform: *mut root::v8::Platform);
        }
        extern "C" {
            /// Clears all references to the v8::Platform. This should be invoked after
            /// V8 was disposed.
            #[link_name = "\u{1}?ShutdownPlatform@V8@v8@@SAXXZ"]
            pub fn V8_ShutdownPlatform();
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterDefaultSignalHandler@V8@v8@@SA_NXZ"]
            pub fn V8_RegisterDefaultSignalHandler() -> bool;
        }
        extern "C" {
            /// Activate trap-based bounds checking for WebAssembly.
            ///
            /// \param use_v8_signal_handler Whether V8 should install its own signal
            /// handler or rely on the embedder's.
            #[link_name = "\u{1}?EnableWebAssemblyTrapHandler@V8@v8@@SA_N_N@Z"]
            pub fn V8_EnableWebAssemblyTrapHandler(use_v8_signal_handler: bool) -> bool;
        }
        /// Helper class to create a snapshot data blob.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct SnapshotCreator {
            pub data_: *mut ::std::os::raw::c_void,
        }
        pub const SnapshotCreator_FunctionCodeHandling_kClear:
            root::v8::SnapshotCreator_FunctionCodeHandling = 0;
        pub const SnapshotCreator_FunctionCodeHandling_kKeep:
            root::v8::SnapshotCreator_FunctionCodeHandling = 1;
        pub type SnapshotCreator_FunctionCodeHandling = i32;
        #[test]
        fn bindgen_test_layout_SnapshotCreator() {
            assert_eq!(
                ::std::mem::size_of::<SnapshotCreator>(),
                8usize,
                concat!("Size of: ", stringify!(SnapshotCreator))
            );
            assert_eq!(
                ::std::mem::align_of::<SnapshotCreator>(),
                8usize,
                concat!("Alignment of ", stringify!(SnapshotCreator))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SnapshotCreator>())).data_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SnapshotCreator),
                    "::",
                    stringify!(data_)
                )
            );
        }
        extern "C" {
            /// \returns the isolate prepared by the snapshot creator.
            #[link_name = "\u{1}?GetIsolate@SnapshotCreator@v8@@QEAAPEAVIsolate@2@XZ"]
            pub fn SnapshotCreator_GetIsolate(
                this: *mut root::v8::SnapshotCreator,
            ) -> *mut root::v8::Isolate;
        }
        extern "C" {
            /// Set the default context to be included in the snapshot blob.
            /// The snapshot will not contain the global proxy, and we expect one or a
            /// global object template to create one, to be provided upon deserialization.
            ///
            /// \param callback optional callback to serialize internal fields.
            #[link_name = "\u{1}?SetDefaultContext@SnapshotCreator@v8@@QEAAXV?$Local@VContext@v8@@@2@USerializeInternalFieldsCallback@2@@Z"]
            pub fn SnapshotCreator_SetDefaultContext(
                this: *mut root::v8::SnapshotCreator,
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::SerializeInternalFieldsCallback,
            );
        }
        extern "C" {
            /// Add additional context to be included in the snapshot blob.
            /// The snapshot will include the global proxy.
            ///
            /// \param callback optional callback to serialize internal fields.
            ///
            /// \returns the index of the context in the snapshot blob.
            #[link_name = "\u{1}?AddContext@SnapshotCreator@v8@@QEAA_KV?$Local@VContext@v8@@@2@USerializeInternalFieldsCallback@2@@Z"]
            pub fn SnapshotCreator_AddContext(
                this: *mut root::v8::SnapshotCreator,
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::SerializeInternalFieldsCallback,
            ) -> usize;
        }
        extern "C" {
            /// Add a template to be included in the snapshot blob.
            /// \returns the index of the template in the snapshot blob.
            #[link_name = "\u{1}?AddTemplate@SnapshotCreator@v8@@QEAA_KV?$Local@VTemplate@v8@@@2@@Z"]
            pub fn SnapshotCreator_AddTemplate(
                this: *mut root::v8::SnapshotCreator,
                template_obj: root::v8::Local<root::v8::Template>,
            ) -> usize;
        }
        extern "C" {
            /// Created a snapshot data blob.
            /// This must not be called from within a handle scope.
            /// \param function_code_handling whether to include compiled function code
            /// in the snapshot.
            /// \returns { nullptr, 0 } on failure, and a startup snapshot on success. The
            /// caller acquires ownership of the data array in the return value.
            #[link_name = "\u{1}?CreateBlob@SnapshotCreator@v8@@QEAA?AVStartupData@2@W4FunctionCodeHandling@12@@Z"]
            pub fn SnapshotCreator_CreateBlob(
                this: *mut root::v8::SnapshotCreator,
                function_code_handling: root::v8::SnapshotCreator_FunctionCodeHandling,
            ) -> root::v8::StartupData;
        }
        extern "C" {
            /// Initialize and enter an isolate, and set it up for serialization.
            /// The isolate is either created from scratch or from an existing snapshot.
            /// The caller keeps ownership of the argument snapshot.
            /// \param existing_blob existing snapshot from which to create this one.
            /// \param external_references a null-terminated array of external references
            /// that must be equivalent to CreateParams::external_references.
            #[link_name = "\u{1}??0SnapshotCreator@v8@@QEAA@PEAVIsolate@1@PEB_JPEAVStartupData@1@@Z"]
            pub fn SnapshotCreator_SnapshotCreator(
                this: *mut root::v8::SnapshotCreator,
                isolate: *mut root::v8::Isolate,
                external_references: *const isize,
                existing_blob: *mut root::v8::StartupData,
            );
        }
        extern "C" {
            /// Create and enter an isolate, and set it up for serialization.
            /// The isolate is either created from scratch or from an existing snapshot.
            /// The caller keeps ownership of the argument snapshot.
            /// \param existing_blob existing snapshot from which to create this one.
            /// \param external_references a null-terminated array of external references
            /// that must be equivalent to CreateParams::external_references.
            #[link_name = "\u{1}??0SnapshotCreator@v8@@QEAA@PEB_JPEAVStartupData@1@@Z"]
            pub fn SnapshotCreator_SnapshotCreator1(
                this: *mut root::v8::SnapshotCreator,
                external_references: *const isize,
                existing_blob: *mut root::v8::StartupData,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DSnapshotCreator@v8@@QEAAXXZ"]
            pub fn SnapshotCreator_SnapshotCreator_destructor(this: *mut root::v8::SnapshotCreator);
        }
        impl SnapshotCreator {
            #[inline]
            pub unsafe fn GetIsolate(&mut self) -> *mut root::v8::Isolate {
                SnapshotCreator_GetIsolate(self)
            }
            #[inline]
            pub unsafe fn SetDefaultContext(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::SerializeInternalFieldsCallback,
            ) {
                SnapshotCreator_SetDefaultContext(self, context, callback)
            }
            #[inline]
            pub unsafe fn AddContext(
                &mut self,
                context: root::v8::Local<root::v8::Context>,
                callback: root::v8::SerializeInternalFieldsCallback,
            ) -> usize {
                SnapshotCreator_AddContext(self, context, callback)
            }
            #[inline]
            pub unsafe fn AddTemplate(
                &mut self,
                template_obj: root::v8::Local<root::v8::Template>,
            ) -> usize {
                SnapshotCreator_AddTemplate(self, template_obj)
            }
            #[inline]
            pub unsafe fn CreateBlob(
                &mut self,
                function_code_handling: root::v8::SnapshotCreator_FunctionCodeHandling,
            ) -> root::v8::StartupData {
                SnapshotCreator_CreateBlob(self, function_code_handling)
            }
            #[inline]
            pub unsafe fn new(
                isolate: *mut root::v8::Isolate,
                external_references: *const isize,
                existing_blob: *mut root::v8::StartupData,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SnapshotCreator_SnapshotCreator(
                    &mut __bindgen_tmp,
                    isolate,
                    external_references,
                    existing_blob,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                external_references: *const isize,
                existing_blob: *mut root::v8::StartupData,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SnapshotCreator_SnapshotCreator1(
                    &mut __bindgen_tmp,
                    external_references,
                    existing_blob,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                SnapshotCreator_SnapshotCreator_destructor(self)
            }
        }
        /// A simple Maybe type, representing an object which may or may not have a
        /// value, see https://hackage.haskell.org/package/base/docs/Data-Maybe.html.
        ///
        /// If an API method returns a Maybe<>, the API method can potentially fail
        /// either because an exception is thrown, or because an exception is pending,
        /// e.g. because a previous API call threw an exception that hasn't been caught
        /// yet, or because a TerminateExecution exception was thrown. In that case, a
        /// "Nothing" value is returned.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Maybe<T> {
            pub has_value_: bool,
            pub value_: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        /// An external exception handler.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct TryCatch {
            pub isolate_: *mut root::v8::internal::Isolate,
            pub next_: *mut root::v8::TryCatch,
            pub exception_: *mut ::std::os::raw::c_void,
            pub message_obj_: *mut ::std::os::raw::c_void,
            pub js_stack_comparable_address_: *mut ::std::os::raw::c_void,
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[test]
        fn bindgen_test_layout_TryCatch() {
            assert_eq!(
                ::std::mem::size_of::<TryCatch>(),
                48usize,
                concat!("Size of: ", stringify!(TryCatch))
            );
            assert_eq!(
                ::std::mem::align_of::<TryCatch>(),
                8usize,
                concat!("Alignment of ", stringify!(TryCatch))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TryCatch>())).isolate_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TryCatch),
                    "::",
                    stringify!(isolate_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TryCatch>())).next_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TryCatch),
                    "::",
                    stringify!(next_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TryCatch>())).exception_ as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TryCatch),
                    "::",
                    stringify!(exception_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TryCatch>())).message_obj_ as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TryCatch),
                    "::",
                    stringify!(message_obj_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TryCatch>())).js_stack_comparable_address_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TryCatch),
                    "::",
                    stringify!(js_stack_comparable_address_)
                )
            );
        }
        extern "C" {
            /// Returns true if an exception has been caught by this try/catch block.
            #[link_name = "\u{1}?HasCaught@TryCatch@v8@@QEBA_NXZ"]
            pub fn TryCatch_HasCaught(this: *const root::v8::TryCatch) -> bool;
        }
        extern "C" {
            /// For certain types of exceptions, it makes no sense to continue execution.
            ///
            /// If CanContinue returns false, the correct action is to perform any C++
            /// cleanup needed and then return.  If CanContinue returns false and
            /// HasTerminated returns true, it is possible to call
            /// CancelTerminateExecution in order to continue calling into the engine.
            #[link_name = "\u{1}?CanContinue@TryCatch@v8@@QEBA_NXZ"]
            pub fn TryCatch_CanContinue(this: *const root::v8::TryCatch) -> bool;
        }
        extern "C" {
            /// Returns true if an exception has been caught due to script execution
            /// being terminated.
            ///
            /// There is no JavaScript representation of an execution termination
            /// exception.  Such exceptions are thrown when the TerminateExecution
            /// methods are called to terminate a long-running script.
            ///
            /// If such an exception has been thrown, HasTerminated will return true,
            /// indicating that it is possible to call CancelTerminateExecution in order
            /// to continue calling into the engine.
            #[link_name = "\u{1}?HasTerminated@TryCatch@v8@@QEBA_NXZ"]
            pub fn TryCatch_HasTerminated(this: *const root::v8::TryCatch) -> bool;
        }
        extern "C" {
            /// Throws the exception caught by this TryCatch in a way that avoids
            /// it being caught again by this same TryCatch.  As with ThrowException
            /// it is illegal to execute any JavaScript operations after calling
            /// ReThrow; the caller must return immediately to where the exception
            /// is caught.
            #[link_name = "\u{1}?ReThrow@TryCatch@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn TryCatch_ReThrow(
                this: *mut root::v8::TryCatch,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Returns the exception caught by this try/catch block.  If no exception has
            /// been caught an empty handle is returned.
            ///
            /// The returned handle is valid until this TryCatch block has been destroyed.
            #[link_name = "\u{1}?Exception@TryCatch@v8@@QEBA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn TryCatch_Exception(
                this: *const root::v8::TryCatch,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Returns the .stack property of the thrown object.  If no .stack
            /// property is present an empty handle is returned.
            #[link_name = "\u{1}?StackTrace@TryCatch@v8@@QEBA?AV?$MaybeLocal@VValue@v8@@@2@V?$Local@VContext@v8@@@2@@Z"]
            pub fn TryCatch_StackTrace(
                this: *const root::v8::TryCatch,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value>;
        }
        extern "C" {
            /// Returns the message associated with this exception.  If there is
            /// no message associated an empty handle is returned.
            ///
            /// The returned handle is valid until this TryCatch block has been
            /// destroyed.
            #[link_name = "\u{1}?Message@TryCatch@v8@@QEBA?AV?$Local@VMessage@v8@@@2@XZ"]
            pub fn TryCatch_Message(
                this: *const root::v8::TryCatch,
            ) -> root::v8::Local<root::v8::Message>;
        }
        extern "C" {
            /// Clears any exceptions that may have been caught by this try/catch block.
            /// After this method has been called, HasCaught() will return false. Cancels
            /// the scheduled exception if it is caught and ReThrow() is not called before.
            ///
            /// It is not necessary to clear a try/catch block before using it again; if
            /// another exception is thrown the previously caught exception will just be
            /// overwritten.  However, it is often a good idea since it makes it easier
            /// to determine which operation threw a given exception.
            #[link_name = "\u{1}?Reset@TryCatch@v8@@QEAAXXZ"]
            pub fn TryCatch_Reset(this: *mut root::v8::TryCatch);
        }
        extern "C" {
            /// Set verbosity of the external exception handler.
            ///
            /// By default, exceptions that are caught by an external exception
            /// handler are not reported.  Call SetVerbose with true on an
            /// external exception handler to have exceptions caught by the
            /// handler reported as if they were not caught.
            #[link_name = "\u{1}?SetVerbose@TryCatch@v8@@QEAAX_N@Z"]
            pub fn TryCatch_SetVerbose(this: *mut root::v8::TryCatch, value: bool);
        }
        extern "C" {
            /// Returns true if verbosity is enabled.
            #[link_name = "\u{1}?IsVerbose@TryCatch@v8@@QEBA_NXZ"]
            pub fn TryCatch_IsVerbose(this: *const root::v8::TryCatch) -> bool;
        }
        extern "C" {
            /// Set whether or not this TryCatch should capture a Message object
            /// which holds source information about where the exception
            /// occurred.  True by default.
            #[link_name = "\u{1}?SetCaptureMessage@TryCatch@v8@@QEAAX_N@Z"]
            pub fn TryCatch_SetCaptureMessage(this: *mut root::v8::TryCatch, value: bool);
        }
        extern "C" {
            /// Creates a new try/catch block and registers it with v8.  Note that
            /// all TryCatch blocks should be stack allocated because the memory
            /// location itself is compared against JavaScript try/catch blocks.
            #[link_name = "\u{1}??0TryCatch@v8@@QEAA@PEAVIsolate@1@@Z"]
            pub fn TryCatch_TryCatch(
                this: *mut root::v8::TryCatch,
                isolate: *mut root::v8::Isolate,
            );
        }
        extern "C" {
            /// Unregisters and deletes this try/catch block.
            #[link_name = "\u{1}??_DTryCatch@v8@@QEAAXXZ"]
            pub fn TryCatch_TryCatch_destructor(this: *mut root::v8::TryCatch);
        }
        impl TryCatch {
            #[inline]
            pub fn is_verbose_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_is_verbose_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn can_continue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_can_continue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn capture_message_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_capture_message_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rethrow_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_rethrow_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_terminated_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_has_terminated_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                is_verbose_: bool,
                can_continue_: bool,
                capture_message_: bool,
                rethrow_: bool,
                has_terminated_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<
                    [u8; 1usize],
                    u8,
                > = Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let is_verbose_: u8 = unsafe { ::std::mem::transmute(is_verbose_) };
                    is_verbose_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let can_continue_: u8 = unsafe { ::std::mem::transmute(can_continue_) };
                    can_continue_ as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let capture_message_: u8 = unsafe { ::std::mem::transmute(capture_message_) };
                    capture_message_ as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let rethrow_: u8 = unsafe { ::std::mem::transmute(rethrow_) };
                    rethrow_ as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let has_terminated_: u8 = unsafe { ::std::mem::transmute(has_terminated_) };
                    has_terminated_ as u64
                });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub unsafe fn HasCaught(&self) -> bool {
                TryCatch_HasCaught(self)
            }
            #[inline]
            pub unsafe fn CanContinue(&self) -> bool {
                TryCatch_CanContinue(self)
            }
            #[inline]
            pub unsafe fn HasTerminated(&self) -> bool {
                TryCatch_HasTerminated(self)
            }
            #[inline]
            pub unsafe fn ReThrow(&mut self) -> root::v8::Local<root::v8::Value> {
                TryCatch_ReThrow(self)
            }
            #[inline]
            pub unsafe fn Exception(&self) -> root::v8::Local<root::v8::Value> {
                TryCatch_Exception(self)
            }
            #[inline]
            pub unsafe fn StackTrace(
                &self,
                context: root::v8::Local<root::v8::Context>,
            ) -> root::v8::MaybeLocal<root::v8::Value> {
                TryCatch_StackTrace(self, context)
            }
            #[inline]
            pub unsafe fn Message(&self) -> root::v8::Local<root::v8::Message> {
                TryCatch_Message(self)
            }
            #[inline]
            pub unsafe fn Reset(&mut self) {
                TryCatch_Reset(self)
            }
            #[inline]
            pub unsafe fn SetVerbose(&mut self, value: bool) {
                TryCatch_SetVerbose(self, value)
            }
            #[inline]
            pub unsafe fn IsVerbose(&self) -> bool {
                TryCatch_IsVerbose(self)
            }
            #[inline]
            pub unsafe fn SetCaptureMessage(&mut self, value: bool) {
                TryCatch_SetCaptureMessage(self, value)
            }
            #[inline]
            pub unsafe fn new(isolate: *mut root::v8::Isolate) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                TryCatch_TryCatch(&mut __bindgen_tmp, isolate);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                TryCatch_TryCatch_destructor(self)
            }
        }
        /// A container for extension names.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct ExtensionConfiguration {
            pub name_count_: ::std::os::raw::c_int,
            pub names_: *mut *const ::std::os::raw::c_char,
        }
        #[test]
        fn bindgen_test_layout_ExtensionConfiguration() {
            assert_eq!(
                ::std::mem::size_of::<ExtensionConfiguration>(),
                16usize,
                concat!("Size of: ", stringify!(ExtensionConfiguration))
            );
            assert_eq!(
                ::std::mem::align_of::<ExtensionConfiguration>(),
                8usize,
                concat!("Alignment of ", stringify!(ExtensionConfiguration))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ExtensionConfiguration>())).name_count_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExtensionConfiguration),
                    "::",
                    stringify!(name_count_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ExtensionConfiguration>())).names_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExtensionConfiguration),
                    "::",
                    stringify!(names_)
                )
            );
        }
        /// A sandboxed execution context with its own set of built-in objects
        /// and functions.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub struct Context {
            pub _address: u8,
        }
        pub const Context_EmbedderDataFields_kDebugIdIndex: root::v8::Context_EmbedderDataFields =
            0;
        /// The field at kDebugIdIndex used to be reserved for the inspector.
        /// It now serves no purpose.
        pub type Context_EmbedderDataFields = i32;
        /// Stack-allocated class which sets the execution context for all
        /// operations executed within a local scope.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Context_Scope {
            pub context_: root::v8::Local<root::v8::Context>,
        }
        #[test]
        fn bindgen_test_layout_Context_Scope() {
            assert_eq!(
                ::std::mem::size_of::<Context_Scope>(),
                8usize,
                concat!("Size of: ", stringify!(Context_Scope))
            );
            assert_eq!(
                ::std::mem::align_of::<Context_Scope>(),
                8usize,
                concat!("Alignment of ", stringify!(Context_Scope))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Context_Scope>())).context_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context_Scope),
                    "::",
                    stringify!(context_)
                )
            );
        }
        /// Stack-allocated class to support the backup incumbent settings object
        /// stack.
        /// https://html.spec.whatwg.org/multipage/webappapis.html#backup-incumbent-settings-object-stack
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Context_BackupIncumbentScope {
            pub backup_incumbent_context_: root::v8::Local<root::v8::Context>,
            pub prev_: *const root::v8::Context_BackupIncumbentScope,
        }
        #[test]
        fn bindgen_test_layout_Context_BackupIncumbentScope() {
            assert_eq!(
                ::std::mem::size_of::<Context_BackupIncumbentScope>(),
                16usize,
                concat!("Size of: ", stringify!(Context_BackupIncumbentScope))
            );
            assert_eq!(
                ::std::mem::align_of::<Context_BackupIncumbentScope>(),
                8usize,
                concat!("Alignment of ", stringify!(Context_BackupIncumbentScope))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Context_BackupIncumbentScope>()))
                        .backup_incumbent_context_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context_BackupIncumbentScope),
                    "::",
                    stringify!(backup_incumbent_context_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Context_BackupIncumbentScope>())).prev_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context_BackupIncumbentScope),
                    "::",
                    stringify!(prev_)
                )
            );
        }
        extern "C" {
            /// |backup_incumbent_context| is pushed onto the backup incumbent settings
            /// object stack.
            #[link_name = "\u{1}??0BackupIncumbentScope@Context@v8@@QEAA@V?$Local@VContext@v8@@@2@@Z"]
            pub fn Context_BackupIncumbentScope_BackupIncumbentScope(
                this: *mut root::v8::Context_BackupIncumbentScope,
                backup_incumbent_context: root::v8::Local<root::v8::Context>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DBackupIncumbentScope@Context@v8@@QEAAXXZ"]
            pub fn Context_BackupIncumbentScope_BackupIncumbentScope_destructor(
                this: *mut root::v8::Context_BackupIncumbentScope,
            );
        }
        impl Context_BackupIncumbentScope {
            #[inline]
            pub unsafe fn new(
                backup_incumbent_context: root::v8::Local<root::v8::Context>,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Context_BackupIncumbentScope_BackupIncumbentScope(
                    &mut __bindgen_tmp,
                    backup_incumbent_context,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Context_BackupIncumbentScope_BackupIncumbentScope_destructor(self)
            }
        }
        #[test]
        fn bindgen_test_layout_Context() {
            assert_eq!(
                ::std::mem::size_of::<Context>(),
                1usize,
                concat!("Size of: ", stringify!(Context))
            );
            assert_eq!(
                ::std::mem::align_of::<Context>(),
                1usize,
                concat!("Alignment of ", stringify!(Context))
            );
        }
        extern "C" {
            /// Returns the global proxy object.
            ///
            /// Global proxy object is a thin wrapper whose prototype points to actual
            /// context's global object with the properties like Object, etc. This is done
            /// that way for security reasons (for more details see
            /// https://wiki.mozilla.org/Gecko:SplitWindow).
            ///
            /// Please note that changes to global proxy object prototype most probably
            /// would break VM---v8 expects only global object as a prototype of global
            /// proxy object.
            #[link_name = "\u{1}?Global@Context@v8@@QEAA?AV?$Local@VObject@v8@@@2@XZ"]
            pub fn Context_Global(
                this: *mut root::v8::Context,
            ) -> root::v8::Local<root::v8::Object>;
        }
        extern "C" {
            /// Detaches the global object from its context before
            /// the global object can be reused to create a new context.
            #[link_name = "\u{1}?DetachGlobal@Context@v8@@QEAAXXZ"]
            pub fn Context_DetachGlobal(this: *mut root::v8::Context);
        }
        extern "C" {
            /// Creates a new context and returns a handle to the newly allocated
            /// context.
            ///
            /// \param isolate The isolate in which to create the context.
            ///
            /// \param extensions An optional extension configuration containing
            /// the extensions to be installed in the newly created context.
            ///
            /// \param global_template An optional object template from which the
            /// global object for the newly created context will be created.
            ///
            /// \param global_object An optional global object to be reused for
            /// the newly created context. This global object must have been
            /// created by a previous call to Context::New with the same global
            /// template. The state of the global object will be completely reset
            /// and only object identify will remain.
            #[link_name = "\u{1}?New@Context@v8@@SA?AV?$Local@VContext@v8@@@2@PEAVIsolate@2@PEAVExtensionConfiguration@2@V?$MaybeLocal@VObjectTemplate@v8@@@2@V?$MaybeLocal@VValue@v8@@@2@UDeserializeInternalFieldsCallback@2@@Z"]
            pub fn Context_New(
                isolate: *mut root::v8::Isolate,
                extensions: *mut root::v8::ExtensionConfiguration,
                global_template: root::v8::MaybeLocal<root::v8::ObjectTemplate>,
                global_object: root::v8::MaybeLocal<root::v8::Value>,
                internal_fields_deserializer: root::v8::DeserializeInternalFieldsCallback,
            ) -> root::v8::Local<root::v8::Context>;
        }
        extern "C" {
            /// Create a new context from a (non-default) context snapshot. There
            /// is no way to provide a global object template since we do not create
            /// a new global object from template, but we can reuse a global object.
            ///
            /// \param isolate See v8::Context::New.
            ///
            /// \param context_snapshot_index The index of the context snapshot to
            /// deserialize from. Use v8::Context::New for the default snapshot.
            ///
            /// \param embedder_fields_deserializer Optional callback to deserialize
            /// internal fields. It should match the SerializeInternalFieldCallback used
            /// to serialize.
            ///
            /// \param extensions See v8::Context::New.
            ///
            /// \param global_object See v8::Context::New.
            #[link_name = "\u{1}?FromSnapshot@Context@v8@@SA?AV?$MaybeLocal@VContext@v8@@@2@PEAVIsolate@2@_KUDeserializeInternalFieldsCallback@2@PEAVExtensionConfiguration@2@V?$MaybeLocal@VValue@v8@@@2@@Z"]
            pub fn Context_FromSnapshot(
                isolate: *mut root::v8::Isolate,
                context_snapshot_index: usize,
                embedder_fields_deserializer: root::v8::DeserializeInternalFieldsCallback,
                extensions: *mut root::v8::ExtensionConfiguration,
                global_object: root::v8::MaybeLocal<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Context>;
        }
        extern "C" {
            /// Returns an global object that isn't backed by an actual context.
            ///
            /// The global template needs to have access checks with handlers installed.
            /// If an existing global object is passed in, the global object is detached
            /// from its context.
            ///
            /// Note that this is different from a detached context where all accesses to
            /// the global proxy will fail. Instead, the access check handlers are invoked.
            ///
            /// It is also not possible to detach an object returned by this method.
            /// Instead, the access check handlers need to return nothing to achieve the
            /// same effect.
            ///
            /// It is possible, however, to create a new context from the global object
            /// returned by this method.
            #[link_name = "\u{1}?NewRemoteContext@Context@v8@@SA?AV?$MaybeLocal@VObject@v8@@@2@PEAVIsolate@2@V?$Local@VObjectTemplate@v8@@@2@V?$MaybeLocal@VValue@v8@@@2@@Z"]
            pub fn Context_NewRemoteContext(
                isolate: *mut root::v8::Isolate,
                global_template: root::v8::Local<root::v8::ObjectTemplate>,
                global_object: root::v8::MaybeLocal<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Object>;
        }
        extern "C" {
            /// Sets the security token for the context.  To access an object in
            /// another context, the security tokens must match.
            #[link_name = "\u{1}?SetSecurityToken@Context@v8@@QEAAXV?$Local@VValue@v8@@@2@@Z"]
            pub fn Context_SetSecurityToken(
                this: *mut root::v8::Context,
                token: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            /// Restores the security token to the default value.
            #[link_name = "\u{1}?UseDefaultSecurityToken@Context@v8@@QEAAXXZ"]
            pub fn Context_UseDefaultSecurityToken(this: *mut root::v8::Context);
        }
        extern "C" {
            /// Returns the security token of this context.
            #[link_name = "\u{1}?GetSecurityToken@Context@v8@@QEAA?AV?$Local@VValue@v8@@@2@XZ"]
            pub fn Context_GetSecurityToken(
                this: *mut root::v8::Context,
            ) -> root::v8::Local<root::v8::Value>;
        }
        extern "C" {
            /// Enter this context.  After entering a context, all code compiled
            /// and run is compiled and run in this context.  If another context
            /// is already entered, this old context is saved so it can be
            /// restored when the new context is exited.
            #[link_name = "\u{1}?Enter@Context@v8@@QEAAXXZ"]
            pub fn Context_Enter(this: *mut root::v8::Context);
        }
        extern "C" {
            /// Exit this context.  Exiting the current context restores the
            /// context that was in place when entering the current context.
            #[link_name = "\u{1}?Exit@Context@v8@@QEAAXXZ"]
            pub fn Context_Exit(this: *mut root::v8::Context);
        }
        extern "C" {
            /// Returns an isolate associated with a current context.
            #[link_name = "\u{1}?GetIsolate@Context@v8@@QEAAPEAVIsolate@2@XZ"]
            pub fn Context_GetIsolate(this: *mut root::v8::Context) -> *mut root::v8::Isolate;
        }
        extern "C" {
            /// Return the number of fields allocated for embedder data.
            #[link_name = "\u{1}?GetNumberOfEmbedderDataFields@Context@v8@@QEAAIXZ"]
            pub fn Context_GetNumberOfEmbedderDataFields(this: *mut root::v8::Context) -> u32;
        }
        extern "C" {
            /// Gets the binding object used by V8 extras. Extra natives get a reference
            /// to this object and can use it to "export" functionality by adding
            /// properties. Extra natives can also "import" functionality by accessing
            /// properties added by the embedder using the V8 API.
            #[link_name = "\u{1}?GetExtrasBindingObject@Context@v8@@QEAA?AV?$Local@VObject@v8@@@2@XZ"]
            pub fn Context_GetExtrasBindingObject(
                this: *mut root::v8::Context,
            ) -> root::v8::Local<root::v8::Object>;
        }
        extern "C" {
            /// Sets the embedder data with the given index, growing the data as
            /// needed. Note that index 0 currently has a special meaning for Chrome's
            /// debugger.
            #[link_name = "\u{1}?SetEmbedderData@Context@v8@@QEAAXHV?$Local@VValue@v8@@@2@@Z"]
            pub fn Context_SetEmbedderData(
                this: *mut root::v8::Context,
                index: ::std::os::raw::c_int,
                value: root::v8::Local<root::v8::Value>,
            );
        }
        extern "C" {
            /// Sets a 2-byte-aligned native pointer in the embedder data with the given
            /// index, growing the data as needed. Note that index 0 currently has a
            /// special meaning for Chrome's debugger.
            #[link_name = "\u{1}?SetAlignedPointerInEmbedderData@Context@v8@@QEAAXHPEAX@Z"]
            pub fn Context_SetAlignedPointerInEmbedderData(
                this: *mut root::v8::Context,
                index: ::std::os::raw::c_int,
                value: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            /// Control whether code generation from strings is allowed. Calling
            /// this method with false will disable 'eval' and the 'Function'
            /// constructor for code running in this context. If 'eval' or the
            /// 'Function' constructor are used an exception will be thrown.
            ///
            /// If code generation from strings is not allowed the
            /// V8::AllowCodeGenerationFromStrings callback will be invoked if
            /// set before blocking the call to 'eval' or the 'Function'
            /// constructor. If that callback returns true, the call will be
            /// allowed, otherwise an exception will be thrown. If no callback is
            /// set an exception will be thrown.
            #[link_name = "\u{1}?AllowCodeGenerationFromStrings@Context@v8@@QEAAX_N@Z"]
            pub fn Context_AllowCodeGenerationFromStrings(
                this: *mut root::v8::Context,
                allow: bool,
            );
        }
        extern "C" {
            /// Returns true if code generation from strings is allowed for the context.
            /// For more details see AllowCodeGenerationFromStrings(bool) documentation.
            #[link_name = "\u{1}?IsCodeGenerationFromStringsAllowed@Context@v8@@QEAA_NXZ"]
            pub fn Context_IsCodeGenerationFromStringsAllowed(this: *mut root::v8::Context)
                -> bool;
        }
        extern "C" {
            /// Sets the error description for the exception that is thrown when
            /// code generation from strings is not allowed and 'eval' or the 'Function'
            /// constructor are called.
            #[link_name = "\u{1}?SetErrorMessageForCodeGenerationFromStrings@Context@v8@@QEAAXV?$Local@VString@v8@@@2@@Z"]
            pub fn Context_SetErrorMessageForCodeGenerationFromStrings(
                this: *mut root::v8::Context,
                message: root::v8::Local<root::v8::String>,
            );
        }
        impl Context {
            #[inline]
            pub unsafe fn Global(&mut self) -> root::v8::Local<root::v8::Object> {
                Context_Global(self)
            }
            #[inline]
            pub unsafe fn DetachGlobal(&mut self) {
                Context_DetachGlobal(self)
            }
            #[inline]
            pub unsafe fn New(
                isolate: *mut root::v8::Isolate,
                extensions: *mut root::v8::ExtensionConfiguration,
                global_template: root::v8::MaybeLocal<root::v8::ObjectTemplate>,
                global_object: root::v8::MaybeLocal<root::v8::Value>,
                internal_fields_deserializer: root::v8::DeserializeInternalFieldsCallback,
            ) -> root::v8::Local<root::v8::Context> {
                Context_New(
                    isolate,
                    extensions,
                    global_template,
                    global_object,
                    internal_fields_deserializer,
                )
            }
            #[inline]
            pub unsafe fn FromSnapshot(
                isolate: *mut root::v8::Isolate,
                context_snapshot_index: usize,
                embedder_fields_deserializer: root::v8::DeserializeInternalFieldsCallback,
                extensions: *mut root::v8::ExtensionConfiguration,
                global_object: root::v8::MaybeLocal<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Context> {
                Context_FromSnapshot(
                    isolate,
                    context_snapshot_index,
                    embedder_fields_deserializer,
                    extensions,
                    global_object,
                )
            }
            #[inline]
            pub unsafe fn NewRemoteContext(
                isolate: *mut root::v8::Isolate,
                global_template: root::v8::Local<root::v8::ObjectTemplate>,
                global_object: root::v8::MaybeLocal<root::v8::Value>,
            ) -> root::v8::MaybeLocal<root::v8::Object> {
                Context_NewRemoteContext(isolate, global_template, global_object)
            }
            #[inline]
            pub unsafe fn SetSecurityToken(&mut self, token: root::v8::Local<root::v8::Value>) {
                Context_SetSecurityToken(self, token)
            }
            #[inline]
            pub unsafe fn UseDefaultSecurityToken(&mut self) {
                Context_UseDefaultSecurityToken(self)
            }
            #[inline]
            pub unsafe fn GetSecurityToken(&mut self) -> root::v8::Local<root::v8::Value> {
                Context_GetSecurityToken(self)
            }
            #[inline]
            pub unsafe fn Enter(&mut self) {
                Context_Enter(self)
            }
            #[inline]
            pub unsafe fn Exit(&mut self) {
                Context_Exit(self)
            }
            #[inline]
            pub unsafe fn GetIsolate(&mut self) -> *mut root::v8::Isolate {
                Context_GetIsolate(self)
            }
            #[inline]
            pub unsafe fn GetNumberOfEmbedderDataFields(&mut self) -> u32 {
                Context_GetNumberOfEmbedderDataFields(self)
            }
            #[inline]
            pub unsafe fn GetExtrasBindingObject(&mut self) -> root::v8::Local<root::v8::Object> {
                Context_GetExtrasBindingObject(self)
            }
            #[inline]
            pub unsafe fn SetEmbedderData(
                &mut self,
                index: ::std::os::raw::c_int,
                value: root::v8::Local<root::v8::Value>,
            ) {
                Context_SetEmbedderData(self, index, value)
            }
            #[inline]
            pub unsafe fn SetAlignedPointerInEmbedderData(
                &mut self,
                index: ::std::os::raw::c_int,
                value: *mut ::std::os::raw::c_void,
            ) {
                Context_SetAlignedPointerInEmbedderData(self, index, value)
            }
            #[inline]
            pub unsafe fn AllowCodeGenerationFromStrings(&mut self, allow: bool) {
                Context_AllowCodeGenerationFromStrings(self, allow)
            }
            #[inline]
            pub unsafe fn IsCodeGenerationFromStringsAllowed(&mut self) -> bool {
                Context_IsCodeGenerationFromStringsAllowed(self)
            }
            #[inline]
            pub unsafe fn SetErrorMessageForCodeGenerationFromStrings(
                &mut self,
                message: root::v8::Local<root::v8::String>,
            ) {
                Context_SetErrorMessageForCodeGenerationFromStrings(self, message)
            }
        }
        /// Multiple threads in V8 are allowed, but only one thread at a time is allowed
        /// to use any given V8 isolate, see the comments in the Isolate class. The
        /// definition of 'using a V8 isolate' includes accessing handles or holding onto
        /// object pointers obtained from V8 handles while in the particular V8 isolate.
        /// It is up to the user of V8 to ensure, perhaps with locking, that this
        /// constraint is not violated. In addition to any other synchronization
        /// mechanism that may be used, the v8::Locker and v8::Unlocker classes must be
        /// used to signal thread switches to V8.
        ///
        /// v8::Locker is a scoped lock object. While it's active, i.e. between its
        /// construction and destruction, the current thread is allowed to use the locked
        /// isolate. V8 guarantees that an isolate can be locked by at most one thread at
        /// any time. In other words, the scope of a v8::Locker is a critical section.
        ///
        /// Sample usage:
        /// \code
        /// ...
        /// {
        /// v8::Locker locker(isolate);
        /// v8::Isolate::Scope isolate_scope(isolate);
        /// ...
        /// // Code using V8 and isolate goes here.
        /// ...
        /// } // Destructor called here
        /// \endcode
        ///
        /// If you wish to stop using V8 in a thread A you can do this either by
        /// destroying the v8::Locker object as above or by constructing a v8::Unlocker
        /// object:
        ///
        /// \code
        /// {
        /// isolate->Exit();
        /// v8::Unlocker unlocker(isolate);
        /// ...
        /// // Code not using V8 goes here while V8 can run in another thread.
        /// ...
        /// } // Destructor called here.
        /// isolate->Enter();
        /// \endcode
        ///
        /// The Unlocker object is intended for use in a long-running callback from V8,
        /// where you want to release the V8 lock for other threads to use.
        ///
        /// The v8::Locker is a recursive lock, i.e. you can lock more than once in a
        /// given thread. This can be useful if you have code that can be called either
        /// from code that holds the lock or from code that does not. The Unlocker is
        /// not recursive so you can not have several Unlockers on the stack at once, and
        /// you can not use an Unlocker in a thread that is not inside a Locker's scope.
        ///
        /// An unlocker will unlock several lockers if it has to and reinstate the
        /// correct depth of locking on its destruction, e.g.:
        ///
        /// \code
        /// // V8 not locked.
        /// {
        /// v8::Locker locker(isolate);
        /// Isolate::Scope isolate_scope(isolate);
        /// // V8 locked.
        /// {
        /// v8::Locker another_locker(isolate);
        /// // V8 still locked (2 levels).
        /// {
        /// isolate->Exit();
        /// v8::Unlocker unlocker(isolate);
        /// // V8 not locked.
        /// }
        /// isolate->Enter();
        /// // V8 locked again (2 levels).
        /// }
        /// // V8 still locked (1 level).
        /// }
        /// // V8 Now no longer locked.
        /// \endcode
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Unlocker {
            pub isolate_: *mut root::v8::internal::Isolate,
        }
        #[test]
        fn bindgen_test_layout_Unlocker() {
            assert_eq!(
                ::std::mem::size_of::<Unlocker>(),
                8usize,
                concat!("Size of: ", stringify!(Unlocker))
            );
            assert_eq!(
                ::std::mem::align_of::<Unlocker>(),
                8usize,
                concat!("Alignment of ", stringify!(Unlocker))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Unlocker>())).isolate_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Unlocker),
                    "::",
                    stringify!(isolate_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DUnlocker@v8@@QEAAXXZ"]
            pub fn Unlocker_Unlocker_destructor(this: *mut root::v8::Unlocker);
        }
        impl Unlocker {
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Unlocker_Unlocker_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Locker {
            pub has_lock_: bool,
            pub top_level_: bool,
            pub isolate_: *mut root::v8::internal::Isolate,
        }
        #[test]
        fn bindgen_test_layout_Locker() {
            assert_eq!(
                ::std::mem::size_of::<Locker>(),
                16usize,
                concat!("Size of: ", stringify!(Locker))
            );
            assert_eq!(
                ::std::mem::align_of::<Locker>(),
                8usize,
                concat!("Alignment of ", stringify!(Locker))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Locker>())).has_lock_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Locker),
                    "::",
                    stringify!(has_lock_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Locker>())).top_level_ as *const _ as usize },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Locker),
                    "::",
                    stringify!(top_level_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Locker>())).isolate_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Locker),
                    "::",
                    stringify!(isolate_)
                )
            );
        }
        extern "C" {
            /// Returns whether or not the locker for a given isolate, is locked by the
            /// current thread.
            #[link_name = "\u{1}?IsLocked@Locker@v8@@SA_NPEAVIsolate@2@@Z"]
            pub fn Locker_IsLocked(isolate: *mut root::v8::Isolate) -> bool;
        }
        extern "C" {
            /// Returns whether v8::Locker is being used by this V8 instance.
            #[link_name = "\u{1}?IsActive@Locker@v8@@SA_NXZ"]
            pub fn Locker_IsActive() -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??_DLocker@v8@@QEAAXXZ"]
            pub fn Locker_Locker_destructor(this: *mut root::v8::Locker);
        }
        impl Locker {
            #[inline]
            pub unsafe fn IsLocked(isolate: *mut root::v8::Isolate) -> bool {
                Locker_IsLocked(isolate)
            }
            #[inline]
            pub unsafe fn IsActive() -> bool {
                Locker_IsActive()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Locker_Locker_destructor(self)
            }
        }
        #[repr(C)]
        pub struct Task__bindgen_vtable(::std::os::raw::c_void);
        /// A Task represents a unit of work.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Task {
            pub vtable_: *const Task__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_Task() {
            assert_eq!(
                ::std::mem::size_of::<Task>(),
                8usize,
                concat!("Size of: ", stringify!(Task))
            );
            assert_eq!(
                ::std::mem::align_of::<Task>(),
                8usize,
                concat!("Alignment of ", stringify!(Task))
            );
        }
        #[repr(C)]
        pub struct IdleTask__bindgen_vtable(::std::os::raw::c_void);
        /// An IdleTask represents a unit of work to be performed in idle time.
        /// The Run method is invoked with an argument that specifies the deadline in
        /// seconds returned by MonotonicallyIncreasingTime().
        /// The idle task is expected to complete by this deadline.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct IdleTask {
            pub vtable_: *const IdleTask__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_IdleTask() {
            assert_eq!(
                ::std::mem::size_of::<IdleTask>(),
                8usize,
                concat!("Size of: ", stringify!(IdleTask))
            );
            assert_eq!(
                ::std::mem::align_of::<IdleTask>(),
                8usize,
                concat!("Alignment of ", stringify!(IdleTask))
            );
        }
        #[repr(C)]
        pub struct TaskRunner__bindgen_vtable(::std::os::raw::c_void);
        /// A TaskRunner allows scheduling of tasks. The TaskRunner may still be used to
        /// post tasks after the isolate gets destructed, but these tasks may not get
        /// executed anymore. All tasks posted to a given TaskRunner will be invoked in
        /// sequence. Tasks can be posted from any thread.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct TaskRunner {
            pub vtable_: *const TaskRunner__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_TaskRunner() {
            assert_eq!(
                ::std::mem::size_of::<TaskRunner>(),
                8usize,
                concat!("Size of: ", stringify!(TaskRunner))
            );
            assert_eq!(
                ::std::mem::align_of::<TaskRunner>(),
                8usize,
                concat!("Alignment of ", stringify!(TaskRunner))
            );
        }
        #[repr(C)]
        pub struct ConvertableToTraceFormat__bindgen_vtable(::std::os::raw::c_void);
        /// The interface represents complex arguments to trace events.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct ConvertableToTraceFormat {
            pub vtable_: *const ConvertableToTraceFormat__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ConvertableToTraceFormat() {
            assert_eq!(
                ::std::mem::size_of::<ConvertableToTraceFormat>(),
                8usize,
                concat!("Size of: ", stringify!(ConvertableToTraceFormat))
            );
            assert_eq!(
                ::std::mem::align_of::<ConvertableToTraceFormat>(),
                8usize,
                concat!("Alignment of ", stringify!(ConvertableToTraceFormat))
            );
        }
        #[repr(C)]
        pub struct TracingController__bindgen_vtable(::std::os::raw::c_void);
        /// V8 Tracing controller.
        ///
        /// Can be implemented by an embedder to record trace events from V8.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct TracingController {
            pub vtable_: *const TracingController__bindgen_vtable,
        }
        #[repr(C)]
        pub struct TracingController_TraceStateObserver__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct TracingController_TraceStateObserver {
            pub vtable_: *const TracingController_TraceStateObserver__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_TracingController_TraceStateObserver() {
            assert_eq!(
                ::std::mem::size_of::<TracingController_TraceStateObserver>(),
                8usize,
                concat!(
                    "Size of: ",
                    stringify!(TracingController_TraceStateObserver)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<TracingController_TraceStateObserver>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(TracingController_TraceStateObserver)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_TracingController() {
            assert_eq!(
                ::std::mem::size_of::<TracingController>(),
                8usize,
                concat!("Size of: ", stringify!(TracingController))
            );
            assert_eq!(
                ::std::mem::align_of::<TracingController>(),
                8usize,
                concat!("Alignment of ", stringify!(TracingController))
            );
        }
        pub const PageAllocator_Permission_kNoAccess: root::v8::PageAllocator_Permission = 0;
        pub const PageAllocator_Permission_kRead: root::v8::PageAllocator_Permission = 1;
        pub const PageAllocator_Permission_kReadWrite: root::v8::PageAllocator_Permission = 2;
        pub const PageAllocator_Permission_kReadWriteExecute: root::v8::PageAllocator_Permission =
            3;
        pub const PageAllocator_Permission_kReadExecute: root::v8::PageAllocator_Permission = 4;
        /// Memory permissions.
        pub type PageAllocator_Permission = i32;
        #[repr(C)]
        pub struct Platform__bindgen_vtable(::std::os::raw::c_void);
        /// V8 Platform abstraction layer.
        ///
        /// The embedder has to provide an implementation of this interface before
        /// initializing the rest of V8.
        #[repr(C)]
        #[derive(Debug, Hash, PartialEq, Eq)]
        pub struct Platform {
            pub vtable_: *const Platform__bindgen_vtable,
        }
        pub type Platform_StackTracePrinter = ::std::option::Option<unsafe extern "C" fn()>;
        #[test]
        fn bindgen_test_layout_Platform() {
            assert_eq!(
                ::std::mem::size_of::<Platform>(),
                8usize,
                concat!("Size of: ", stringify!(Platform))
            );
            assert_eq!(
                ::std::mem::align_of::<Platform>(),
                8usize,
                concat!("Alignment of ", stringify!(Platform))
            );
        }
        extern "C" {
            /// Default implementation of current wall-clock time in milliseconds
            /// since epoch. Useful for implementing |CurrentClockTimeMillis| if
            /// nothing special needed.
            #[link_name = "\u{1}?SystemClockTimeMillis@Platform@v8@@KANXZ"]
            pub fn Platform_SystemClockTimeMillis() -> f64;
        }
        impl Platform {
            #[inline]
            pub unsafe fn SystemClockTimeMillis() -> f64 {
                Platform_SystemClockTimeMillis()
            }
        }
        pub mod base {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Mutex {
                _unused: [u8; 0],
            }
        }
        pub mod platform {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod tracing {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub const kTraceMaxNumArgs: ::std::os::raw::c_int = 2;
                #[repr(C)]
                pub struct TraceObject {
                    pub pid_: ::std::os::raw::c_int,
                    pub tid_: ::std::os::raw::c_int,
                    pub phase_: ::std::os::raw::c_char,
                    pub name_: *const ::std::os::raw::c_char,
                    pub scope_: *const ::std::os::raw::c_char,
                    pub category_enabled_flag_: *const u8,
                    pub id_: u64,
                    pub bind_id_: u64,
                    pub num_args_: ::std::os::raw::c_int,
                    pub arg_names_: [*const ::std::os::raw::c_char; 2usize],
                    pub arg_types_: [u8; 2usize],
                    pub arg_values_: [root::v8::platform::tracing::TraceObject_ArgValue; 2usize],
                    pub arg_convertables_: [u64; 2usize],
                    pub parameter_copy_storage_: *mut ::std::os::raw::c_char,
                    pub flags_: ::std::os::raw::c_uint,
                    pub ts_: i64,
                    pub tts_: i64,
                    pub duration_: u64,
                    pub cpu_duration_: u64,
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub union TraceObject_ArgValue {
                    pub as_bool: bool,
                    pub as_uint: u64,
                    pub as_int: i64,
                    pub as_double: f64,
                    pub as_pointer: *const ::std::os::raw::c_void,
                    pub as_string: *const ::std::os::raw::c_char,
                    _bindgen_union_align: u64,
                }
                #[test]
                fn bindgen_test_layout_TraceObject_ArgValue() {
                    assert_eq!(
                        ::std::mem::size_of::<TraceObject_ArgValue>(),
                        8usize,
                        concat!("Size of: ", stringify!(TraceObject_ArgValue))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<TraceObject_ArgValue>(),
                        8usize,
                        concat!("Alignment of ", stringify!(TraceObject_ArgValue))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject_ArgValue>())).as_bool as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject_ArgValue),
                            "::",
                            stringify!(as_bool)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject_ArgValue>())).as_uint as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject_ArgValue),
                            "::",
                            stringify!(as_uint)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject_ArgValue>())).as_int as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject_ArgValue),
                            "::",
                            stringify!(as_int)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject_ArgValue>())).as_double as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject_ArgValue),
                            "::",
                            stringify!(as_double)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject_ArgValue>())).as_pointer as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject_ArgValue),
                            "::",
                            stringify!(as_pointer)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject_ArgValue>())).as_string as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject_ArgValue),
                            "::",
                            stringify!(as_string)
                        )
                    );
                }
                #[test]
                fn bindgen_test_layout_TraceObject() {
                    assert_eq!(
                        ::std::mem::size_of::<TraceObject>(),
                        168usize,
                        concat!("Size of: ", stringify!(TraceObject))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<TraceObject>(),
                        8usize,
                        concat!("Alignment of ", stringify!(TraceObject))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).pid_ as *const _ as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(pid_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).tid_ as *const _ as usize
                        },
                        4usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(tid_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).phase_ as *const _ as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(phase_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).name_ as *const _ as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(name_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).scope_ as *const _ as usize
                        },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(scope_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).category_enabled_flag_
                                as *const _ as usize
                        },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(category_enabled_flag_)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::std::ptr::null::<TraceObject>())).id_ as *const _ as usize },
                        40usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(id_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).bind_id_ as *const _ as usize
                        },
                        48usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(bind_id_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).num_args_ as *const _ as usize
                        },
                        56usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(num_args_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).arg_names_ as *const _ as usize
                        },
                        64usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(arg_names_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).arg_types_ as *const _ as usize
                        },
                        80usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(arg_types_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).arg_values_ as *const _ as usize
                        },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(arg_values_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).arg_convertables_ as *const _
                                as usize
                        },
                        104usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(arg_convertables_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).parameter_copy_storage_
                                as *const _ as usize
                        },
                        120usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(parameter_copy_storage_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).flags_ as *const _ as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(flags_)
                        )
                    );
                    assert_eq!(
                        unsafe { &(*(::std::ptr::null::<TraceObject>())).ts_ as *const _ as usize },
                        136usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(ts_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).tts_ as *const _ as usize
                        },
                        144usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(tts_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).duration_ as *const _ as usize
                        },
                        152usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(duration_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceObject>())).cpu_duration_ as *const _
                                as usize
                        },
                        160usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceObject),
                            "::",
                            stringify!(cpu_duration_)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?Initialize@TraceObject@tracing@platform@v8@@QEAAXDPEBEPEBD1_K2HPEAPEBD0PEB_KPEAV?$unique_ptr@VConvertableToTraceFormat@v8@@U?$default_delete@VConvertableToTraceFormat@v8@@@std@@@std@@I_J6@Z"]
                    pub fn TraceObject_Initialize(
                        this: *mut root::v8::platform::tracing::TraceObject,
                        phase: ::std::os::raw::c_char,
                        category_enabled_flag: *const u8,
                        name: *const ::std::os::raw::c_char,
                        scope: *const ::std::os::raw::c_char,
                        id: u64,
                        bind_id: u64,
                        num_args: ::std::os::raw::c_int,
                        arg_names: *mut *const ::std::os::raw::c_char,
                        arg_types: *const u8,
                        arg_values: *const u64,
                        arg_convertables: *mut u64,
                        flags: ::std::os::raw::c_uint,
                        timestamp: i64,
                        cpu_timestamp: i64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?UpdateDuration@TraceObject@tracing@platform@v8@@QEAAX_J0@Z"]
                    pub fn TraceObject_UpdateDuration(
                        this: *mut root::v8::platform::tracing::TraceObject,
                        timestamp: i64,
                        cpu_timestamp: i64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?InitializeForTesting@TraceObject@tracing@platform@v8@@QEAAXDPEBEPEBD1_K2HPEAPEBD0PEB_KPEAV?$unique_ptr@VConvertableToTraceFormat@v8@@U?$default_delete@VConvertableToTraceFormat@v8@@@std@@@std@@IHH_J622@Z"]
                    pub fn TraceObject_InitializeForTesting(
                        this: *mut root::v8::platform::tracing::TraceObject,
                        phase: ::std::os::raw::c_char,
                        category_enabled_flag: *const u8,
                        name: *const ::std::os::raw::c_char,
                        scope: *const ::std::os::raw::c_char,
                        id: u64,
                        bind_id: u64,
                        num_args: ::std::os::raw::c_int,
                        arg_names: *mut *const ::std::os::raw::c_char,
                        arg_types: *const u8,
                        arg_values: *const u64,
                        arg_convertables: *mut u64,
                        flags: ::std::os::raw::c_uint,
                        pid: ::std::os::raw::c_int,
                        tid: ::std::os::raw::c_int,
                        ts: i64,
                        tts: i64,
                        duration: u64,
                        cpu_duration: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}??_DTraceObject@tracing@platform@v8@@QEAAXXZ"]
                    pub fn TraceObject_TraceObject_destructor(
                        this: *mut root::v8::platform::tracing::TraceObject,
                    );
                }
                impl TraceObject {
                    #[inline]
                    pub unsafe fn Initialize(
                        &mut self,
                        phase: ::std::os::raw::c_char,
                        category_enabled_flag: *const u8,
                        name: *const ::std::os::raw::c_char,
                        scope: *const ::std::os::raw::c_char,
                        id: u64,
                        bind_id: u64,
                        num_args: ::std::os::raw::c_int,
                        arg_names: *mut *const ::std::os::raw::c_char,
                        arg_types: *const u8,
                        arg_values: *const u64,
                        arg_convertables: *mut u64,
                        flags: ::std::os::raw::c_uint,
                        timestamp: i64,
                        cpu_timestamp: i64,
                    ) {
                        TraceObject_Initialize(
                            self,
                            phase,
                            category_enabled_flag,
                            name,
                            scope,
                            id,
                            bind_id,
                            num_args,
                            arg_names,
                            arg_types,
                            arg_values,
                            arg_convertables,
                            flags,
                            timestamp,
                            cpu_timestamp,
                        )
                    }
                    #[inline]
                    pub unsafe fn UpdateDuration(&mut self, timestamp: i64, cpu_timestamp: i64) {
                        TraceObject_UpdateDuration(self, timestamp, cpu_timestamp)
                    }
                    #[inline]
                    pub unsafe fn InitializeForTesting(
                        &mut self,
                        phase: ::std::os::raw::c_char,
                        category_enabled_flag: *const u8,
                        name: *const ::std::os::raw::c_char,
                        scope: *const ::std::os::raw::c_char,
                        id: u64,
                        bind_id: u64,
                        num_args: ::std::os::raw::c_int,
                        arg_names: *mut *const ::std::os::raw::c_char,
                        arg_types: *const u8,
                        arg_values: *const u64,
                        arg_convertables: *mut u64,
                        flags: ::std::os::raw::c_uint,
                        pid: ::std::os::raw::c_int,
                        tid: ::std::os::raw::c_int,
                        ts: i64,
                        tts: i64,
                        duration: u64,
                        cpu_duration: u64,
                    ) {
                        TraceObject_InitializeForTesting(
                            self,
                            phase,
                            category_enabled_flag,
                            name,
                            scope,
                            id,
                            bind_id,
                            num_args,
                            arg_names,
                            arg_types,
                            arg_values,
                            arg_convertables,
                            flags,
                            pid,
                            tid,
                            ts,
                            tts,
                            duration,
                            cpu_duration,
                        )
                    }
                    #[inline]
                    pub unsafe fn destruct(&mut self) {
                        TraceObject_TraceObject_destructor(self)
                    }
                }
                #[repr(C)]
                pub struct TraceWriter__bindgen_vtable(::std::os::raw::c_void);
                #[repr(C)]
                #[derive(Debug, Hash, PartialEq, Eq)]
                pub struct TraceWriter {
                    pub vtable_: *const TraceWriter__bindgen_vtable,
                }
                #[test]
                fn bindgen_test_layout_TraceWriter() {
                    assert_eq!(
                        ::std::mem::size_of::<TraceWriter>(),
                        8usize,
                        concat!("Size of: ", stringify!(TraceWriter))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<TraceWriter>(),
                        8usize,
                        concat!("Alignment of ", stringify!(TraceWriter))
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?CreateJSONTraceWriter@TraceWriter@tracing@platform@v8@@SAPEAV1234@AEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z"]
                    pub fn TraceWriter_CreateJSONTraceWriter(
                        stream: *mut root::std::ostream,
                    ) -> *mut root::v8::platform::tracing::TraceWriter;
                }
                extern "C" {
                    #[link_name = "\u{1}?CreateJSONTraceWriter@TraceWriter@tracing@platform@v8@@SAPEAV1234@AEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@6@@Z"]
                    pub fn TraceWriter_CreateJSONTraceWriter1(
                        stream: *mut root::std::ostream,
                        tag: *const root::std::string,
                    ) -> *mut root::v8::platform::tracing::TraceWriter;
                }
                impl TraceWriter {
                    #[inline]
                    pub unsafe fn CreateJSONTraceWriter(
                        stream: *mut root::std::ostream,
                    ) -> *mut root::v8::platform::tracing::TraceWriter {
                        TraceWriter_CreateJSONTraceWriter(stream)
                    }
                    #[inline]
                    pub unsafe fn CreateJSONTraceWriter1(
                        stream: *mut root::std::ostream,
                        tag: *const root::std::string,
                    ) -> *mut root::v8::platform::tracing::TraceWriter {
                        TraceWriter_CreateJSONTraceWriter1(stream, tag)
                    }
                }
                #[repr(C)]
                pub struct TraceBufferChunk {
                    pub next_free_: usize,
                    pub chunk_: [root::v8::platform::tracing::TraceObject; 64usize],
                    pub seq_: u32,
                }
                pub const TraceBufferChunk_kChunkSize: usize = 64;
                #[test]
                fn bindgen_test_layout_TraceBufferChunk() {
                    assert_eq!(
                        ::std::mem::size_of::<TraceBufferChunk>(),
                        10768usize,
                        concat!("Size of: ", stringify!(TraceBufferChunk))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<TraceBufferChunk>(),
                        8usize,
                        concat!("Alignment of ", stringify!(TraceBufferChunk))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceBufferChunk>())).next_free_ as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceBufferChunk),
                            "::",
                            stringify!(next_free_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceBufferChunk>())).chunk_ as *const _ as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceBufferChunk),
                            "::",
                            stringify!(chunk_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceBufferChunk>())).seq_ as *const _ as usize
                        },
                        10760usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceBufferChunk),
                            "::",
                            stringify!(seq_)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?Reset@TraceBufferChunk@tracing@platform@v8@@QEAAXI@Z"]
                    pub fn TraceBufferChunk_Reset(
                        this: *mut root::v8::platform::tracing::TraceBufferChunk,
                        new_seq: u32,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?AddTraceEvent@TraceBufferChunk@tracing@platform@v8@@QEAAPEAVTraceObject@234@PEA_K@Z"]
                    pub fn TraceBufferChunk_AddTraceEvent(
                        this: *mut root::v8::platform::tracing::TraceBufferChunk,
                        event_index: *mut usize,
                    ) -> *mut root::v8::platform::tracing::TraceObject;
                }
                extern "C" {
                    #[link_name = "\u{1}??0TraceBufferChunk@tracing@platform@v8@@QEAA@I@Z"]
                    pub fn TraceBufferChunk_TraceBufferChunk(
                        this: *mut root::v8::platform::tracing::TraceBufferChunk,
                        seq: u32,
                    );
                }
                impl TraceBufferChunk {
                    #[inline]
                    pub unsafe fn Reset(&mut self, new_seq: u32) {
                        TraceBufferChunk_Reset(self, new_seq)
                    }
                    #[inline]
                    pub unsafe fn AddTraceEvent(
                        &mut self,
                        event_index: *mut usize,
                    ) -> *mut root::v8::platform::tracing::TraceObject {
                        TraceBufferChunk_AddTraceEvent(self, event_index)
                    }
                    #[inline]
                    pub unsafe fn new(seq: u32) -> Self {
                        let mut __bindgen_tmp = ::std::mem::uninitialized();
                        TraceBufferChunk_TraceBufferChunk(&mut __bindgen_tmp, seq);
                        __bindgen_tmp
                    }
                }
                #[repr(C)]
                pub struct TraceBuffer__bindgen_vtable(::std::os::raw::c_void);
                #[repr(C)]
                #[derive(Debug, Hash, PartialEq, Eq)]
                pub struct TraceBuffer {
                    pub vtable_: *const TraceBuffer__bindgen_vtable,
                }
                pub const TraceBuffer_kRingBufferChunks: usize = 1024;
                #[test]
                fn bindgen_test_layout_TraceBuffer() {
                    assert_eq!(
                        ::std::mem::size_of::<TraceBuffer>(),
                        8usize,
                        concat!("Size of: ", stringify!(TraceBuffer))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<TraceBuffer>(),
                        8usize,
                        concat!("Alignment of ", stringify!(TraceBuffer))
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?CreateTraceBufferRingBuffer@TraceBuffer@tracing@platform@v8@@SAPEAV1234@_KPEAVTraceWriter@234@@Z"]
                    pub fn TraceBuffer_CreateTraceBufferRingBuffer(
                        max_chunks: usize,
                        trace_writer: *mut root::v8::platform::tracing::TraceWriter,
                    ) -> *mut root::v8::platform::tracing::TraceBuffer;
                }
                impl TraceBuffer {
                    #[inline]
                    pub unsafe fn CreateTraceBufferRingBuffer(
                        max_chunks: usize,
                        trace_writer: *mut root::v8::platform::tracing::TraceWriter,
                    ) -> *mut root::v8::platform::tracing::TraceBuffer {
                        TraceBuffer_CreateTraceBufferRingBuffer(max_chunks, trace_writer)
                    }
                }
                pub const TraceRecordMode_RECORD_UNTIL_FULL:
                    root::v8::platform::tracing::TraceRecordMode = 0;
                pub const TraceRecordMode_RECORD_CONTINUOUSLY:
                    root::v8::platform::tracing::TraceRecordMode = 1;
                pub const TraceRecordMode_RECORD_AS_MUCH_AS_POSSIBLE:
                    root::v8::platform::tracing::TraceRecordMode = 2;
                pub const TraceRecordMode_ECHO_TO_CONSOLE:
                    root::v8::platform::tracing::TraceRecordMode = 3;
                pub type TraceRecordMode = i32;
                #[repr(C)]
                #[derive(Debug, Hash, PartialEq, Eq)]
                pub struct TraceConfig {
                    pub record_mode_: root::v8::platform::tracing::TraceRecordMode,
                    pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
                    pub included_categories_: root::v8::platform::tracing::TraceConfig_StringList,
                }
                pub type TraceConfig_StringList = [u64; 3usize];
                #[test]
                fn bindgen_test_layout_TraceConfig() {
                    assert_eq!(
                        ::std::mem::size_of::<TraceConfig>(),
                        32usize,
                        concat!("Size of: ", stringify!(TraceConfig))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<TraceConfig>(),
                        8usize,
                        concat!("Alignment of ", stringify!(TraceConfig))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceConfig>())).record_mode_ as *const _
                                as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceConfig),
                            "::",
                            stringify!(record_mode_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TraceConfig>())).included_categories_ as *const _
                                as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TraceConfig),
                            "::",
                            stringify!(included_categories_)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?CreateDefaultTraceConfig@TraceConfig@tracing@platform@v8@@SAPEAV1234@XZ"]
                    pub fn TraceConfig_CreateDefaultTraceConfig(
) -> *mut root::v8::platform::tracing::TraceConfig;
                }
                extern "C" {
                    #[link_name = "\u{1}?AddIncludedCategory@TraceConfig@tracing@platform@v8@@QEAAXPEBD@Z"]
                    pub fn TraceConfig_AddIncludedCategory(
                        this: *mut root::v8::platform::tracing::TraceConfig,
                        included_category: *const ::std::os::raw::c_char,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?IsCategoryGroupEnabled@TraceConfig@tracing@platform@v8@@QEBA_NPEBD@Z"]
                    pub fn TraceConfig_IsCategoryGroupEnabled(
                        this: *const root::v8::platform::tracing::TraceConfig,
                        category_group: *const ::std::os::raw::c_char,
                    ) -> bool;
                }
                impl TraceConfig {
                    #[inline]
                    pub fn enable_systrace_(&self) -> bool {
                        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
                    }
                    #[inline]
                    pub fn set_enable_systrace_(&mut self, val: bool) {
                        unsafe {
                            let val: u8 = ::std::mem::transmute(val);
                            self._bitfield_1.set(0usize, 1u8, val as u64)
                        }
                    }
                    #[inline]
                    pub fn enable_argument_filter_(&self) -> bool {
                        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
                    }
                    #[inline]
                    pub fn set_enable_argument_filter_(&mut self, val: bool) {
                        unsafe {
                            let val: u8 = ::std::mem::transmute(val);
                            self._bitfield_1.set(1usize, 1u8, val as u64)
                        }
                    }
                    #[inline]
                    pub fn new_bitfield_1(
                        enable_systrace_: bool,
                        enable_argument_filter_: bool,
                    ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
                        let mut __bindgen_bitfield_unit : root :: __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ;
                        __bindgen_bitfield_unit.set(0usize, 1u8, {
                            let enable_systrace_: u8 =
                                unsafe { ::std::mem::transmute(enable_systrace_) };
                            enable_systrace_ as u64
                        });
                        __bindgen_bitfield_unit.set(1usize, 1u8, {
                            let enable_argument_filter_: u8 =
                                unsafe { ::std::mem::transmute(enable_argument_filter_) };
                            enable_argument_filter_ as u64
                        });
                        __bindgen_bitfield_unit
                    }
                    #[inline]
                    pub unsafe fn CreateDefaultTraceConfig(
) -> *mut root::v8::platform::tracing::TraceConfig {
                        TraceConfig_CreateDefaultTraceConfig()
                    }
                    #[inline]
                    pub unsafe fn AddIncludedCategory(
                        &mut self,
                        included_category: *const ::std::os::raw::c_char,
                    ) {
                        TraceConfig_AddIncludedCategory(self, included_category)
                    }
                    #[inline]
                    pub unsafe fn IsCategoryGroupEnabled(
                        &self,
                        category_group: *const ::std::os::raw::c_char,
                    ) -> bool {
                        TraceConfig_IsCategoryGroupEnabled(self, category_group)
                    }
                }
                #[repr(C)]
                #[derive(Debug, Hash, PartialEq, Eq)]
                pub struct TracingController {
                    pub _base: root::v8::TracingController,
                    pub trace_buffer_: u64,
                    pub trace_config_: u64,
                    pub mutex_: u64,
                    pub observers_: [u64; 8usize],
                    pub mode_: root::v8::platform::tracing::TracingController_Mode,
                }
                pub const TracingController_Mode_DISABLED:
                    root::v8::platform::tracing::TracingController_Mode = 0;
                pub const TracingController_Mode_RECORDING_MODE:
                    root::v8::platform::tracing::TracingController_Mode = 1;
                pub type TracingController_Mode = i32;
                pub const TracingController_CategoryGroupEnabledFlags_ENABLED_FOR_RECORDING:
                    root::v8::platform::tracing::TracingController_CategoryGroupEnabledFlags = 1;
                pub const TracingController_CategoryGroupEnabledFlags_ENABLED_FOR_EVENT_CALLBACK:
                    root::v8::platform::tracing::TracingController_CategoryGroupEnabledFlags = 4;
                pub const TracingController_CategoryGroupEnabledFlags_ENABLED_FOR_ETW_EXPORT:
                    root::v8::platform::tracing::TracingController_CategoryGroupEnabledFlags = 8;
                pub type TracingController_CategoryGroupEnabledFlags = i32;
                #[test]
                fn bindgen_test_layout_TracingController() {
                    assert_eq!(
                        ::std::mem::size_of::<TracingController>(),
                        104usize,
                        concat!("Size of: ", stringify!(TracingController))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<TracingController>(),
                        8usize,
                        concat!("Alignment of ", stringify!(TracingController))
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TracingController>())).trace_buffer_ as *const _
                                as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TracingController),
                            "::",
                            stringify!(trace_buffer_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TracingController>())).trace_config_ as *const _
                                as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TracingController),
                            "::",
                            stringify!(trace_config_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TracingController>())).mutex_ as *const _
                                as usize
                        },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TracingController),
                            "::",
                            stringify!(mutex_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TracingController>())).observers_ as *const _
                                as usize
                        },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TracingController),
                            "::",
                            stringify!(observers_)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            &(*(::std::ptr::null::<TracingController>())).mode_ as *const _ as usize
                        },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(TracingController),
                            "::",
                            stringify!(mode_)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?Initialize@TracingController@tracing@platform@v8@@QEAAXPEAVTraceBuffer@234@@Z"]
                    pub fn TracingController_Initialize(
                        this: *mut root::v8::platform::tracing::TracingController,
                        trace_buffer: *mut root::v8::platform::tracing::TraceBuffer,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?StartTracing@TracingController@tracing@platform@v8@@QEAAXPEAVTraceConfig@234@@Z"]
                    pub fn TracingController_StartTracing(
                        this: *mut root::v8::platform::tracing::TracingController,
                        trace_config: *mut root::v8::platform::tracing::TraceConfig,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?StopTracing@TracingController@tracing@platform@v8@@QEAAXXZ"]
                    pub fn TracingController_StopTracing(
                        this: *mut root::v8::platform::tracing::TracingController,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?GetCategoryGroupName@TracingController@tracing@platform@v8@@SAPEBDPEBE@Z"]
                    pub fn TracingController_GetCategoryGroupName(
                        category_enabled_flag: *const u8,
                    ) -> *const ::std::os::raw::c_char;
                }
                extern "C" {
                    #[link_name = "\u{1}??0TracingController@tracing@platform@v8@@QEAA@XZ"]
                    pub fn TracingController_TracingController(
                        this: *mut root::v8::platform::tracing::TracingController,
                    );
                }
                impl TracingController {
                    #[inline]
                    pub unsafe fn Initialize(
                        &mut self,
                        trace_buffer: *mut root::v8::platform::tracing::TraceBuffer,
                    ) {
                        TracingController_Initialize(self, trace_buffer)
                    }
                    #[inline]
                    pub unsafe fn StartTracing(
                        &mut self,
                        trace_config: *mut root::v8::platform::tracing::TraceConfig,
                    ) {
                        TracingController_StartTracing(self, trace_config)
                    }
                    #[inline]
                    pub unsafe fn StopTracing(&mut self) {
                        TracingController_StopTracing(self)
                    }
                    #[inline]
                    pub unsafe fn GetCategoryGroupName(
                        category_enabled_flag: *const u8,
                    ) -> *const ::std::os::raw::c_char {
                        TracingController_GetCategoryGroupName(category_enabled_flag)
                    }
                    #[inline]
                    pub unsafe fn new() -> Self {
                        let mut __bindgen_tmp = ::std::mem::uninitialized();
                        TracingController_TracingController(&mut __bindgen_tmp);
                        __bindgen_tmp
                    }
                }
                extern "C" {
                    #[link_name = "\u{1}??_DTracingController@tracing@platform@v8@@QEAAXXZ"]
                    pub fn TracingController_TracingController_destructor(
                        this: *mut root::v8::platform::tracing::TracingController,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?GetCategoryGroupEnabled@TracingController@tracing@platform@v8@@UEAAPEBEPEBD@Z"]
                    pub fn TracingController_GetCategoryGroupEnabled(
                        this: *mut ::std::os::raw::c_void,
                        category_group: *const ::std::os::raw::c_char,
                    ) -> *const u8;
                }
                extern "C" {
                    #[link_name = "\u{1}?AddTraceEvent@TracingController@tracing@platform@v8@@UEAA_KDPEBEPEBD1_K2HPEAPEBD0PEB_KPEAV?$unique_ptr@VConvertableToTraceFormat@v8@@U?$default_delete@VConvertableToTraceFormat@v8@@@std@@@std@@I@Z"]
                    pub fn TracingController_AddTraceEvent(
                        this: *mut ::std::os::raw::c_void,
                        phase: ::std::os::raw::c_char,
                        category_enabled_flag: *const u8,
                        name: *const ::std::os::raw::c_char,
                        scope: *const ::std::os::raw::c_char,
                        id: u64,
                        bind_id: u64,
                        num_args: i32,
                        arg_names: *mut *const ::std::os::raw::c_char,
                        arg_types: *const u8,
                        arg_values: *const u64,
                        arg_convertables: *mut u64,
                        flags: ::std::os::raw::c_uint,
                    ) -> u64;
                }
                extern "C" {
                    #[link_name = "\u{1}?AddTraceEventWithTimestamp@TracingController@tracing@platform@v8@@UEAA_KDPEBEPEBD1_K2HPEAPEBD0PEB_KPEAV?$unique_ptr@VConvertableToTraceFormat@v8@@U?$default_delete@VConvertableToTraceFormat@v8@@@std@@@std@@I_J@Z"]
                    pub fn TracingController_AddTraceEventWithTimestamp(
                        this: *mut ::std::os::raw::c_void,
                        phase: ::std::os::raw::c_char,
                        category_enabled_flag: *const u8,
                        name: *const ::std::os::raw::c_char,
                        scope: *const ::std::os::raw::c_char,
                        id: u64,
                        bind_id: u64,
                        num_args: i32,
                        arg_names: *mut *const ::std::os::raw::c_char,
                        arg_types: *const u8,
                        arg_values: *const u64,
                        arg_convertables: *mut u64,
                        flags: ::std::os::raw::c_uint,
                        timestamp: i64,
                    ) -> u64;
                }
                extern "C" {
                    #[link_name = "\u{1}?UpdateTraceEventDuration@TracingController@tracing@platform@v8@@UEAAXPEBEPEBD_K@Z"]
                    pub fn TracingController_UpdateTraceEventDuration(
                        this: *mut ::std::os::raw::c_void,
                        category_enabled_flag: *const u8,
                        name: *const ::std::os::raw::c_char,
                        handle: u64,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?AddTraceStateObserver@TracingController@tracing@platform@v8@@UEAAXPEAVTraceStateObserver@14@@Z"]
                    pub fn TracingController_AddTraceStateObserver(
                        this: *mut ::std::os::raw::c_void,
                        observer: *mut root::v8::TracingController_TraceStateObserver,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?RemoveTraceStateObserver@TracingController@tracing@platform@v8@@UEAAXPEAVTraceStateObserver@14@@Z"]
                    pub fn TracingController_RemoveTraceStateObserver(
                        this: *mut ::std::os::raw::c_void,
                        observer: *mut root::v8::TracingController_TraceStateObserver,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?CurrentTimestampMicroseconds@TracingController@tracing@platform@v8@@MEAA_JXZ"]
                    pub fn TracingController_CurrentTimestampMicroseconds(
                        this: *mut ::std::os::raw::c_void,
                    ) -> i64;
                }
                extern "C" {
                    #[link_name = "\u{1}?CurrentCpuTimestampMicroseconds@TracingController@tracing@platform@v8@@MEAA_JXZ"]
                    pub fn TracingController_CurrentCpuTimestampMicroseconds(
                        this: *mut ::std::os::raw::c_void,
                    ) -> i64;
                }
            }
            pub const IdleTaskSupport_kDisabled: root::v8::platform::IdleTaskSupport = 0;
            pub const IdleTaskSupport_kEnabled: root::v8::platform::IdleTaskSupport = 1;
            pub type IdleTaskSupport = i32;
            pub const InProcessStackDumping_kDisabled: root::v8::platform::InProcessStackDumping =
                0;
            pub const InProcessStackDumping_kEnabled: root::v8::platform::InProcessStackDumping = 1;
            pub type InProcessStackDumping = i32;
            pub const MessageLoopBehavior_kDoNotWait: root::v8::platform::MessageLoopBehavior = 0;
            pub const MessageLoopBehavior_kWaitForWork: root::v8::platform::MessageLoopBehavior = 1;
            pub type MessageLoopBehavior = u8;
            extern "C" {
                /// Returns a new instance of the default v8::Platform implementation.
                ///
                /// The caller will take ownership of the returned pointer. |thread_pool_size|
                /// is the number of worker threads to allocate for background jobs. If a value
                /// of zero is passed, a suitable default based on the current number of
                /// processors online will be chosen.
                /// If |idle_task_support| is enabled then the platform will accept idle
                /// tasks (IdleTasksEnabled will return true) and will rely on the embedder
                /// calling v8::platform::RunIdleTasks to process the idle tasks.
                /// If |tracing_controller| is nullptr, the default platform will create a
                /// v8::platform::TracingController instance and use it.
                #[link_name = "\u{1}?NewDefaultPlatform@platform@v8@@YA?AV?$unique_ptr@VPlatform@v8@@U?$default_delete@VPlatform@v8@@@std@@@std@@HW4IdleTaskSupport@12@W4InProcessStackDumping@12@V?$unique_ptr@VTracingController@v8@@U?$default_delete@VTracingController@v8@@@std@@@4@@Z"]
                pub fn NewDefaultPlatform(
                    thread_pool_size: ::std::os::raw::c_int,
                    idle_task_support: root::v8::platform::IdleTaskSupport,
                    in_process_stack_dumping: root::v8::platform::InProcessStackDumping,
                    tracing_controller: u64,
                ) -> u8;
            }
            extern "C" {
                #[link_name = "\u{1}?CreateDefaultPlatform@platform@v8@@YAPEAVPlatform@2@HW4IdleTaskSupport@12@W4InProcessStackDumping@12@PEAVTracingController@2@@Z"]
                pub fn CreateDefaultPlatform(
                    thread_pool_size: ::std::os::raw::c_int,
                    idle_task_support: root::v8::platform::IdleTaskSupport,
                    in_process_stack_dumping: root::v8::platform::InProcessStackDumping,
                    tracing_controller: *mut root::v8::TracingController,
                ) -> *mut root::v8::Platform;
            }
            extern "C" {
                /// Pumps the message loop for the given isolate.
                ///
                /// The caller has to make sure that this is called from the right thread.
                /// Returns true if a task was executed, and false otherwise. Unless requested
                /// through the |behavior| parameter, this call does not block if no task is
                /// pending. The |platform| has to be created using |NewDefaultPlatform|.
                #[link_name = "\u{1}?PumpMessageLoop@platform@v8@@YA_NPEAVPlatform@2@PEAVIsolate@2@W4MessageLoopBehavior@12@@Z"]
                pub fn PumpMessageLoop(
                    platform: *mut root::v8::Platform,
                    isolate: *mut root::v8::Isolate,
                    behavior: root::v8::platform::MessageLoopBehavior,
                ) -> bool;
            }
            extern "C" {
                /// Runs pending idle tasks for at most |idle_time_in_seconds| seconds.
                ///
                /// The caller has to make sure that this is called from the right thread.
                /// This call does not block if no task is pending. The |platform| has to be
                /// created using |NewDefaultPlatform|.
                #[link_name = "\u{1}?RunIdleTasks@platform@v8@@YAXPEAVPlatform@2@PEAVIsolate@2@N@Z"]
                pub fn RunIdleTasks(
                    platform: *mut root::v8::Platform,
                    isolate: *mut root::v8::Isolate,
                    idle_time_in_seconds: f64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetTracingController@platform@v8@@YAXPEAVPlatform@2@PEAVTracingController@tracing@12@@Z"]
                pub fn SetTracingController(
                    platform: *mut root::v8::Platform,
                    tracing_controller: *mut root::v8::platform::tracing::TracingController,
                );
            }
        }
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_PrimitiveArray_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_PrimitiveArray_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Primitive_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Primitive>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Primitive>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Primitive>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Primitive>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Primitive_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Primitive>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Primitive>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Primitive>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Primitive>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_PrimitiveArray_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_UnboundScript_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::UnboundScript>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::UnboundScript>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::UnboundScript>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::UnboundScript>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_PrimitiveArray_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::PrimitiveArray>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::PrimitiveArray>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_UnboundScript_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::UnboundScript>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::UnboundScript>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::UnboundScript>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::UnboundScript>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_StackTrace_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_StackTrace_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Object_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Object_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Boolean_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Boolean>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Boolean>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Boolean>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Boolean>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Integer_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Integer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Integer>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_34() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_35() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_36() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_37() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_38() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_39() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_40() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_41() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_34() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_42() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_43() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_35() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_44() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_36() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_45() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_37() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_38() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_46() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_39() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_47() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_48() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_49() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_50() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_40() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_51() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_41() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_52() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_53() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_42() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_54() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_55() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_56() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_57() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_58() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_59() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_43() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_60() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_44() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_61() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_String_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_62() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_45() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_63() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_64() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_65() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_66() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_67() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_68() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_69() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_70() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_71() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_72() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_73() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_46() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_47() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_74() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_48() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_75() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_49() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_76() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_50() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_51() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_77() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_52() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_78() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_53() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_79() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_54() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_80() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_55() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_81() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_56() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_82() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_57() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_58() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_83() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_59() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Object_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_84() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_60() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Object_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_61() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_62() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_63() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_85() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_64() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_65() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_66() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_67() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_68() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_69() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_70() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_86() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Promise_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_87() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_71() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_88() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_72() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_89() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_90() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_73() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_74() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_75() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_76() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_77() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_78() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_79() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_80() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_81() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_82() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_91() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_34() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_83() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Promise_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Persistent_open0_Promise_CopyablePersistentTraits_open1_Promise_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Persistent<root::v8::Promise>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Persistent<root::v8::Promise>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Persistent<root::v8::Promise>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Persistent<root::v8::Promise>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_84() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_92() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_85() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_86() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_87() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_35() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_88() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_36() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_89() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_93() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_37() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_38() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Data_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Data>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Data>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Data>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Data>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Data_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Data>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Data>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Data>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Data>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_39() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_90() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_AccessorSignature_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_91() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_AccessorSignature_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_92() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_93() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_94() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_94() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_95() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_96() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Signature_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Signature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Signature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Signature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Signature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_97() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Signature_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Signature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Signature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Signature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Signature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_95() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Object_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_98() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_40() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_99() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_100() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_101() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_ObjectTemplate_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::ObjectTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::ObjectTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::ObjectTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::ObjectTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_96() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Object_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_41() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_102() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_AccessorSignature_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Name_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Name>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Name>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_103() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_AccessorSignature_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_104() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_105() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_106() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Signature_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Signature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Signature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Signature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Signature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_FunctionTemplate_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::FunctionTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::FunctionTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_AccessorSignature_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::AccessorSignature>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::AccessorSignature>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_107() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_42() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_108() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_43() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_109() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_44() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_110() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_45() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_111() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_46() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_112() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_113() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_114() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_StackTrace_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_97() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_47() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_98() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Promise_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_115() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Promise_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Promise>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Promise>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_116() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_StackTrace_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::StackTrace>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::StackTrace>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_117() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_99() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_48() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_100() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_49() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_101() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_UnboundScript_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::UnboundScript>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::UnboundScript>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::UnboundScript>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::UnboundScript>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_102() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_103() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_104() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_105() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_118() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_119() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Function_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Function>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Function>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_120() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_121() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_106() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_107() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_122() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_123() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_108() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_ObjectTemplate_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::ObjectTemplate>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::ObjectTemplate>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::ObjectTemplate>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::ObjectTemplate>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_109() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Value_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MaybeLocal_open0_Object_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::MaybeLocal<root::v8::Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::MaybeLocal<root::v8::Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_124() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_125() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Value_close0_instantiation_126() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_String_close0_instantiation_50() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::String>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::String>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_110() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_111() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Local_open0_Context_close0_instantiation_112() {
        assert_eq!(
            ::std::mem::size_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::v8::Local<root::v8::Context>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::v8::Local<root::v8::Context>)
            )
        );
    }
}
